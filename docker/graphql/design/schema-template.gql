  # declares the query entry-points for this type
  extend type Query {
    <typeName>(id: ID!): <type-name> 
	  <typeName-plural>(
        first: Int
        offset: Int
        orderBy: <type-name>Ordering
        orderMode: OrderingMode
        filters: [<type-name>Filtering]
        filterMode: FilterMode
        search: String
    ): [<type-name>] 
	...						
  }

  # declares the mutation entry-points for this type
  extend type Mutation {	
	<typeName>Add(input: <type>AddInput): <type-name> 
	<typeName>Delete(id: ID!): ID!
	<typeName>Edit(id: ID!, input: [EditInput]!, commitMessage: String): <type-name>
	# <typeName>Edit(id: ID!): <type>EditMutations
	...
  }

  # declares the subscription entry-points for this type
  extend type Subscription {
	...				
  }

  # Type Definitions
  type <type-name> implements <interface-name> & <interface-name> {
    object_id: ID!				# unique identifier
	  object_type: String!	# type of object
	  created_by: OrganizationOrIndividual	# union
	  created_at: DateTime!		# time object was created
	  modified_at: DateTime!		# time object was last modified
	  revoked: Boolean!		# object is revoked
	  object_markings: [MarkingDefinition]
	  object_markings: MarkingDefinitionConnection
	  # extensions: [ID]		# ID of extension definitions
    ...						# defined each field for this specific type
  }

  # Ordering Types
  enum <type-name>Ordering {
	...				# defines list of field-names to order results on for this type
  }

  # Filtering Types
  enum <type-name>Filter {
	...				# defines list of field-names to filter results on for this type
  }

  input <type-name>Filtering {
    key: <type-name>Filter!
    values: [String]
    operator: String		# match, wildcard, gt (>), lt (<), gte (>=), lte (<=)>), eq (=), ne (!=)
    filterMode: FilterMode
  }

  # Pagination Types
  type <type-name>Connection {
	pageInfo: PageInfo!
	edges: [<type-name>Edge]
  }

  type <type-name>Edge {
	cursor: String!
	node: <type-name>!
  }

  # Mutation Types
  input <type-name>AddInput {
    ...						# defined field for this specific type that the user can supply
  }

  # type <type-name>EditMutations {
  #   delete: ID 
  #   fieldPatch(input: [EditInput]!, commitMessage: String): <type-name> 
  #   contextPatch(input: EditContext): <type-name> 
  #   contextClean: <type-name> 
  #   relationAdd(input:StixMetaRelationshipAddInput): StixMetaRelationship 
  #   relationDelete(toId: String!, relationship_type: String!): <type-name> 
  # }
