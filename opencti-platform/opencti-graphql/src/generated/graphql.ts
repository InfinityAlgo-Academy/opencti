import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import type { BasicStoreEntityChannel } from '../modules/channel/channel-types';
import type { BasicStoreEntityLanguage } from '../modules/language/language-types';
import type { BasicStoreEntityEvent } from '../modules/event/event-types';
import type { BasicStoreEntityNarrative } from '../modules/narrative/narrative-types';
import type { BasicStoreEntityGrouping } from '../modules/grouping/grouping-types';
import type { BasicStoreEntityDataSource } from '../modules/dataSource/dataSource-types';
import type { BasicStoreEntityDataComponent } from '../modules/dataComponent/dataComponent-types';
import type { BasicStoreEntityVocabulary } from '../modules/vocabulary/vocabulary-types';
import type { BasicStoreEntityAdministrativeArea } from '../modules/administrativeArea/administrativeArea-types';
import type { BasicStoreEntityCase } from '../modules/case/case-types';
import type { BasicStoreEntityEntitySetting } from '../modules/entitySetting/entitySetting-types';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  ConstraintNumber: any;
  ConstraintString: any;
  DateTime: any;
  StixId: any;
  StixRef: any;
  Upload: any;
};

export type AckDetails = {
  __typename?: 'AckDetails';
  rate?: Maybe<Scalars['Float']>;
};

export type AdministrativeArea = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'AdministrativeArea';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  country?: Maybe<Country>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type AdministrativeAreaCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type AdministrativeAreaExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AdministrativeAreaStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AdministrativeAreaStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AdministrativeAreaStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AdministrativeAreaAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type AdministrativeAreaConnection = {
  __typename?: 'AdministrativeAreaConnection';
  edges?: Maybe<Array<AdministrativeAreaEdge>>;
  pageInfo: PageInfo;
};

export type AdministrativeAreaEdge = {
  __typename?: 'AdministrativeAreaEdge';
  cursor: Scalars['String'];
  node: AdministrativeArea;
};

export enum AdministrativeAreasFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type AdministrativeAreasFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<AdministrativeAreasFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum AdministrativeAreasOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type AppDebugDistribution = {
  __typename?: 'AppDebugDistribution';
  label: Scalars['String'];
  value?: Maybe<Scalars['Int']>;
};

export type AppDebugStatistics = {
  __typename?: 'AppDebugStatistics';
  objects?: Maybe<Array<Maybe<AppDebugDistribution>>>;
  relationships?: Maybe<Array<Maybe<AppDebugDistribution>>>;
};

/** Retrieve the application information version add dependencies */
export type AppInfo = {
  __typename?: 'AppInfo';
  /** The objects statistics */
  debugStats?: Maybe<AppDebugStatistics>;
  /** The list of OpenCTI software dependencies */
  dependencies: Array<DependencyVersion>;
  /** The OpenCTI api current memory usage */
  memory?: Maybe<AppMemory>;
  /** The OpenCTI application version */
  version: Scalars['String'];
};

/**
 * NodeJs memory.
 * https://nodejs.org/api/process.html#process_process_memoryusage
 * https://nodejs.org/docs/latest-v11.x/api/v8.html#v8_v8_getheapstatistics
 */
export type AppMemory = {
  __typename?: 'AppMemory';
  arrayBuffers?: Maybe<Scalars['Float']>;
  does_zap_garbage?: Maybe<Scalars['Float']>;
  external?: Maybe<Scalars['Float']>;
  heapTotal?: Maybe<Scalars['Float']>;
  heapUsed?: Maybe<Scalars['Float']>;
  heap_size_limit?: Maybe<Scalars['Float']>;
  malloced_memory?: Maybe<Scalars['Float']>;
  peak_malloced_memory?: Maybe<Scalars['Float']>;
  rss?: Maybe<Scalars['Float']>;
  total_available_size?: Maybe<Scalars['Float']>;
  total_heap_size?: Maybe<Scalars['Float']>;
  total_heap_size_executable?: Maybe<Scalars['Float']>;
  total_physical_size?: Maybe<Scalars['Float']>;
  used_heap_size?: Maybe<Scalars['Float']>;
};

export type Artifact = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Artifact';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  decryption_key?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  encryption_algorithm?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  mime_type?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  payload_bin?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  url?: Maybe<Scalars['String']>;
  x_opencti_additional_names?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ArtifactCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ArtifactExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ArtifactStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ArtifactStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ArtifactStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ArtifactAddInput = {
  decryption_key?: InputMaybe<Scalars['String']>;
  encryption_algorithm?: InputMaybe<Scalars['String']>;
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  mime_type?: InputMaybe<Scalars['String']>;
  payload_bin?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  x_opencti_additional_names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type Assignee = {
  __typename?: 'Assignee';
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  user_email: Scalars['String'];
};

export type AssigneeConnection = {
  __typename?: 'AssigneeConnection';
  edges: Array<AssigneeEdge>;
  pageInfo: PageInfo;
};

export type AssigneeEdge = {
  __typename?: 'AssigneeEdge';
  cursor: Scalars['String'];
  node: Assignee;
};

export type AttackPattern = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'AttackPattern';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  coursesOfAction?: Maybe<CourseOfActionConnection>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  dataComponents?: Maybe<DataComponentConnection>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  isSubAttackPattern?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentAttackPatterns?: Maybe<AttackPatternConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  subAttackPatterns?: Maybe<AttackPatternConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_detection?: Maybe<Scalars['String']>;
  x_mitre_id?: Maybe<Scalars['String']>;
  x_mitre_permissions_required?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_mitre_platforms?: Maybe<Array<Scalars['String']>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type AttackPatternCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type AttackPatternExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AttackPatternStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AttackPatternStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AttackPatternAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_mitre_detection?: InputMaybe<Scalars['String']>;
  x_mitre_id?: InputMaybe<Scalars['String']>;
  x_mitre_permissions_required?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_mitre_platforms?: InputMaybe<Array<Scalars['String']>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type AttackPatternConnection = {
  __typename?: 'AttackPatternConnection';
  edges: Array<AttackPatternEdge>;
  pageInfo: PageInfo;
};

export type AttackPatternEdge = {
  __typename?: 'AttackPatternEdge';
  cursor: Scalars['String'];
  node: AttackPattern;
};

export type AttackPatternEditMutations = {
  __typename?: 'AttackPatternEditMutations';
  contextClean?: Maybe<AttackPattern>;
  contextPatch?: Maybe<AttackPattern>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<AttackPattern>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<AttackPattern>;
};


export type AttackPatternEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type AttackPatternEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AttackPatternEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type AttackPatternEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum AttackPatternsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  MitigatedBy = 'mitigatedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type AttackPatternsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<AttackPatternsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum AttackPatternsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Attribute = {
  __typename?: 'Attribute';
  id: Scalars['ID'];
  key: Scalars['String'];
  value: Scalars['String'];
};

export type AttributeConnection = {
  __typename?: 'AttributeConnection';
  edges?: Maybe<Array<Maybe<AttributeEdge>>>;
  pageInfo: PageInfo;
};

export type AttributeEdge = {
  __typename?: 'AttributeEdge';
  cursor: Scalars['String'];
  node: Attribute;
};

export type AttributeEditMutations = {
  __typename?: 'AttributeEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Attribute>;
};


export type AttributeEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum AttributesOrdering {
  Value = 'value'
}

export type AutonomousSystem = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'AutonomousSystem';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  number?: Maybe<Scalars['Int']>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  rir?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type AutonomousSystemCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type AutonomousSystemExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AutonomousSystemStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AutonomousSystemStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AutonomousSystemStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AutonomousSystemAddInput = {
  name?: InputMaybe<Scalars['String']>;
  number: Scalars['Int'];
  rir?: InputMaybe<Scalars['String']>;
};

export type BankAccount = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'BankAccount';
  account_number?: Maybe<Scalars['String']>;
  bic?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  iban?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type BankAccountCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type BankAccountExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type BankAccountStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type BankAccountStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type BankAccountStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type BankAccountStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type BankAccountAddInput = {
  account_number?: InputMaybe<Scalars['String']>;
  bic?: InputMaybe<Scalars['String']>;
  iban?: InputMaybe<Scalars['String']>;
};

export type BasicObject = {
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
};

export type BasicRelationship = {
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  entity_type: Scalars['String'];
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
};

export type Campaign = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Campaign';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objective?: Maybe<Scalars['String']>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CampaignCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CampaignExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CampaignStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CampaignStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CampaignAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objective?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type CampaignConnection = {
  __typename?: 'CampaignConnection';
  edges?: Maybe<Array<Maybe<CampaignEdge>>>;
  pageInfo: PageInfo;
};

export type CampaignEdge = {
  __typename?: 'CampaignEdge';
  cursor: Scalars['String'];
  node: Campaign;
};

export type CampaignEditMutations = {
  __typename?: 'CampaignEditMutations';
  contextClean?: Maybe<Campaign>;
  contextPatch?: Maybe<Campaign>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Campaign>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Campaign>;
};


export type CampaignEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CampaignEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CampaignEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CampaignEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum CampaignsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type CampaignsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<CampaignsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CampaignsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  RolePlayed = 'role_played',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export enum Capabilities {
  Connectorapi = 'CONNECTORAPI',
  Explore = 'EXPLORE',
  ExploreExupdate = 'EXPLORE_EXUPDATE',
  ExploreExupdateExdelete = 'EXPLORE_EXUPDATE_EXDELETE',
  Knowledge = 'KNOWLEDGE',
  KnowledgeKnaskimport = 'KNOWLEDGE_KNASKIMPORT',
  KnowledgeKnenrichment = 'KNOWLEDGE_KNENRICHMENT',
  KnowledgeKngetexport = 'KNOWLEDGE_KNGETEXPORT',
  KnowledgeKngetexportKnaskexport = 'KNOWLEDGE_KNGETEXPORT_KNASKEXPORT',
  KnowledgeKnparticipate = 'KNOWLEDGE_KNPARTICIPATE',
  KnowledgeKnupdate = 'KNOWLEDGE_KNUPDATE',
  KnowledgeKnupdateKndelete = 'KNOWLEDGE_KNUPDATE_KNDELETE',
  KnowledgeKnupdateKnorgarestrict = 'KNOWLEDGE_KNUPDATE_KNORGARESTRICT',
  KnowledgeKnupload = 'KNOWLEDGE_KNUPLOAD',
  Modules = 'MODULES',
  ModulesModmanage = 'MODULES_MODMANAGE',
  Settings = 'SETTINGS',
  SettingsSetaccesses = 'SETTINGS_SETACCESSES',
  SettingsSetlabels = 'SETTINGS_SETLABELS',
  SettingsSetmarkings = 'SETTINGS_SETMARKINGS',
  TaxiiapiSetcollections = 'TAXIIAPI_SETCOLLECTIONS'
}

export type Capability = BasicObject & InternalObject & {
  __typename?: 'Capability';
  attribute_order?: Maybe<Scalars['Int']>;
  created_at: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type CapabilityConnection = {
  __typename?: 'CapabilityConnection';
  edges?: Maybe<Array<Maybe<CapabilityEdge>>>;
  pageInfo: PageInfo;
};

export type CapabilityEdge = {
  __typename?: 'CapabilityEdge';
  cursor: Scalars['String'];
  node: Capability;
};

export type Case = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Case';
  case_type: Scalars['String'];
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  priority?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['Int']>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  severity?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CaseCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CaseExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CaseObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CasePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CaseReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CaseStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CaseStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CaseStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CaseAddInput = {
  case_type: Scalars['String'];
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  file?: InputMaybe<Scalars['Upload']>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  priority?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['Int']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  severity?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type CaseConnection = {
  __typename?: 'CaseConnection';
  edges?: Maybe<Array<Maybe<CaseEdge>>>;
  pageInfo: PageInfo;
};

export type CaseEdge = {
  __typename?: 'CaseEdge';
  cursor: Scalars['String'];
  node: Case;
};

export enum CasesFilter {
  AssigneeTo = 'assigneeTo',
  CaseType = 'case_type',
  Confidence = 'confidence',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Priority = 'priority',
  Rating = 'rating',
  Severity = 'severity',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type CasesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<CasesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CasesOrdering {
  CaseType = 'case_type',
  Confidence = 'confidence',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Priority = 'priority',
  Rating = 'rating',
  Severity = 'severity',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Channel = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Channel';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  channel_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ChannelCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ChannelExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ChannelStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ChannelStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ChannelStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ChannelAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  channel_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ChannelConnection = {
  __typename?: 'ChannelConnection';
  edges?: Maybe<Array<Maybe<ChannelEdge>>>;
  pageInfo: PageInfo;
};

export type ChannelEdge = {
  __typename?: 'ChannelEdge';
  cursor: Scalars['String'];
  node: Channel;
};

export enum ChannelsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  ChannelTypes = 'channel_types',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ChannelsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ChannelsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ChannelsOrdering {
  ChannelTypes = 'channel_types',
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export enum CitiesFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type CitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<CitiesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CitiesOrdering {
  Aliases = 'aliases',
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type City = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'City';
  administrativeArea?: Maybe<AdministrativeArea>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  country?: Maybe<Country>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CityCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CityStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type CityConnection = {
  __typename?: 'CityConnection';
  edges?: Maybe<Array<Maybe<CityEdge>>>;
  pageInfo: PageInfo;
};

export type CityEdge = {
  __typename?: 'CityEdge';
  cursor: Scalars['String'];
  node: City;
};

export type CityEditMutations = {
  __typename?: 'CityEditMutations';
  contextClean?: Maybe<City>;
  contextPatch?: Maybe<City>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<City>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<City>;
};


export type CityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type Cluster = {
  __typename?: 'Cluster';
  instances_number: Scalars['Int'];
};

export type Connector = BasicObject & InternalObject & {
  __typename?: 'Connector';
  active?: Maybe<Scalars['Boolean']>;
  auto?: Maybe<Scalars['Boolean']>;
  config?: Maybe<ConnectorConfig>;
  connector_scope?: Maybe<Array<Scalars['String']>>;
  connector_state?: Maybe<Scalars['String']>;
  connector_state_reset?: Maybe<Scalars['Boolean']>;
  connector_type?: Maybe<Scalars['String']>;
  connector_user_id: Scalars['ID'];
  created_at?: Maybe<Scalars['DateTime']>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  only_contextual?: Maybe<Scalars['Boolean']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at?: Maybe<Scalars['DateTime']>;
  works?: Maybe<Array<Maybe<Work>>>;
};


export type ConnectorWorksArgs = {
  status?: InputMaybe<Scalars['String']>;
};

export type ConnectorConfig = {
  __typename?: 'ConnectorConfig';
  connection: RabbitMqConnection;
  listen: Scalars['String'];
  listen_exchange: Scalars['String'];
  listen_routing: Scalars['String'];
  push: Scalars['String'];
  push_exchange: Scalars['String'];
  push_routing: Scalars['String'];
};

export enum ConnectorType {
  ExternalImport = 'EXTERNAL_IMPORT',
  InternalEnrichment = 'INTERNAL_ENRICHMENT',
  InternalExportFile = 'INTERNAL_EXPORT_FILE',
  InternalImportFile = 'INTERNAL_IMPORT_FILE',
  Stream = 'STREAM'
}

export type Container = {
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ContainerCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ContainerConnection = {
  __typename?: 'ContainerConnection';
  edges?: Maybe<Array<Maybe<ContainerEdge>>>;
  pageInfo: PageInfo;
};

export type ContainerEdge = {
  __typename?: 'ContainerEdge';
  cursor: Scalars['String'];
  node: Container;
};

export type ContainerEditMutations = {
  __typename?: 'ContainerEditMutations';
  contextClean?: Maybe<Container>;
  contextPatch?: Maybe<Container>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Container>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Container>;
};


export type ContainerEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ContainerEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ContainerEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum ContainersFilter {
  AssigneeTo = 'assigneeTo',
  AttributeAbstract = 'attribute_abstract',
  Authors = 'authors',
  Confidence = 'confidence',
  Content = 'content',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ObjectContains = 'objectContains',
  ReportTypes = 'report_types',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ContainersFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ContainersFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ContainersOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ContextData = {
  __typename?: 'ContextData';
  commit?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  external_references?: Maybe<Array<ExternalReference>>;
  from_id?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  message: Scalars['String'];
  to_id?: Maybe<Scalars['String']>;
};

export enum CountriesFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type CountriesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<CountriesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CountriesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Country = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Country';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  region?: Maybe<Region>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CountryCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CountryExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CountryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CountryStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CountryAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type CountryConnection = {
  __typename?: 'CountryConnection';
  edges: Array<CountryEdge>;
  pageInfo: PageInfo;
};

export type CountryEdge = {
  __typename?: 'CountryEdge';
  cursor: Scalars['String'];
  node: Country;
};

export type CountryEditMutations = {
  __typename?: 'CountryEditMutations';
  contextClean?: Maybe<Country>;
  contextPatch?: Maybe<Country>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Country>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Country>;
};


export type CountryEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CountryEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CountryEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CountryEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type CourseOfAction = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'CourseOfAction';
  attackPatterns?: Maybe<AttackPatternConnection>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_id?: Maybe<Scalars['String']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_log_sources?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
  x_opencti_threat_hunting?: Maybe<Scalars['String']>;
};


export type CourseOfActionCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CourseOfActionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CourseOfActionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CourseOfActionStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CourseOfActionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_mitre_id?: InputMaybe<Scalars['String']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type CourseOfActionConnection = {
  __typename?: 'CourseOfActionConnection';
  edges?: Maybe<Array<Maybe<CourseOfActionEdge>>>;
  pageInfo: PageInfo;
};

export type CourseOfActionEdge = {
  __typename?: 'CourseOfActionEdge';
  cursor: Scalars['String'];
  node: CourseOfAction;
};

export type CourseOfActionEditMutations = {
  __typename?: 'CourseOfActionEditMutations';
  contextClean?: Maybe<CourseOfAction>;
  contextPatch?: Maybe<CourseOfAction>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<CourseOfAction>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<CourseOfAction>;
};


export type CourseOfActionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CourseOfActionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CourseOfActionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CourseOfActionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum CoursesOfActionFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  MitigatedBy = 'mitigatedBy',
  Modified = 'modified',
  Name = 'name',
  XMitreId = 'x_mitre_id',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type CoursesOfActionFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<CoursesOfActionFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CoursesOfActionOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Creator = {
  __typename?: 'Creator';
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type CreatorConnection = {
  __typename?: 'CreatorConnection';
  edges?: Maybe<Array<Maybe<CreatorEdge>>>;
  pageInfo: PageInfo;
};

export type CreatorEdge = {
  __typename?: 'CreatorEdge';
  cursor: Scalars['String'];
  node: Creator;
};

export type CryptocurrencyWallet = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'CryptocurrencyWallet';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CryptocurrencyWalletCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CryptocurrencyWalletExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptocurrencyWalletStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptocurrencyWalletStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptocurrencyWalletStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CryptocurrencyWalletAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type CryptographicKey = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'CryptographicKey';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type CryptographicKeyCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CryptographicKeyExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptographicKeyStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptographicKeyStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptographicKeyStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CryptographicKeyAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type DataComponent = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'DataComponent';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  attackPatterns?: Maybe<AttackPatternConnection>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  dataSource?: Maybe<DataSource>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type DataComponentCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DataComponentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataComponentStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DataComponentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DataComponentStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DataComponentAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  dataSource?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type DataComponentConnection = {
  __typename?: 'DataComponentConnection';
  edges?: Maybe<Array<Maybe<DataComponentEdge>>>;
  pageInfo: PageInfo;
};

export type DataComponentEdge = {
  __typename?: 'DataComponentEdge';
  cursor: Scalars['String'];
  node: DataComponent;
};

export enum DataComponentsFilter {
  Aliases = 'aliases',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type DataComponentsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<DataComponentsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum DataComponentsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type DataSource = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'DataSource';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  collection_layers?: Maybe<Array<Scalars['String']>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  dataComponents?: Maybe<DataComponentConnection>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_platforms?: Maybe<Array<Scalars['String']>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type DataSourceCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DataSourceExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourcePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DataSourceStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DataSourceStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DataSourceStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DataSourceAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  collection_layers?: InputMaybe<Array<Scalars['String']>>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  dataComponents?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_mitre_platforms?: InputMaybe<Array<Scalars['String']>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type DataSourceConnection = {
  __typename?: 'DataSourceConnection';
  edges?: Maybe<Array<Maybe<DataSourceEdge>>>;
  pageInfo: PageInfo;
};

export type DataSourceEdge = {
  __typename?: 'DataSourceEdge';
  cursor: Scalars['String'];
  node: DataSource;
};

export enum DataSourcesFilter {
  Aliases = 'aliases',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type DataSourcesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<DataSourcesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum DataSourcesOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

/** Dependency information containing the name and the deployed version. */
export type DependencyVersion = {
  __typename?: 'DependencyVersion';
  name: Scalars['String'];
  version: Scalars['String'];
};

export type Dictionary = {
  __typename?: 'Dictionary';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type DictionaryInput = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type Directory = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Directory';
  atime?: Maybe<Scalars['DateTime']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  ctime?: Maybe<Scalars['DateTime']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  mtime?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  path: Scalars['String'];
  path_enc?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type DirectoryCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DirectoryExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DirectoryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DirectoryStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DirectoryStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DirectoryAddInput = {
  atime?: InputMaybe<Scalars['DateTime']>;
  ctime?: InputMaybe<Scalars['DateTime']>;
  mtime?: InputMaybe<Scalars['DateTime']>;
  path: Scalars['String'];
  path_enc?: InputMaybe<Scalars['String']>;
};

export type Display = {
  __typename?: 'Display';
  if?: Maybe<Array<Maybe<DisplayStep>>>;
  then?: Maybe<Array<Maybe<DisplayStep>>>;
};

export type DisplayStep = {
  __typename?: 'DisplayStep';
  action?: Maybe<Scalars['String']>;
  identifier?: Maybe<Scalars['String']>;
  identifier_color?: Maybe<Scalars['String']>;
  relation?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  source_color?: Maybe<Scalars['String']>;
  target?: Maybe<Scalars['String']>;
  target_color?: Maybe<Scalars['String']>;
};

export type Distribution = {
  __typename?: 'Distribution';
  entity?: Maybe<StixObjectOrStixRelationship>;
  label: Scalars['String'];
  value?: Maybe<Scalars['Int']>;
};

export type DocsMetrics = {
  __typename?: 'DocsMetrics';
  count?: Maybe<Scalars['String']>;
};

export type DomainName = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'DomainName';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type DomainNameCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DomainNameExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNamePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DomainNameStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DomainNameStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DomainNameStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DomainNameAddInput = {
  value: Scalars['String'];
};

export type EditContext = {
  focusOn?: InputMaybe<Scalars['String']>;
};

export type EditInput = {
  key: Scalars['String'];
  operation?: InputMaybe<EditOperation>;
  value: Array<InputMaybe<Scalars['String']>>;
};

export enum EditOperation {
  Add = 'add',
  Remove = 'remove',
  Replace = 'replace'
}

export type EditUserContext = {
  __typename?: 'EditUserContext';
  focusOn?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

export type ElasticSearchMetrics = {
  __typename?: 'ElasticSearchMetrics';
  docs?: Maybe<DocsMetrics>;
  get?: Maybe<GetMetrics>;
  indexing?: Maybe<IndexingMetrics>;
  search?: Maybe<SearchMetrics>;
};

export type EmailAddr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailAddr';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  display_name?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type EmailAddrCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailAddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailAddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailAddrStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailAddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailAddrAddInput = {
  display_name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type EmailMessage = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailMessage';
  attribute_date?: Maybe<Scalars['DateTime']>;
  body?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content_type?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  is_multipart?: Maybe<Scalars['Boolean']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  message_id?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  received_lines?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  subject?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type EmailMessageCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailMessageExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessagePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMessageStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMessageStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMessageStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailMessageAddInput = {
  attribute_date?: InputMaybe<Scalars['DateTime']>;
  body?: InputMaybe<Scalars['String']>;
  content_type?: InputMaybe<Scalars['String']>;
  is_multipart?: InputMaybe<Scalars['Boolean']>;
  message_id?: InputMaybe<Scalars['String']>;
  received_lines?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  subject?: InputMaybe<Scalars['String']>;
};

export type EmailMimePartType = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailMimePartType';
  body?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content_disposition?: Maybe<Scalars['String']>;
  content_type?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type EmailMimePartTypeCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailMimePartTypeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMimePartTypeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMimePartTypeStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMimePartTypeStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailMimePartTypeAddInput = {
  body?: InputMaybe<Scalars['String']>;
  content_disposition?: InputMaybe<Scalars['String']>;
  content_type?: InputMaybe<Scalars['String']>;
};

export type EntitySetting = BasicObject & InternalObject & {
  __typename?: 'EntitySetting';
  created_at: Scalars['DateTime'];
  enforce_reference?: Maybe<Scalars['Boolean']>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  parent_types: Array<Scalars['String']>;
  platform_entity_files_ref?: Maybe<Scalars['Boolean']>;
  platform_hidden_type?: Maybe<Scalars['Boolean']>;
  standard_id: Scalars['String'];
  target_type: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type EntitySettingConnection = {
  __typename?: 'EntitySettingConnection';
  edges: Array<EntitySettingEdge>;
  pageInfo: PageInfo;
};

export type EntitySettingEdge = {
  __typename?: 'EntitySettingEdge';
  cursor: Scalars['String'];
  node: EntitySetting;
};

export enum EntitySettingsFilter {
  TargetType = 'target_type'
}

export type EntitySettingsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<EntitySettingsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum EntitySettingsOrdering {
  TargetType = 'target_type'
}

export type Event = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Event';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  event_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_time?: Maybe<Scalars['DateTime']>;
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stop_time?: Maybe<Scalars['DateTime']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type EventCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EventExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EventStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EventStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EventStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EventAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  event_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  start_time?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  stop_time?: InputMaybe<Scalars['DateTime']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type EventConnection = {
  __typename?: 'EventConnection';
  edges?: Maybe<Array<Maybe<EventEdge>>>;
  pageInfo: PageInfo;
};

export type EventEdge = {
  __typename?: 'EventEdge';
  cursor: Scalars['String'];
  node: Event;
};

export enum EventsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EventTypes = 'event_types',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type EventsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<EventsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum EventsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  EventTypes = 'event_types',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ExternalReference = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'ExternalReference';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  external_id?: Maybe<Scalars['String']>;
  fileId?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  references?: Maybe<StixObjectOrStixRelationshipConnection>;
  source_name: Scalars['String'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  url?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ExternalReferenceConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ExternalReferenceExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferencePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceReferencesArgs = {
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ExternalReferenceAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  description?: InputMaybe<Scalars['String']>;
  external_id?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['Upload']>;
  hash?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  source_name: Scalars['String'];
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  url?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ExternalReferenceConnection = {
  __typename?: 'ExternalReferenceConnection';
  edges: Array<ExternalReferenceEdge>;
  pageInfo: PageInfo;
};

export type ExternalReferenceEdge = {
  __typename?: 'ExternalReferenceEdge';
  cursor: Scalars['String'];
  node: ExternalReference;
};

export type ExternalReferenceEditMutations = {
  __typename?: 'ExternalReferenceEditMutations';
  askEnrichment?: Maybe<Work>;
  contextClean?: Maybe<ExternalReference>;
  contextPatch?: Maybe<ExternalReference>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ExternalReference>;
  importPush?: Maybe<File>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ExternalReference>;
};


export type ExternalReferenceEditMutationsAskEnrichmentArgs = {
  connectorId: Scalars['ID'];
};


export type ExternalReferenceEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ExternalReferenceEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type ExternalReferenceEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
  noTriggerImport?: InputMaybe<Scalars['Boolean']>;
};


export type ExternalReferenceEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ExternalReferenceEditMutationsRelationDeleteArgs = {
  fromId: Scalars['StixRef'];
  relationship_type: Scalars['String'];
};

export enum ExternalReferencesFilter {
  Creator = 'creator',
  ExternalId = 'external_id',
  FileId = 'fileId',
  SourceName = 'source_name',
  Url = 'url',
  UsedBy = 'usedBy'
}

export type ExternalReferencesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ExternalReferencesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ExternalReferencesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Creator = 'creator',
  ExternalId = 'external_id',
  Hash = 'hash',
  Modified = 'modified',
  SourceName = 'source_name',
  UpdatedAt = 'updated_at',
  Url = 'url'
}

export type Feed = {
  __typename?: 'Feed';
  feed_attributes: Array<FeedAttribute>;
  feed_types: Array<Scalars['String']>;
  filters?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  include_header: Scalars['Boolean'];
  name: Scalars['String'];
  rolling_time: Scalars['Int'];
  separator: Scalars['String'];
  standard_id: Scalars['ID'];
};

export type FeedAddInput = {
  feed_attributes: Array<FeedAttributeMappingInput>;
  feed_types: Array<Scalars['String']>;
  filters?: InputMaybe<Scalars['String']>;
  include_header: Scalars['Boolean'];
  name: Scalars['String'];
  rolling_time: Scalars['Int'];
  separator: Scalars['String'];
};

export type FeedAttribute = {
  __typename?: 'FeedAttribute';
  attribute: Scalars['String'];
  mappings: Array<FeedMapping>;
};

export type FeedAttributeMappingInput = {
  attribute: Scalars['String'];
  mappings: Array<FeedMappingInput>;
};

export type FeedConnection = {
  __typename?: 'FeedConnection';
  edges?: Maybe<Array<Maybe<FeedEdge>>>;
  pageInfo: PageInfo;
};

export type FeedEdge = {
  __typename?: 'FeedEdge';
  cursor: Scalars['String'];
  node: Feed;
};

export type FeedMapping = {
  __typename?: 'FeedMapping';
  attribute: Scalars['String'];
  type: Scalars['String'];
};

export type FeedMappingInput = {
  attribute: Scalars['String'];
  type: Scalars['String'];
};

export enum FeedOrdering {
  Name = 'name'
}

export type File = {
  __typename?: 'File';
  id: Scalars['ID'];
  lastModified?: Maybe<Scalars['DateTime']>;
  lastModifiedSinceMin?: Maybe<Scalars['Int']>;
  metaData?: Maybe<FileMetadata>;
  name: Scalars['String'];
  size?: Maybe<Scalars['Int']>;
  uploadStatus: State;
  works?: Maybe<Array<Maybe<Work>>>;
};

export type FileConnection = {
  __typename?: 'FileConnection';
  edges?: Maybe<Array<Maybe<FileEdge>>>;
  pageInfo: PageInfo;
};

export type FileEdge = {
  __typename?: 'FileEdge';
  cursor: Scalars['String'];
  node: File;
};

export type FileMetadata = {
  __typename?: 'FileMetadata';
  creator?: Maybe<Creator>;
  creator_id?: Maybe<Scalars['String']>;
  encoding?: Maybe<Scalars['String']>;
  entity?: Maybe<StixCoreObject>;
  entity_id?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<WorkMessage>>>;
  external_reference_id?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Maybe<Scalars['String']>>>;
  labels_text?: Maybe<Scalars['String']>;
  list_filters?: Maybe<Scalars['String']>;
  messages?: Maybe<Array<Maybe<WorkMessage>>>;
  mimetype?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

export enum FilterMode {
  And = 'and',
  Or = 'or'
}

export type GetMetrics = {
  __typename?: 'GetMetrics';
  total?: Maybe<Scalars['String']>;
};

export type Group = BasicObject & InternalObject & {
  __typename?: 'Group';
  allowed_marking?: Maybe<Array<Maybe<MarkingDefinition>>>;
  auto_new_marking?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  default_assignation?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  members?: Maybe<UserConnection>;
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at?: Maybe<Scalars['DateTime']>;
};

export type GroupAddInput = {
  auto_new_marking?: InputMaybe<Scalars['Boolean']>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  default_assignation?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type GroupConnection = {
  __typename?: 'GroupConnection';
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  pageInfo: PageInfo;
};

export type GroupEdge = {
  __typename?: 'GroupEdge';
  cursor: Scalars['String'];
  node: Group;
};

export type GroupEditMutations = {
  __typename?: 'GroupEditMutations';
  contextClean?: Maybe<Group>;
  contextPatch?: Maybe<Group>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Group>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<Group>;
};


export type GroupEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type GroupEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type GroupEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type GroupEditMutationsRelationDeleteArgs = {
  fromId?: InputMaybe<Scalars['StixRef']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['StixRef']>;
};

export type Grouping = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Grouping';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  context: Scalars['String'];
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type GroupingCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type GroupingExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type GroupingObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type GroupingReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupingStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type GroupingStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type GroupingStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type GroupingAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  context: Scalars['String'];
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type GroupingConnection = {
  __typename?: 'GroupingConnection';
  edges?: Maybe<Array<Maybe<GroupingEdge>>>;
  pageInfo: PageInfo;
};

export type GroupingEdge = {
  __typename?: 'GroupingEdge';
  cursor: Scalars['String'];
  node: Grouping;
};

export enum GroupingsFilter {
  Confidence = 'confidence',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Name = 'name',
  ObjectContains = 'objectContains',
  ObjectLabel = 'objectLabel',
  Revoked = 'revoked',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type GroupingsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<GroupingsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum GroupingsOrdering {
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export enum GroupsOrdering {
  AutoNewMarking = 'auto_new_marking',
  CreatedAt = 'created_at',
  DefaultAssignation = 'default_assignation',
  Name = 'name',
  UpdatedAt = 'updated_at'
}

export type Hash = {
  __typename?: 'Hash';
  algorithm: Scalars['String'];
  hash?: Maybe<Scalars['String']>;
};

export type HashInput = {
  algorithm: Scalars['String'];
  hash: Scalars['String'];
};

export type HashedObservable = {
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type HashedObservableCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type HashedObservableExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservablePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HashedObservableStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HashedObservableStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HashedObservableStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type Hostname = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Hostname';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type HostnameCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type HostnameExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnamePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HostnameStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HostnameStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HostnameStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type HostnameAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type IPv4Addr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'IPv4Addr';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  countries?: Maybe<CountryConnection>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IPv4AddrCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IPv4AddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv4AddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv4AddrStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv4AddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IPv4AddrAddInput = {
  belongsTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  resolvesTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  value?: InputMaybe<Scalars['String']>;
};

export type IPv6Addr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'IPv6Addr';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  countries?: Maybe<CountryConnection>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IPv6AddrCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IPv6AddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv6AddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv6AddrStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv6AddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IPv6AddrAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export enum IdentitiesFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  IdentityClass = 'identity_class',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IdentitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<IdentitiesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IdentitiesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Identity = {
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IdentityCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IdentityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IdentityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IdentityStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IdentityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  type: IdentityType;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type IdentityConnection = {
  __typename?: 'IdentityConnection';
  edges?: Maybe<Array<Maybe<IdentityEdge>>>;
  pageInfo: PageInfo;
};

export type IdentityEdge = {
  __typename?: 'IdentityEdge';
  cursor: Scalars['String'];
  node: Identity;
};

export type IdentityEditMutations = {
  __typename?: 'IdentityEditMutations';
  contextClean?: Maybe<Identity>;
  contextPatch?: Maybe<Identity>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Identity>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Identity>;
};


export type IdentityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IdentityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IdentityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IdentityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum IdentityType {
  Individual = 'Individual',
  Organization = 'Organization',
  Sector = 'Sector',
  System = 'System'
}

export type Incident = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Incident';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  incident_type?: Maybe<Scalars['String']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objective?: Maybe<Scalars['String']>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  severity?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IncidentCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IncidentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IncidentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IncidentStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IncidentAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  incident_type?: InputMaybe<Scalars['String']>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objective?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  severity?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type IncidentConnection = {
  __typename?: 'IncidentConnection';
  edges?: Maybe<Array<Maybe<IncidentEdge>>>;
  pageInfo: PageInfo;
};

export type IncidentEdge = {
  __typename?: 'IncidentEdge';
  cursor: Scalars['String'];
  node: Incident;
};

export type IncidentEditMutations = {
  __typename?: 'IncidentEditMutations';
  contextClean?: Maybe<Incident>;
  contextPatch?: Maybe<Incident>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Incident>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Incident>;
};


export type IncidentEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IncidentEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IncidentEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IncidentEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum IncidentsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  IncidentType = 'incident_type',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Severity = 'severity',
  Source = 'source',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IncidentsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<IncidentsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IncidentsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  IncidentType = 'incident_type',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Severity = 'severity',
  Source = 'source',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IndexingMetrics = {
  __typename?: 'IndexingMetrics';
  delete_total?: Maybe<Scalars['String']>;
  index_total?: Maybe<Scalars['String']>;
};

export type Indicator = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Indicator';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicator_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observables?: Maybe<StixCyberObservableConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pattern?: Maybe<Scalars['String']>;
  pattern_type?: Maybe<Scalars['String']>;
  pattern_version?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  valid_from?: Maybe<Scalars['DateTime']>;
  valid_until?: Maybe<Scalars['DateTime']>;
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_platforms?: Maybe<Array<Scalars['String']>>;
  x_opencti_detection?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_main_observable_type?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IndicatorCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IndicatorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorObservablesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndicatorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndicatorStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndicatorAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  createObservables?: InputMaybe<Scalars['Boolean']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<Scalars['String']>>;
  indicator_types?: InputMaybe<Array<Scalars['String']>>;
  killChainPhases?: InputMaybe<Array<Scalars['String']>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<Scalars['String']>>;
  objectMarking?: InputMaybe<Array<Scalars['String']>>;
  objectOrganization?: InputMaybe<Array<Scalars['String']>>;
  pattern: Scalars['String'];
  pattern_type: Scalars['String'];
  pattern_version?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  valid_from?: InputMaybe<Scalars['DateTime']>;
  valid_until?: InputMaybe<Scalars['DateTime']>;
  x_mitre_platforms?: InputMaybe<Array<Scalars['String']>>;
  x_opencti_detection?: InputMaybe<Scalars['Boolean']>;
  x_opencti_main_observable_type?: InputMaybe<Scalars['String']>;
  x_opencti_score?: InputMaybe<Scalars['Int']>;
  x_opencti_stix_ids?: InputMaybe<Array<Scalars['StixId']>>;
};

export type IndicatorConnection = {
  __typename?: 'IndicatorConnection';
  edges?: Maybe<Array<Maybe<IndicatorEdge>>>;
  pageInfo: PageInfo;
};

export type IndicatorEdge = {
  __typename?: 'IndicatorEdge';
  cursor: Scalars['String'];
  node: Indicator;
};

export type IndicatorEditMutations = {
  __typename?: 'IndicatorEditMutations';
  contextClean?: Maybe<Indicator>;
  contextPatch?: Maybe<Indicator>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Indicator>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Indicator>;
};


export type IndicatorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IndicatorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndicatorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IndicatorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum IndicatorsFilter {
  AssigneeTo = 'assigneeTo',
  BasedOn = 'basedOn',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Indicates = 'indicates',
  IndicatorTypes = 'indicator_types',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Pattern = 'pattern',
  PatternType = 'pattern_type',
  PatternVersion = 'pattern_version',
  Revoked = 'revoked',
  SightedBy = 'sightedBy',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiDetection = 'x_opencti_detection',
  XOpenctiMainObservableType = 'x_opencti_main_observable_type',
  XOpenctiScore = 'x_opencti_score',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IndicatorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<IndicatorsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IndicatorsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Creator = 'creator',
  IndicatorTypes = 'indicator_types',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Pattern = 'pattern',
  PatternType = 'pattern_type',
  PatternVersion = 'pattern_version',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiDetection = 'x_opencti_detection',
  XOpenctiScore = 'x_opencti_score',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Individual = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Individual';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  isUser?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  organizations?: Maybe<OrganizationConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_firstname?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_lastname?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IndividualCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IndividualExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndividualStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndividualStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndividualAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_firstname?: InputMaybe<Scalars['String']>;
  x_opencti_lastname?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type IndividualConnection = {
  __typename?: 'IndividualConnection';
  edges?: Maybe<Array<Maybe<IndividualEdge>>>;
  pageInfo: PageInfo;
};

export type IndividualEdge = {
  __typename?: 'IndividualEdge';
  cursor: Scalars['String'];
  node: Individual;
};

export type IndividualEditMutations = {
  __typename?: 'IndividualEditMutations';
  contextClean?: Maybe<Individual>;
  contextPatch?: Maybe<Individual>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Individual>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Individual>;
};


export type IndividualEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IndividualEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndividualEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IndividualEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum IndividualsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  ContactInformation = 'contact_information',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Description = 'description',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiFirstname = 'x_opencti_firstname',
  XOpenctiLastname = 'x_opencti_lastname',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IndividualsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<IndividualsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IndividualsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Firstname = 'firstname',
  Lastname = 'lastname',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Inference = {
  __typename?: 'Inference';
  attributes?: Maybe<Array<Maybe<InferenceAttribute>>>;
  explanation: Array<Maybe<StixObjectOrStixRelationship>>;
  rule: Rule;
};

export type InferenceAttribute = {
  __typename?: 'InferenceAttribute';
  field: Scalars['String'];
  value: Scalars['String'];
};

export type Infrastructure = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Infrastructure';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  infrastructure_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type InfrastructureCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type InfrastructureExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructurePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type InfrastructureStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type InfrastructureStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type InfrastructureAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  infrastructure_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type InfrastructureConnection = {
  __typename?: 'InfrastructureConnection';
  edges?: Maybe<Array<Maybe<InfrastructureEdge>>>;
  pageInfo: PageInfo;
};

export type InfrastructureEdge = {
  __typename?: 'InfrastructureEdge';
  cursor: Scalars['String'];
  node: Infrastructure;
};

export type InfrastructureEditMutations = {
  __typename?: 'InfrastructureEditMutations';
  contextClean?: Maybe<Infrastructure>;
  contextPatch?: Maybe<Infrastructure>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Infrastructure>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Infrastructure>;
};


export type InfrastructureEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type InfrastructureEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type InfrastructureEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type InfrastructureEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum InfrastructuresFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  InfrastructureTypes = 'infrastructure_types',
  LabelledBy = 'labelledBy',
  LastSeen = 'last_seen',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type InfrastructuresFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<InfrastructuresFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum InfrastructuresOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  InfrastructureTypes = 'infrastructure_types',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type InternalObject = {
  entity_type: Scalars['String'];
  id: Scalars['ID'];
};

export type InternalRelationship = BasicRelationship & {
  __typename?: 'InternalRelationship';
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  entity_type: Scalars['String'];
  from?: Maybe<InternalObject>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  to?: Maybe<InternalObject>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
};

export type InternalRelationshipAddInput = {
  fromId?: InputMaybe<Scalars['ID']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['ID']>;
};

export type IntrusionSet = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'IntrusionSet';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  goals?: Maybe<Array<Maybe<Scalars['String']>>>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  locations?: Maybe<LocationConnection>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  primary_motivation?: Maybe<Scalars['String']>;
  reports?: Maybe<ReportConnection>;
  resource_level?: Maybe<Scalars['String']>;
  revoked: Scalars['Boolean'];
  secondary_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type IntrusionSetCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IntrusionSetExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IntrusionSetStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IntrusionSetStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IntrusionSetAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  goals?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  primary_motivation?: InputMaybe<Scalars['String']>;
  resource_level?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  secondary_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type IntrusionSetConnection = {
  __typename?: 'IntrusionSetConnection';
  edges?: Maybe<Array<Maybe<IntrusionSetEdge>>>;
  pageInfo: PageInfo;
};

export type IntrusionSetEdge = {
  __typename?: 'IntrusionSetEdge';
  cursor: Scalars['String'];
  node: IntrusionSet;
};

export type IntrusionSetEditMutations = {
  __typename?: 'IntrusionSetEditMutations';
  contextClean?: Maybe<IntrusionSet>;
  contextPatch?: Maybe<IntrusionSet>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<IntrusionSet>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<IntrusionSet>;
};


export type IntrusionSetEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IntrusionSetEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IntrusionSetEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IntrusionSetEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum IntrusionSetsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type IntrusionSetsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<IntrusionSetsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IntrusionSetsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type KillChainPhase = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'KillChainPhase';
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  kill_chain_name: Scalars['String'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  phase_name: Scalars['String'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_order?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type KillChainPhaseAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  kill_chain_name: Scalars['String'];
  modified?: InputMaybe<Scalars['DateTime']>;
  phase_name: Scalars['String'];
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type KillChainPhaseConnection = {
  __typename?: 'KillChainPhaseConnection';
  edges?: Maybe<Array<Maybe<KillChainPhaseEdge>>>;
  pageInfo: PageInfo;
};

export type KillChainPhaseEdge = {
  __typename?: 'KillChainPhaseEdge';
  cursor: Scalars['String'];
  node: KillChainPhase;
};

export type KillChainPhaseEditMutations = {
  __typename?: 'KillChainPhaseEditMutations';
  contextClean?: Maybe<KillChainPhase>;
  contextPatch?: Maybe<KillChainPhase>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<KillChainPhase>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<KillChainPhase>;
};


export type KillChainPhaseEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type KillChainPhaseEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type KillChainPhaseEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type KillChainPhaseEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum KillChainPhasesFilter {
  KillChainName = 'kill_chain_name',
  PhaseName = 'phase_name'
}

export type KillChainPhasesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<KillChainPhasesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum KillChainPhasesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  KillChainName = 'kill_chain_name',
  Modified = 'modified',
  PhaseName = 'phase_name',
  UpdatedAt = 'updated_at',
  XOpenctiOrder = 'x_opencti_order'
}

export type Label = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'Label';
  color?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type LabelAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  value: Scalars['String'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type LabelConnection = {
  __typename?: 'LabelConnection';
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  pageInfo: PageInfo;
};

export type LabelEdge = {
  __typename?: 'LabelEdge';
  cursor: Scalars['String'];
  node: Label;
};

export type LabelEditMutations = {
  __typename?: 'LabelEditMutations';
  contextClean?: Maybe<Label>;
  contextPatch?: Maybe<Label>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Label>;
};


export type LabelEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type LabelEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum LabelsFilter {
  MarkedBy = 'markedBy',
  Value = 'value'
}

export type LabelsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<LabelsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LabelsOrdering {
  Color = 'color',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  UpdatedAt = 'updated_at',
  Value = 'value'
}

export type Language = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Language';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type LanguageCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type LanguageExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguagePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LanguageStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LanguageStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LanguageStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LanguageAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type LanguageConnection = {
  __typename?: 'LanguageConnection';
  edges?: Maybe<Array<Maybe<LanguageEdge>>>;
  pageInfo: PageInfo;
};

export type LanguageEdge = {
  __typename?: 'LanguageEdge';
  cursor: Scalars['String'];
  node: Language;
};

export enum LanguagesFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type LanguagesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<LanguagesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LanguagesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ListTask = Task & {
  __typename?: 'ListTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<Creator>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_ids?: Maybe<Array<Scalars['ID']>>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type ListTaskAddInput = {
  actions: Array<InputMaybe<TaskActionInput>>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type Location = {
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type LocationCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type LocationExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LocationStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LocationStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LocationAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  type: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type LocationConnection = {
  __typename?: 'LocationConnection';
  edges?: Maybe<Array<Maybe<LocationEdge>>>;
  pageInfo: PageInfo;
};

export type LocationEdge = {
  __typename?: 'LocationEdge';
  cursor: Scalars['String'];
  node: Location;
};

export type LocationEditMutations = {
  __typename?: 'LocationEditMutations';
  contextClean?: Maybe<Location>;
  contextPatch?: Maybe<Location>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Location>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Location>;
};


export type LocationEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type LocationEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LocationEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type LocationEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum LocationsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type LocationsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<LocationsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LocationsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Latitude = 'latitude',
  Longitude = 'longitude',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Log = {
  __typename?: 'Log';
  context_data?: Maybe<ContextData>;
  event_type: Scalars['String'];
  id: Scalars['ID'];
  timestamp: Scalars['DateTime'];
  user?: Maybe<User>;
  user_id: Scalars['String'];
};

export type LogConnection = {
  __typename?: 'LogConnection';
  edges?: Maybe<Array<Maybe<LogEdge>>>;
  pageInfo: PageInfo;
};

export type LogEdge = {
  __typename?: 'LogEdge';
  cursor: Scalars['String'];
  node: Log;
};

export enum LogsFilter {
  ApplicantId = 'applicant_id',
  ConnectionId = 'connection_id',
  EntityId = 'entity_id',
  EventType = 'event_type',
  UserId = 'user_id'
}

export type LogsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<LogsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LogsOrdering {
  Event = 'event',
  Timestamp = 'timestamp'
}

export type LogsWorkerConfig = {
  __typename?: 'LogsWorkerConfig';
  elasticsearch_api_key?: Maybe<Scalars['String']>;
  elasticsearch_index: Scalars['String'];
  elasticsearch_password?: Maybe<Scalars['String']>;
  elasticsearch_proxy?: Maybe<Scalars['String']>;
  elasticsearch_ssl_reject_unauthorized?: Maybe<Scalars['Boolean']>;
  elasticsearch_url: Array<Maybe<Scalars['String']>>;
  elasticsearch_username?: Maybe<Scalars['String']>;
};

export type MacAddr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'MacAddr';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type MacAddrCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MacAddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MacAddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MacAddrStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MacAddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MacAddrAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type Malware = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Malware';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  architecture_execution_envs?: Maybe<Array<Maybe<Scalars['String']>>>;
  capabilities?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  implementation_languages?: Maybe<Array<Maybe<Scalars['String']>>>;
  importFiles?: Maybe<FileConnection>;
  is_family?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  malware_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type MalwareCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MalwareExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwarePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MalwareStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MalwareStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MalwareAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  architecture_execution_envs?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  capabilities?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  implementation_languages?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  is_family?: InputMaybe<Scalars['Boolean']>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  malware_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type MalwareConnection = {
  __typename?: 'MalwareConnection';
  edges?: Maybe<Array<Maybe<MalwareEdge>>>;
  pageInfo: PageInfo;
};

export type MalwareEdge = {
  __typename?: 'MalwareEdge';
  cursor: Scalars['String'];
  node: Malware;
};

export type MalwareEditMutations = {
  __typename?: 'MalwareEditMutations';
  contextClean?: Maybe<Malware>;
  contextPatch?: Maybe<Malware>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Malware>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Malware>;
};


export type MalwareEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type MalwareEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MalwareEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type MalwareEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum MalwaresFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  IsFamily = 'is_family',
  LabelledBy = 'labelledBy',
  LastSeen = 'last_seen',
  MalwareTypes = 'malware_types',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type MalwaresFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<MalwaresFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum MalwaresOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  MalwareTypes = 'malware_types',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type MarkingDefinition = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'MarkingDefinition';
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  definition?: Maybe<Scalars['String']>;
  definition_type?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_color?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type MarkingDefinitionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  definition: Scalars['String'];
  definition_type: Scalars['String'];
  modified?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_color?: InputMaybe<Scalars['String']>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type MarkingDefinitionConnection = {
  __typename?: 'MarkingDefinitionConnection';
  edges: Array<MarkingDefinitionEdge>;
  pageInfo: PageInfo;
};

export type MarkingDefinitionEdge = {
  __typename?: 'MarkingDefinitionEdge';
  cursor: Scalars['String'];
  node: MarkingDefinition;
};

export type MarkingDefinitionEditMutations = {
  __typename?: 'MarkingDefinitionEditMutations';
  contextClean?: Maybe<MarkingDefinition>;
  contextPatch?: Maybe<MarkingDefinition>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<MarkingDefinition>;
};


export type MarkingDefinitionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type MarkingDefinitionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum MarkingDefinitionsFilter {
  Definition = 'definition',
  DefinitionType = 'definition_type',
  MarkedBy = 'markedBy'
}

export type MarkingDefinitionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<MarkingDefinitionsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum MarkingDefinitionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Definition = 'definition',
  DefinitionType = 'definition_type',
  Modified = 'modified',
  UpdatedAt = 'updated_at',
  XOpenctiColor = 'x_opencti_color',
  XOpenctiOrder = 'x_opencti_order'
}

export type MeOrganization = {
  __typename?: 'MeOrganization';
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type MeOrganizationConnection = {
  __typename?: 'MeOrganizationConnection';
  edges: Array<MeOrganizationEdge>;
  pageInfo: PageInfo;
};

export type MeOrganizationEdge = {
  __typename?: 'MeOrganizationEdge';
  cursor: Scalars['String'];
  node: MeOrganization;
};

export type MeUser = BasicObject & InternalObject & {
  __typename?: 'MeUser';
  allowed_marking?: Maybe<Array<MarkingDefinition>>;
  api_token: Scalars['String'];
  capabilities: Array<Capability>;
  description?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  external?: Maybe<Scalars['Boolean']>;
  firstname?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  individual_id?: Maybe<Scalars['String']>;
  language?: Maybe<Scalars['String']>;
  lastname?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  objectOrganization?: Maybe<MeOrganizationConnection>;
  otp_activated?: Maybe<Scalars['Boolean']>;
  otp_mandatory?: Maybe<Scalars['Boolean']>;
  otp_qr?: Maybe<Scalars['String']>;
  parent_types: Array<Scalars['String']>;
  standard_id: Scalars['String'];
  theme?: Maybe<Scalars['String']>;
  userSubscriptions?: Maybe<UserSubscriptionConnection>;
  user_email: Scalars['String'];
};


export type MeUserUserSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type MediaContent = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'MediaContent';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  media_category?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  publication_date?: Maybe<Scalars['DateTime']>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  title?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  url?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type MediaContentCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MediaContentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MediaContentStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MediaContentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MediaContentStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MediaContentStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MediaContentAddInput = {
  content?: InputMaybe<Scalars['String']>;
  media_category?: InputMaybe<Scalars['String']>;
  publication_date?: InputMaybe<Scalars['DateTime']>;
  title?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};

export type MessagesStats = {
  __typename?: 'MessagesStats';
  ack?: Maybe<Scalars['String']>;
  ack_details?: Maybe<AckDetails>;
};

export type Module = {
  __typename?: 'Module';
  enable: Scalars['Boolean'];
  id: Scalars['ID'];
  running: Scalars['Boolean'];
};

export type MultiDistribution = {
  __typename?: 'MultiDistribution';
  data?: Maybe<Array<Maybe<Distribution>>>;
};

export type MultiTimeSeries = {
  __typename?: 'MultiTimeSeries';
  data?: Maybe<Array<Maybe<TimeSeries>>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  administrativeAreaAdd?: Maybe<AdministrativeArea>;
  administrativeAreaContextClean?: Maybe<AdministrativeArea>;
  administrativeAreaContextPatch?: Maybe<AdministrativeArea>;
  administrativeAreaDelete?: Maybe<Scalars['ID']>;
  administrativeAreaFieldPatch?: Maybe<AdministrativeArea>;
  administrativeAreaRelationAdd?: Maybe<StixMetaRelationship>;
  administrativeAreaRelationDelete?: Maybe<AdministrativeArea>;
  artifactImport?: Maybe<Artifact>;
  askJobImport?: Maybe<File>;
  attackPatternAdd?: Maybe<AttackPattern>;
  attackPatternEdit?: Maybe<AttackPatternEditMutations>;
  bookmarkAdd?: Maybe<StixDomainObject>;
  bookmarkDelete?: Maybe<Scalars['ID']>;
  campaignAdd?: Maybe<Campaign>;
  campaignEdit?: Maybe<CampaignEditMutations>;
  caseAdd?: Maybe<Case>;
  caseContextClean?: Maybe<Case>;
  caseContextPatch?: Maybe<Case>;
  caseDelete?: Maybe<Scalars['ID']>;
  caseFieldPatch?: Maybe<Case>;
  caseRelationAdd?: Maybe<StixMetaRelationship>;
  caseRelationDelete?: Maybe<Case>;
  channelAdd?: Maybe<Channel>;
  channelContextClean?: Maybe<Channel>;
  channelContextPatch?: Maybe<Channel>;
  channelDelete?: Maybe<Scalars['ID']>;
  channelFieldPatch?: Maybe<Channel>;
  channelRelationAdd?: Maybe<StixMetaRelationship>;
  channelRelationDelete?: Maybe<Channel>;
  cityAdd?: Maybe<City>;
  cityEdit?: Maybe<CityEditMutations>;
  containerEdit?: Maybe<ContainerEditMutations>;
  countryAdd?: Maybe<Country>;
  countryEdit?: Maybe<CountryEditMutations>;
  courseOfActionAdd?: Maybe<CourseOfAction>;
  courseOfActionEdit?: Maybe<CourseOfActionEditMutations>;
  dataComponentAdd?: Maybe<DataComponent>;
  dataComponentContextClean?: Maybe<DataComponent>;
  dataComponentContextPatch?: Maybe<DataComponent>;
  dataComponentDelete?: Maybe<Scalars['ID']>;
  dataComponentFieldPatch?: Maybe<DataComponent>;
  dataComponentRelationAdd?: Maybe<StixMetaRelationship>;
  dataComponentRelationDelete?: Maybe<DataComponent>;
  dataSourceAdd?: Maybe<DataSource>;
  dataSourceContextClean?: Maybe<DataSource>;
  dataSourceContextPatch?: Maybe<DataSource>;
  dataSourceDataComponentAdd?: Maybe<DataSource>;
  dataSourceDataComponentDelete?: Maybe<DataSource>;
  dataSourceDelete?: Maybe<Scalars['ID']>;
  dataSourceFieldPatch?: Maybe<DataSource>;
  dataSourceRelationAdd?: Maybe<StixMetaRelationship>;
  dataSourceRelationDelete?: Maybe<DataSource>;
  deleteConnector: Scalars['ID'];
  deleteImport?: Maybe<Scalars['Boolean']>;
  deleteTask: Scalars['ID'];
  entitySettingsFieldPatch?: Maybe<Array<Maybe<EntitySetting>>>;
  eventAdd?: Maybe<Event>;
  eventContextClean?: Maybe<Event>;
  eventContextPatch?: Maybe<Event>;
  eventDelete?: Maybe<Scalars['ID']>;
  eventFieldPatch?: Maybe<Event>;
  eventRelationAdd?: Maybe<StixMetaRelationship>;
  eventRelationDelete?: Maybe<Event>;
  externalReferenceAdd?: Maybe<ExternalReference>;
  externalReferenceEdit?: Maybe<ExternalReferenceEditMutations>;
  feedAdd?: Maybe<Feed>;
  feedDelete: Scalars['ID'];
  feedEdit: Feed;
  groupAdd?: Maybe<Group>;
  groupEdit?: Maybe<GroupEditMutations>;
  groupingAdd?: Maybe<Grouping>;
  groupingContextClean?: Maybe<Grouping>;
  groupingContextPatch?: Maybe<Grouping>;
  groupingDelete?: Maybe<Scalars['ID']>;
  groupingFieldPatch?: Maybe<Grouping>;
  groupingRelationAdd?: Maybe<StixMetaRelationship>;
  groupingRelationDelete?: Maybe<Grouping>;
  identityAdd?: Maybe<Identity>;
  identityEdit?: Maybe<IdentityEditMutations>;
  incidentAdd?: Maybe<Incident>;
  incidentEdit?: Maybe<IncidentEditMutations>;
  indicatorAdd?: Maybe<Indicator>;
  indicatorEdit?: Maybe<IndicatorEditMutations>;
  individualAdd?: Maybe<Individual>;
  individualEdit?: Maybe<IndividualEditMutations>;
  infrastructureAdd?: Maybe<Infrastructure>;
  infrastructureEdit?: Maybe<InfrastructureEditMutations>;
  intrusionSetAdd?: Maybe<IntrusionSet>;
  intrusionSetEdit?: Maybe<IntrusionSetEditMutations>;
  killChainPhaseAdd?: Maybe<KillChainPhase>;
  killChainPhaseEdit?: Maybe<KillChainPhaseEditMutations>;
  labelAdd?: Maybe<Label>;
  labelEdit?: Maybe<LabelEditMutations>;
  languageAdd?: Maybe<Language>;
  languageContextClean?: Maybe<Language>;
  languageContextPatch?: Maybe<Language>;
  languageDelete?: Maybe<Scalars['ID']>;
  languageFieldPatch?: Maybe<Language>;
  languageRelationAdd?: Maybe<StixMetaRelationship>;
  languageRelationDelete?: Maybe<Language>;
  listTaskAdd: Task;
  locationAdd?: Maybe<Location>;
  locationEdit?: Maybe<LocationEditMutations>;
  logout?: Maybe<Scalars['ID']>;
  malwareAdd?: Maybe<Malware>;
  malwareEdit?: Maybe<MalwareEditMutations>;
  markingDefinitionAdd?: Maybe<MarkingDefinition>;
  markingDefinitionEdit?: Maybe<MarkingDefinitionEditMutations>;
  meEdit?: Maybe<MeUser>;
  meTokenRenew?: Maybe<MeUser>;
  narrativeAdd?: Maybe<Narrative>;
  narrativeContextClean?: Maybe<Narrative>;
  narrativeContextPatch?: Maybe<Narrative>;
  narrativeDelete?: Maybe<Scalars['ID']>;
  narrativeFieldPatch?: Maybe<Narrative>;
  narrativeRelationAdd?: Maybe<StixMetaRelationship>;
  narrativeRelationDelete?: Maybe<Narrative>;
  noteAdd?: Maybe<Note>;
  noteEdit?: Maybe<NoteEditMutations>;
  observedDataAdd?: Maybe<ObservedData>;
  observedDataEdit?: Maybe<ObservedDataEditMutations>;
  opinionAdd?: Maybe<Opinion>;
  opinionEdit?: Maybe<OpinionEditMutations>;
  organizationAdd?: Maybe<Organization>;
  organizationEdit?: Maybe<OrganizationEditMutations>;
  otpActivation?: Maybe<MeUser>;
  otpDeactivation?: Maybe<MeUser>;
  otpLogin?: Maybe<Scalars['Boolean']>;
  otpSetActivation?: Maybe<User>;
  otpUserDeactivation?: Maybe<MeUser>;
  pingConnector?: Maybe<Connector>;
  positionAdd?: Maybe<Position>;
  positionEdit?: Maybe<PositionEditMutations>;
  queryTaskAdd: Task;
  regionAdd?: Maybe<Region>;
  regionEdit?: Maybe<RegionEditMutations>;
  registerConnector?: Maybe<Connector>;
  reportAdd?: Maybe<Report>;
  reportEdit?: Maybe<ReportEditMutations>;
  resetStateConnector?: Maybe<Connector>;
  retentionRuleAdd: RetentionRule;
  retentionRuleCheck: Scalars['Int'];
  retentionRuleEdit?: Maybe<RetentionRuleEditMutations>;
  roleAdd?: Maybe<Role>;
  roleEdit?: Maybe<RoleEditMutations>;
  ruleManagerClean: RuleManager;
  ruleSetActivation: Rule;
  runtimeAttributeEdit: Scalars['ID'];
  sectorAdd?: Maybe<Sector>;
  sectorEdit?: Maybe<SectorEditMutations>;
  sessionKill?: Maybe<Scalars['ID']>;
  settingsEdit?: Maybe<SettingsEditMutations>;
  statusTemplateAdd: StatusTemplate;
  statusTemplateContextClean: StatusTemplate;
  statusTemplateContextPatch: StatusTemplate;
  statusTemplateDelete: Scalars['ID'];
  statusTemplateFieldPatch: StatusTemplate;
  stixCoreObjectEdit?: Maybe<StixCoreObjectEditMutations>;
  stixCoreObjectsExportAsk?: Maybe<FileConnection>;
  stixCoreObjectsExportPush?: Maybe<Scalars['Boolean']>;
  stixCoreRelationshipAdd?: Maybe<StixCoreRelationship>;
  stixCoreRelationshipDelete: Scalars['Boolean'];
  stixCoreRelationshipEdit?: Maybe<StixCoreRelationshipEditMutations>;
  stixCoreRelationshipsExportAsk?: Maybe<FileConnection>;
  stixCoreRelationshipsExportPush?: Maybe<Scalars['Boolean']>;
  stixCyberObservableAdd?: Maybe<StixCyberObservable>;
  stixCyberObservableEdit?: Maybe<StixCyberObservableEditMutations>;
  stixCyberObservableRelationshipAdd?: Maybe<StixCyberObservableRelationship>;
  stixCyberObservableRelationshipEdit?: Maybe<StixCyberObservableRelationshipEditMutations>;
  stixCyberObservablesExportAsk?: Maybe<FileConnection>;
  stixCyberObservablesExportPush?: Maybe<Scalars['Boolean']>;
  stixDomainObjectAdd?: Maybe<StixDomainObject>;
  stixDomainObjectEdit?: Maybe<StixDomainObjectEditMutations>;
  stixDomainObjectsDelete: Array<Maybe<Scalars['ID']>>;
  stixDomainObjectsExportAsk?: Maybe<FileConnection>;
  stixDomainObjectsExportPush?: Maybe<Scalars['Boolean']>;
  stixEdit?: Maybe<StixEditMutations>;
  stixRelationshipEdit?: Maybe<StixRelationshipEditMutations>;
  stixSightingRelationshipAdd?: Maybe<StixSightingRelationship>;
  stixSightingRelationshipEdit?: Maybe<StixSightingRelationshipEditMutations>;
  streamCollectionAdd?: Maybe<StreamCollection>;
  streamCollectionEdit?: Maybe<StreamCollectionEditMutations>;
  subTypeEdit?: Maybe<SubTypeEditMutations>;
  synchronizerAdd?: Maybe<Synchronizer>;
  synchronizerEdit?: Maybe<SynchronizerEditMutations>;
  synchronizerStart?: Maybe<Synchronizer>;
  synchronizerStop?: Maybe<Synchronizer>;
  synchronizerTest?: Maybe<Scalars['String']>;
  systemAdd?: Maybe<System>;
  systemEdit?: Maybe<SystemEditMutations>;
  taxiiCollectionAdd?: Maybe<TaxiiCollection>;
  taxiiCollectionEdit?: Maybe<TaxiiCollectionEditMutations>;
  threatActorAdd?: Maybe<ThreatActor>;
  threatActorEdit?: Maybe<ThreatActorEditMutations>;
  token?: Maybe<Scalars['String']>;
  toolAdd?: Maybe<Tool>;
  toolEdit?: Maybe<ToolEditMutations>;
  uploadImport?: Maybe<File>;
  uploadPending?: Maybe<File>;
  userAdd?: Maybe<User>;
  userEdit?: Maybe<UserEditMutations>;
  userNoteAdd?: Maybe<Note>;
  userSessionsKill?: Maybe<Array<Maybe<Scalars['ID']>>>;
  userSubscriptionAdd?: Maybe<UserSubscription>;
  userSubscriptionEdit?: Maybe<UserSubscriptionEditMutations>;
  vocabularyAdd?: Maybe<Vocabulary>;
  vocabularyDelete?: Maybe<Scalars['ID']>;
  vocabularyFieldPatch?: Maybe<Vocabulary>;
  vulnerabilityAdd?: Maybe<Vulnerability>;
  vulnerabilityEdit?: Maybe<VulnerabilityEditMutations>;
  workAdd: Work;
  workDelete?: Maybe<Scalars['Boolean']>;
  workEdit?: Maybe<WorkEditMutations>;
  workspaceAdd?: Maybe<Workspace>;
  workspaceEdit?: Maybe<WorkspaceEditMutations>;
};


export type MutationAdministrativeAreaAddArgs = {
  input: AdministrativeAreaAddInput;
};


export type MutationAdministrativeAreaContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationAdministrativeAreaContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationAdministrativeAreaDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAdministrativeAreaFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationAdministrativeAreaRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationAdministrativeAreaRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationArtifactImportArgs = {
  createdBy?: InputMaybe<Scalars['String']>;
  file: Scalars['Upload'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_description?: InputMaybe<Scalars['String']>;
};


export type MutationAskJobImportArgs = {
  bypassEntityId?: InputMaybe<Scalars['String']>;
  bypassValidation?: InputMaybe<Scalars['Boolean']>;
  connectorId?: InputMaybe<Scalars['String']>;
  fileName: Scalars['ID'];
};


export type MutationAttackPatternAddArgs = {
  input?: InputMaybe<AttackPatternAddInput>;
};


export type MutationAttackPatternEditArgs = {
  id: Scalars['ID'];
};


export type MutationBookmarkAddArgs = {
  id: Scalars['ID'];
  type: Scalars['String'];
};


export type MutationBookmarkDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCampaignAddArgs = {
  input?: InputMaybe<CampaignAddInput>;
};


export type MutationCampaignEditArgs = {
  id: Scalars['ID'];
};


export type MutationCaseAddArgs = {
  input: CaseAddInput;
};


export type MutationCaseContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationCaseContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationCaseDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCaseFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationCaseRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationCaseRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationChannelAddArgs = {
  input: ChannelAddInput;
};


export type MutationChannelContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationChannelContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationChannelDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationChannelFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationChannelRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationChannelRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationCityAddArgs = {
  input?: InputMaybe<CityAddInput>;
};


export type MutationCityEditArgs = {
  id: Scalars['ID'];
};


export type MutationContainerEditArgs = {
  id: Scalars['ID'];
};


export type MutationCountryAddArgs = {
  input?: InputMaybe<CountryAddInput>;
};


export type MutationCountryEditArgs = {
  id: Scalars['ID'];
};


export type MutationCourseOfActionAddArgs = {
  input?: InputMaybe<CourseOfActionAddInput>;
};


export type MutationCourseOfActionEditArgs = {
  id: Scalars['ID'];
};


export type MutationDataComponentAddArgs = {
  input: DataComponentAddInput;
};


export type MutationDataComponentContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationDataComponentContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationDataComponentDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationDataComponentFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationDataComponentRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationDataComponentRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationDataSourceAddArgs = {
  input: DataSourceAddInput;
};


export type MutationDataSourceContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationDataSourceContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationDataSourceDataComponentAddArgs = {
  dataComponentId: Scalars['ID'];
  id: Scalars['ID'];
};


export type MutationDataSourceDataComponentDeleteArgs = {
  dataComponentId: Scalars['ID'];
  id: Scalars['ID'];
};


export type MutationDataSourceDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationDataSourceFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationDataSourceRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationDataSourceRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationDeleteConnectorArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteImportArgs = {
  fileName?: InputMaybe<Scalars['String']>;
};


export type MutationDeleteTaskArgs = {
  id: Scalars['ID'];
};


export type MutationEntitySettingsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
  input: Array<EditInput>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationEventAddArgs = {
  input: EventAddInput;
};


export type MutationEventContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationEventContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationEventDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationEventFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationEventRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationEventRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationExternalReferenceAddArgs = {
  input?: InputMaybe<ExternalReferenceAddInput>;
};


export type MutationExternalReferenceEditArgs = {
  id: Scalars['ID'];
};


export type MutationFeedAddArgs = {
  input: FeedAddInput;
};


export type MutationFeedDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationFeedEditArgs = {
  id: Scalars['ID'];
  input: FeedAddInput;
};


export type MutationGroupAddArgs = {
  input?: InputMaybe<GroupAddInput>;
};


export type MutationGroupEditArgs = {
  id: Scalars['ID'];
};


export type MutationGroupingAddArgs = {
  input: GroupingAddInput;
};


export type MutationGroupingContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationGroupingContextPatchArgs = {
  id: Scalars['ID'];
  input?: InputMaybe<EditContext>;
};


export type MutationGroupingDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationGroupingFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationGroupingRelationAddArgs = {
  id: Scalars['ID'];
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type MutationGroupingRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationIdentityAddArgs = {
  input?: InputMaybe<IdentityAddInput>;
};


export type MutationIdentityEditArgs = {
  id: Scalars['ID'];
};


export type MutationIncidentAddArgs = {
  input?: InputMaybe<IncidentAddInput>;
};


export type MutationIncidentEditArgs = {
  id: Scalars['ID'];
};


export type MutationIndicatorAddArgs = {
  input?: InputMaybe<IndicatorAddInput>;
};


export type MutationIndicatorEditArgs = {
  id: Scalars['ID'];
};


export type MutationIndividualAddArgs = {
  input?: InputMaybe<IndividualAddInput>;
};


export type MutationIndividualEditArgs = {
  id: Scalars['ID'];
};


export type MutationInfrastructureAddArgs = {
  input?: InputMaybe<InfrastructureAddInput>;
};


export type MutationInfrastructureEditArgs = {
  id: Scalars['ID'];
};


export type MutationIntrusionSetAddArgs = {
  input?: InputMaybe<IntrusionSetAddInput>;
};


export type MutationIntrusionSetEditArgs = {
  id: Scalars['ID'];
};


export type MutationKillChainPhaseAddArgs = {
  input?: InputMaybe<KillChainPhaseAddInput>;
};


export type MutationKillChainPhaseEditArgs = {
  id: Scalars['ID'];
};


export type MutationLabelAddArgs = {
  input?: InputMaybe<LabelAddInput>;
};


export type MutationLabelEditArgs = {
  id: Scalars['ID'];
};


export type MutationLanguageAddArgs = {
  input: LanguageAddInput;
};


export type MutationLanguageContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationLanguageContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationLanguageDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationLanguageFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationLanguageRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationLanguageRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationListTaskAddArgs = {
  input?: InputMaybe<ListTaskAddInput>;
};


export type MutationLocationAddArgs = {
  input?: InputMaybe<LocationAddInput>;
};


export type MutationLocationEditArgs = {
  id: Scalars['ID'];
};


export type MutationMalwareAddArgs = {
  input?: InputMaybe<MalwareAddInput>;
};


export type MutationMalwareEditArgs = {
  id: Scalars['ID'];
};


export type MutationMarkingDefinitionAddArgs = {
  input?: InputMaybe<MarkingDefinitionAddInput>;
};


export type MutationMarkingDefinitionEditArgs = {
  id: Scalars['ID'];
};


export type MutationMeEditArgs = {
  input: Array<InputMaybe<EditInput>>;
  password?: InputMaybe<Scalars['String']>;
};


export type MutationNarrativeAddArgs = {
  input: NarrativeAddInput;
};


export type MutationNarrativeContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationNarrativeContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationNarrativeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationNarrativeFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationNarrativeRelationAddArgs = {
  id: Scalars['ID'];
  input: StixMetaRelationshipAddInput;
};


export type MutationNarrativeRelationDeleteArgs = {
  id: Scalars['ID'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationNoteAddArgs = {
  input?: InputMaybe<NoteAddInput>;
};


export type MutationNoteEditArgs = {
  id: Scalars['ID'];
};


export type MutationObservedDataAddArgs = {
  input?: InputMaybe<ObservedDataAddInput>;
};


export type MutationObservedDataEditArgs = {
  id: Scalars['ID'];
};


export type MutationOpinionAddArgs = {
  input?: InputMaybe<OpinionAddInput>;
};


export type MutationOpinionEditArgs = {
  id: Scalars['ID'];
};


export type MutationOrganizationAddArgs = {
  input?: InputMaybe<OrganizationAddInput>;
};


export type MutationOrganizationEditArgs = {
  id: Scalars['ID'];
};


export type MutationOtpActivationArgs = {
  input?: InputMaybe<UserOtpActivationInput>;
};


export type MutationOtpLoginArgs = {
  input?: InputMaybe<UserOtpLoginInput>;
};


export type MutationOtpSetActivationArgs = {
  input?: InputMaybe<UserOtpActivationInput>;
};


export type MutationOtpUserDeactivationArgs = {
  id: Scalars['ID'];
};


export type MutationPingConnectorArgs = {
  id: Scalars['ID'];
  state?: InputMaybe<Scalars['String']>;
};


export type MutationPositionAddArgs = {
  input?: InputMaybe<PositionAddInput>;
};


export type MutationPositionEditArgs = {
  id: Scalars['ID'];
};


export type MutationQueryTaskAddArgs = {
  input?: InputMaybe<QueryTaskAddInput>;
};


export type MutationRegionAddArgs = {
  input?: InputMaybe<RegionAddInput>;
};


export type MutationRegionEditArgs = {
  id: Scalars['ID'];
};


export type MutationRegisterConnectorArgs = {
  input?: InputMaybe<RegisterConnectorInput>;
};


export type MutationReportAddArgs = {
  input?: InputMaybe<ReportAddInput>;
};


export type MutationReportEditArgs = {
  id: Scalars['ID'];
};


export type MutationResetStateConnectorArgs = {
  id: Scalars['ID'];
};


export type MutationRetentionRuleAddArgs = {
  input?: InputMaybe<RetentionRuleAddInput>;
};


export type MutationRetentionRuleCheckArgs = {
  input?: InputMaybe<RetentionRuleAddInput>;
};


export type MutationRetentionRuleEditArgs = {
  id: Scalars['ID'];
};


export type MutationRoleAddArgs = {
  input?: InputMaybe<RoleAddInput>;
};


export type MutationRoleEditArgs = {
  id: Scalars['ID'];
};


export type MutationRuleManagerCleanArgs = {
  eventId?: InputMaybe<Scalars['ID']>;
};


export type MutationRuleSetActivationArgs = {
  enable: Scalars['Boolean'];
  id: Scalars['ID'];
};


export type MutationRuntimeAttributeEditArgs = {
  current: Scalars['String'];
  id: Scalars['String'];
  previous: Scalars['String'];
};


export type MutationSectorAddArgs = {
  input?: InputMaybe<SectorAddInput>;
};


export type MutationSectorEditArgs = {
  id: Scalars['ID'];
};


export type MutationSessionKillArgs = {
  id: Scalars['ID'];
};


export type MutationSettingsEditArgs = {
  id: Scalars['ID'];
};


export type MutationStatusTemplateAddArgs = {
  input: StatusTemplateAddInput;
};


export type MutationStatusTemplateContextCleanArgs = {
  id: Scalars['ID'];
};


export type MutationStatusTemplateContextPatchArgs = {
  id: Scalars['ID'];
  input: EditContext;
};


export type MutationStatusTemplateDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationStatusTemplateFieldPatchArgs = {
  id: Scalars['ID'];
  input: Array<EditInput>;
};


export type MutationStixCoreObjectEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCoreObjectsExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  elementId?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixCoreObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  selectedIds?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type: Scalars['String'];
};


export type MutationStixCoreObjectsExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};


export type MutationStixCoreRelationshipAddArgs = {
  input?: InputMaybe<StixCoreRelationshipAddInput>;
  reversedReturn?: InputMaybe<Scalars['Boolean']>;
};


export type MutationStixCoreRelationshipDeleteArgs = {
  fromId: Scalars['StixRef'];
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type MutationStixCoreRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCoreRelationshipsExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  selectedIds?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type: Scalars['String'];
};


export type MutationStixCoreRelationshipsExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};


export type MutationStixCyberObservableAddArgs = {
  Artifact?: InputMaybe<ArtifactAddInput>;
  AutonomousSystem?: InputMaybe<AutonomousSystemAddInput>;
  BankAccount?: InputMaybe<BankAccountAddInput>;
  CryptocurrencyWallet?: InputMaybe<CryptocurrencyWalletAddInput>;
  CryptographicKey?: InputMaybe<CryptographicKeyAddInput>;
  Directory?: InputMaybe<DirectoryAddInput>;
  DomainName?: InputMaybe<DomainNameAddInput>;
  EmailAddr?: InputMaybe<EmailAddrAddInput>;
  EmailMessage?: InputMaybe<EmailMessageAddInput>;
  EmailMimePartType?: InputMaybe<EmailMimePartTypeAddInput>;
  Hostname?: InputMaybe<HostnameAddInput>;
  IPv4Addr?: InputMaybe<IPv4AddrAddInput>;
  IPv6Addr?: InputMaybe<IPv6AddrAddInput>;
  MacAddr?: InputMaybe<MacAddrAddInput>;
  MediaContent?: InputMaybe<MediaContentAddInput>;
  Mutex?: InputMaybe<MutexAddInput>;
  NetworkTraffic?: InputMaybe<NetworkTrafficAddInput>;
  PaymentCard?: InputMaybe<PaymentCardAddInput>;
  PhoneNumber?: InputMaybe<PhoneNumberAddInput>;
  Process?: InputMaybe<ProcessAddInput>;
  Software?: InputMaybe<SoftwareAddInput>;
  StixFile?: InputMaybe<StixFileAddInput>;
  Text?: InputMaybe<TextAddInput>;
  Url?: InputMaybe<UrlAddInput>;
  UserAccount?: InputMaybe<UserAccountAddInput>;
  UserAgent?: InputMaybe<UserAgentAddInput>;
  WindowsRegistryKey?: InputMaybe<WindowsRegistryKeyAddInput>;
  WindowsRegistryValueType?: InputMaybe<WindowsRegistryValueTypeAddInput>;
  X509Certificate?: InputMaybe<X509CertificateAddInput>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  createIndicator?: InputMaybe<Scalars['Boolean']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  type: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_description?: InputMaybe<Scalars['String']>;
  x_opencti_score?: InputMaybe<Scalars['Int']>;
};


export type MutationStixCyberObservableEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCyberObservableRelationshipAddArgs = {
  input?: InputMaybe<StixCyberObservableRelationshipAddInput>;
};


export type MutationStixCyberObservableRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCyberObservablesExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixCyberObservablesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  selectedIds?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationStixCyberObservablesExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
};


export type MutationStixDomainObjectAddArgs = {
  input?: InputMaybe<StixDomainObjectAddInput>;
};


export type MutationStixDomainObjectEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixDomainObjectsDeleteArgs = {
  id: Array<InputMaybe<Scalars['ID']>>;
};


export type MutationStixDomainObjectsExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  elementId?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixDomainObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  selectedIds?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type: Scalars['String'];
};


export type MutationStixDomainObjectsExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};


export type MutationStixEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixSightingRelationshipAddArgs = {
  input?: InputMaybe<StixSightingRelationshipAddInput>;
};


export type MutationStixSightingRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStreamCollectionAddArgs = {
  input?: InputMaybe<StreamCollectionAddInput>;
};


export type MutationStreamCollectionEditArgs = {
  id: Scalars['ID'];
};


export type MutationSubTypeEditArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerAddArgs = {
  input?: InputMaybe<SynchronizerAddInput>;
};


export type MutationSynchronizerEditArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerStartArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerStopArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerTestArgs = {
  input?: InputMaybe<SynchronizerAddInput>;
};


export type MutationSystemAddArgs = {
  input?: InputMaybe<SystemAddInput>;
};


export type MutationSystemEditArgs = {
  id: Scalars['ID'];
};


export type MutationTaxiiCollectionAddArgs = {
  input?: InputMaybe<TaxiiCollectionAddInput>;
};


export type MutationTaxiiCollectionEditArgs = {
  id: Scalars['ID'];
};


export type MutationThreatActorAddArgs = {
  input?: InputMaybe<ThreatActorAddInput>;
};


export type MutationThreatActorEditArgs = {
  id: Scalars['ID'];
};


export type MutationTokenArgs = {
  input?: InputMaybe<UserLoginInput>;
};


export type MutationToolAddArgs = {
  input?: InputMaybe<ToolAddInput>;
};


export type MutationToolEditArgs = {
  id: Scalars['ID'];
};


export type MutationUploadImportArgs = {
  file: Scalars['Upload'];
};


export type MutationUploadPendingArgs = {
  entityId?: InputMaybe<Scalars['String']>;
  errorOnExisting?: InputMaybe<Scalars['Boolean']>;
  file: Scalars['Upload'];
  labels?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationUserAddArgs = {
  input?: InputMaybe<UserAddInput>;
};


export type MutationUserEditArgs = {
  id: Scalars['ID'];
};


export type MutationUserNoteAddArgs = {
  input: NoteUserAddInput;
};


export type MutationUserSessionsKillArgs = {
  id: Scalars['ID'];
};


export type MutationUserSubscriptionAddArgs = {
  input?: InputMaybe<UserSubscriptionAddInput>;
};


export type MutationUserSubscriptionEditArgs = {
  id: Scalars['ID'];
};


export type MutationVocabularyAddArgs = {
  input: VocabularyAddInput;
};


export type MutationVocabularyDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationVocabularyFieldPatchArgs = {
  id: Scalars['ID'];
  input: Array<EditInput>;
};


export type MutationVulnerabilityAddArgs = {
  input?: InputMaybe<VulnerabilityAddInput>;
};


export type MutationVulnerabilityEditArgs = {
  id: Scalars['ID'];
};


export type MutationWorkAddArgs = {
  connectorId: Scalars['String'];
  friendlyName?: InputMaybe<Scalars['String']>;
};


export type MutationWorkDeleteArgs = {
  connectorId: Scalars['String'];
};


export type MutationWorkEditArgs = {
  id: Scalars['ID'];
};


export type MutationWorkspaceAddArgs = {
  input?: InputMaybe<WorkspaceAddInput>;
};


export type MutationWorkspaceEditArgs = {
  id: Scalars['ID'];
};

export type Mutex = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Mutex';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type MutexCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MutexExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutexStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutexStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutexStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MutexAddInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type Narrative = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Narrative';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  isSubNarrative?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  narrative_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentNarratives?: Maybe<NarrativeConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  subNarratives?: Maybe<NarrativeConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type NarrativeCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type NarrativeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NarrativeStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NarrativeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NarrativeStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NarrativeAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  narrative_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type NarrativeConnection = {
  __typename?: 'NarrativeConnection';
  edges?: Maybe<Array<Maybe<NarrativeEdge>>>;
  pageInfo: PageInfo;
};

export type NarrativeEdge = {
  __typename?: 'NarrativeEdge';
  cursor: Scalars['String'];
  node: Narrative;
};

export enum NarrativesFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  NarrativeTypes = 'narrative_types',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type NarrativesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<NarrativesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum NarrativesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  NarrativeTypes = 'narrative_types',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type NetworkTraffic = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'NetworkTraffic';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  dst_byte_count?: Maybe<Scalars['Int']>;
  dst_packets?: Maybe<Scalars['Int']>;
  dst_port?: Maybe<Scalars['Int']>;
  editContext?: Maybe<Array<EditUserContext>>;
  end?: Maybe<Scalars['DateTime']>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  protocols?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  src_byte_count?: Maybe<Scalars['Int']>;
  src_packets?: Maybe<Scalars['Int']>;
  src_port?: Maybe<Scalars['Int']>;
  standard_id: Scalars['String'];
  start?: Maybe<Scalars['DateTime']>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type NetworkTrafficCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type NetworkTrafficExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NetworkTrafficStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NetworkTrafficStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NetworkTrafficStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NetworkTrafficAddInput = {
  dst_byte_count?: InputMaybe<Scalars['Int']>;
  dst_packets?: InputMaybe<Scalars['Int']>;
  dst_port?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['DateTime']>;
  is_active?: InputMaybe<Scalars['Boolean']>;
  protocols?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  src_byte_count?: InputMaybe<Scalars['Int']>;
  src_packets?: InputMaybe<Scalars['Int']>;
  src_port?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['DateTime']>;
};

export type Note = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Note';
  attribute_abstract?: Maybe<Scalars['String']>;
  authors?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content: Scalars['String'];
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  likelihood?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['DateTime']>;
  note_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type NoteCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type NoteExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NotePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NoteAddInput = {
  attribute_abstract?: InputMaybe<Scalars['String']>;
  authors?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  content: Scalars['String'];
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  likelihood?: InputMaybe<Scalars['Int']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  note_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type NoteConnection = {
  __typename?: 'NoteConnection';
  edges: Array<NoteEdge>;
  pageInfo: PageInfo;
};

export type NoteEdge = {
  __typename?: 'NoteEdge';
  cursor: Scalars['String'];
  node: Note;
};

export type NoteEditMutations = {
  __typename?: 'NoteEditMutations';
  contextClean?: Maybe<Note>;
  contextPatch?: Maybe<Note>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Note>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Note>;
};


export type NoteEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type NoteEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type NoteEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type NoteUserAddInput = {
  attribute_abstract?: InputMaybe<Scalars['String']>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  content: Scalars['String'];
  created?: InputMaybe<Scalars['DateTime']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  likelihood?: InputMaybe<Scalars['Int']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  note_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum NotesFilter {
  AssigneeTo = 'assigneeTo',
  AttributeAbstract = 'attribute_abstract',
  Authors = 'authors',
  Content = 'content',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  LabelledBy = 'labelledBy',
  Likelihood = 'likelihood',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  NoteTypes = 'note_types',
  ObjectContains = 'objectContains',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type NotesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<NotesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum NotesOrdering {
  AttributeAbstract = 'attribute_abstract',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Modified = 'modified',
  NoteTypes = 'note_types',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Number = {
  __typename?: 'Number';
  count: Scalars['Int'];
  total: Scalars['Int'];
};

export type ObjectTotals = {
  __typename?: 'ObjectTotals';
  channels?: Maybe<Scalars['String']>;
  consumers?: Maybe<Scalars['String']>;
  queues?: Maybe<Scalars['String']>;
};

export type ObservedData = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'ObservedData';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_observed: Scalars['DateTime'];
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_observed: Scalars['DateTime'];
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  number_observed: Scalars['Int'];
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ObservedDataCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ObservedDataExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ObservedDataAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_observed: Scalars['DateTime'];
  lang?: InputMaybe<Scalars['String']>;
  last_observed: Scalars['DateTime'];
  modified?: InputMaybe<Scalars['DateTime']>;
  number_observed?: InputMaybe<Scalars['Int']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects: Array<InputMaybe<Scalars['String']>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ObservedDataConnection = {
  __typename?: 'ObservedDataConnection';
  edges?: Maybe<Array<Maybe<ObservedDataEdge>>>;
  pageInfo: PageInfo;
};

export type ObservedDataEdge = {
  __typename?: 'ObservedDataEdge';
  cursor: Scalars['String'];
  node: ObservedData;
};

export type ObservedDataEditMutations = {
  __typename?: 'ObservedDataEditMutations';
  contextClean?: Maybe<ObservedData>;
  contextPatch?: Maybe<ObservedData>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ObservedData>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ObservedData>;
};


export type ObservedDataEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ObservedDataEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ObservedDataEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum ObservedDatasFilter {
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstObserved = 'first_observed',
  LabelledBy = 'labelledBy',
  LastObserved = 'last_observed',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  NumberObserved = 'number_observed',
  ObjectContains = 'objectContains',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ObservedDatasFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ObservedDatasFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ObservedDatasOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstObserved = 'first_observed',
  LastObserved = 'last_observed',
  Modified = 'modified',
  NumberObserved = 'number_observed',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Opinion = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Opinion';
  authors?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  explanation?: Maybe<Scalars['String']>;
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinion: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type OpinionCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type OpinionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OpinionAddInput = {
  authors?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  explanation?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  opinion: Scalars['String'];
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type OpinionConnection = {
  __typename?: 'OpinionConnection';
  edges?: Maybe<Array<Maybe<OpinionEdge>>>;
  pageInfo: PageInfo;
};

export type OpinionEdge = {
  __typename?: 'OpinionEdge';
  cursor: Scalars['String'];
  node: Opinion;
};

export type OpinionEditMutations = {
  __typename?: 'OpinionEditMutations';
  contextClean?: Maybe<Opinion>;
  contextPatch?: Maybe<Opinion>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Opinion>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Opinion>;
};


export type OpinionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type OpinionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type OpinionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum OpinionsFilter {
  AssigneeTo = 'assigneeTo',
  Authors = 'authors',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Explanation = 'explanation',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ObjectContains = 'objectContains',
  Opinion = 'opinion',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type OpinionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<OpinionsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum OpinionsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Modified = 'modified',
  ObjectMarking = 'objectMarking',
  Opinion = 'opinion',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export enum OrderingMode {
  Asc = 'asc',
  Desc = 'desc'
}

export type Organization = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Organization';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  sectors?: Maybe<SectorConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_organization_type?: Maybe<Scalars['String']>;
  x_opencti_reliability?: Maybe<OrganizationReliability>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type OrganizationCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type OrganizationExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OrganizationStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OrganizationStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OrganizationAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_organization_type?: InputMaybe<Scalars['String']>;
  x_opencti_reliability?: InputMaybe<OrganizationReliability>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type OrganizationConnection = {
  __typename?: 'OrganizationConnection';
  edges: Array<OrganizationEdge>;
  pageInfo: PageInfo;
};

export type OrganizationEdge = {
  __typename?: 'OrganizationEdge';
  cursor: Scalars['String'];
  node: Organization;
};

export type OrganizationEditMutations = {
  __typename?: 'OrganizationEditMutations';
  contextClean?: Maybe<Organization>;
  contextPatch?: Maybe<Organization>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Organization>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Organization>;
};


export type OrganizationEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type OrganizationEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OrganizationEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type OrganizationEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type OrganizationOrIndividual = Individual | Organization;

export enum OrganizationReliability {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  E = 'E',
  F = 'F'
}

export enum OrganizationsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  ContactInformation = 'contact_information',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Description = 'description',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiReliability = 'x_opencti_reliability',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type OrganizationsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<OrganizationsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum OrganizationsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Modified = 'modified',
  Name = 'name',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type OtpElement = {
  __typename?: 'OtpElement';
  secret: Scalars['String'];
  uri: Scalars['String'];
};

export type OverviewMetrics = {
  __typename?: 'OverviewMetrics';
  message_stats?: Maybe<MessagesStats>;
  node?: Maybe<Scalars['String']>;
  object_totals?: Maybe<ObjectTotals>;
  queue_totals?: Maybe<QueueTotals>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor: Scalars['String'];
  globalCount: Scalars['Int'];
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
};

export type PaymentCard = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'PaymentCard';
  card_number?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  cvv?: Maybe<Scalars['Int']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  expiration_date?: Maybe<Scalars['DateTime']>;
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  holder_name?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type PaymentCardCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type PaymentCardExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PaymentCardStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PaymentCardStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PaymentCardStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PaymentCardStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type PaymentCardAddInput = {
  card_number: Scalars['String'];
  cvv?: InputMaybe<Scalars['Int']>;
  expiration_date?: InputMaybe<Scalars['DateTime']>;
  holder_name?: InputMaybe<Scalars['String']>;
};

export type PhoneNumber = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'PhoneNumber';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type PhoneNumberCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type PhoneNumberExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PhoneNumberStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PhoneNumberStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PhoneNumberStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PhoneNumberStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type PhoneNumberAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type Position = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Position';
  cases?: Maybe<CaseConnection>;
  city?: Maybe<City>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  postal_code?: Maybe<Scalars['String']>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  street_address?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type PositionCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type PositionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PositionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PositionStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type PositionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  postal_code?: InputMaybe<Scalars['String']>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  street_address?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type PositionConnection = {
  __typename?: 'PositionConnection';
  edges?: Maybe<Array<Maybe<PositionEdge>>>;
  pageInfo: PageInfo;
};

export type PositionEdge = {
  __typename?: 'PositionEdge';
  cursor: Scalars['String'];
  node: Position;
};

export type PositionEditMutations = {
  __typename?: 'PositionEditMutations';
  contextClean?: Maybe<Position>;
  contextPatch?: Maybe<Position>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Position>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Position>;
};


export type PositionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type PositionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PositionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type PositionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum PositionsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type PositionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<PositionsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum PositionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  PostalAddress = 'postal_address',
  PostalCode = 'postal_code',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Process = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Process';
  aslr_enabled?: Maybe<Scalars['Boolean']>;
  cases?: Maybe<CaseConnection>;
  command_line?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  created_time?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<Creator>;
  cwd?: Maybe<Scalars['String']>;
  dep_enabled?: Maybe<Scalars['Boolean']>;
  descriptions?: Maybe<Array<Maybe<Scalars['String']>>>;
  display_name?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  environment_variables?: Maybe<Array<Maybe<Scalars['String']>>>;
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  group_name?: Maybe<Scalars['String']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  integrity_level?: Maybe<Scalars['String']>;
  is_hidden?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  owner_sid?: Maybe<Scalars['String']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  pid?: Maybe<Scalars['Int']>;
  priority?: Maybe<Scalars['String']>;
  reports?: Maybe<ReportConnection>;
  serviceDlls?: Maybe<StixFileConnection>;
  service_name?: Maybe<Scalars['String']>;
  service_status?: Maybe<Scalars['String']>;
  service_type?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_type?: Maybe<Scalars['String']>;
  startup_info?: Maybe<Array<Maybe<Dictionary>>>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  window_title?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ProcessCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ProcessExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ProcessStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ProcessStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ProcessStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ProcessAddInput = {
  aslr_enabled?: InputMaybe<Scalars['Boolean']>;
  command_line: Scalars['String'];
  created_time?: InputMaybe<Scalars['DateTime']>;
  cwd?: InputMaybe<Scalars['String']>;
  dep_enabled?: InputMaybe<Scalars['Boolean']>;
  descriptions?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  display_name?: InputMaybe<Scalars['String']>;
  environment_variables?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  group_name?: InputMaybe<Scalars['String']>;
  integrity_level?: InputMaybe<Scalars['String']>;
  is_hidden?: InputMaybe<Scalars['Boolean']>;
  owner_sid?: InputMaybe<Scalars['String']>;
  pid?: InputMaybe<Scalars['Int']>;
  priority?: InputMaybe<Scalars['String']>;
  serviceDlls?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  service_name?: InputMaybe<Scalars['String']>;
  service_status?: InputMaybe<Scalars['String']>;
  service_type?: InputMaybe<Scalars['String']>;
  start_type?: InputMaybe<Scalars['String']>;
  startup_info?: InputMaybe<Array<InputMaybe<DictionaryInput>>>;
  window_title?: InputMaybe<Scalars['String']>;
  x_opencti_description?: InputMaybe<Scalars['String']>;
};

export type Provider = {
  __typename?: 'Provider';
  name: Scalars['String'];
  provider?: Maybe<Scalars['String']>;
  strategy?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  about?: Maybe<AppInfo>;
  administrativeArea?: Maybe<AdministrativeArea>;
  administrativeAreas?: Maybe<AdministrativeAreaConnection>;
  assignees?: Maybe<AssigneeConnection>;
  attackPattern?: Maybe<AttackPattern>;
  attackPatterns?: Maybe<AttackPatternConnection>;
  bookmarks?: Maybe<StixDomainObjectConnection>;
  campaign?: Maybe<Campaign>;
  campaigns?: Maybe<CampaignConnection>;
  campaignsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  capabilities?: Maybe<CapabilityConnection>;
  case?: Maybe<Case>;
  cases?: Maybe<CaseConnection>;
  channel?: Maybe<Channel>;
  channels?: Maybe<ChannelConnection>;
  cities?: Maybe<CityConnection>;
  city?: Maybe<City>;
  connector?: Maybe<Connector>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  connectorsForExport?: Maybe<Array<Maybe<Connector>>>;
  connectorsForImport?: Maybe<Array<Maybe<Connector>>>;
  connectorsForWorker?: Maybe<Array<Maybe<Connector>>>;
  container?: Maybe<Container>;
  containers?: Maybe<ContainerConnection>;
  containersObjectsOfObject?: Maybe<StixObjectOrStixRelationshipConnection>;
  countries?: Maybe<CountryConnection>;
  country?: Maybe<Country>;
  courseOfAction?: Maybe<CourseOfAction>;
  coursesOfAction?: Maybe<CourseOfActionConnection>;
  creators?: Maybe<CreatorConnection>;
  dataComponent?: Maybe<DataComponent>;
  dataComponents?: Maybe<DataComponentConnection>;
  dataSource?: Maybe<DataSource>;
  dataSources?: Maybe<DataSourceConnection>;
  elasticSearchMetrics?: Maybe<ElasticSearchMetrics>;
  enrichmentConnectors?: Maybe<Array<Maybe<Connector>>>;
  entitySetting?: Maybe<EntitySetting>;
  entitySettingByType?: Maybe<EntitySetting>;
  entitySettings?: Maybe<EntitySettingConnection>;
  event?: Maybe<Event>;
  events?: Maybe<EventConnection>;
  externalReference?: Maybe<ExternalReference>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  feed?: Maybe<Feed>;
  feeds?: Maybe<FeedConnection>;
  file?: Maybe<File>;
  group?: Maybe<Group>;
  grouping?: Maybe<Grouping>;
  groupingContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  groupings?: Maybe<GroupingConnection>;
  groupingsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  groupingsNumber?: Maybe<Number>;
  groupingsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  groups?: Maybe<GroupConnection>;
  identities?: Maybe<IdentityConnection>;
  identity?: Maybe<Identity>;
  importFiles?: Maybe<FileConnection>;
  incident?: Maybe<Incident>;
  incidents?: Maybe<IncidentConnection>;
  incidentsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  indicator?: Maybe<Indicator>;
  indicators?: Maybe<IndicatorConnection>;
  indicatorsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  indicatorsNumber?: Maybe<Number>;
  indicatorsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  individual?: Maybe<Individual>;
  individuals?: Maybe<IndividualConnection>;
  infrastructure?: Maybe<Infrastructure>;
  infrastructures?: Maybe<InfrastructureConnection>;
  intrusionSet?: Maybe<IntrusionSet>;
  intrusionSets?: Maybe<IntrusionSetConnection>;
  killChainPhase?: Maybe<KillChainPhase>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  label?: Maybe<Label>;
  labels?: Maybe<LabelConnection>;
  language?: Maybe<Language>;
  languages?: Maybe<LanguageConnection>;
  location?: Maybe<Location>;
  locations?: Maybe<LocationConnection>;
  logs?: Maybe<LogConnection>;
  logsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  logsWorkerConfig?: Maybe<LogsWorkerConfig>;
  malware?: Maybe<Malware>;
  malwares?: Maybe<MalwareConnection>;
  markingDefinition?: Maybe<MarkingDefinition>;
  markingDefinitions?: Maybe<MarkingDefinitionConnection>;
  me: MeUser;
  myOpinion?: Maybe<Opinion>;
  narrative?: Maybe<Narrative>;
  narratives?: Maybe<NarrativeConnection>;
  note?: Maybe<Note>;
  notes?: Maybe<NoteConnection>;
  observedData?: Maybe<ObservedData>;
  observedDataContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  observedDatas?: Maybe<ObservedDataConnection>;
  observedDatasDistribution?: Maybe<Array<Maybe<Distribution>>>;
  observedDatasNumber?: Maybe<Number>;
  observedDatasTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  opinion?: Maybe<Opinion>;
  opinionContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  opinions?: Maybe<OpinionConnection>;
  opinionsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  opinionsNumber?: Maybe<Number>;
  opinionsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  organization?: Maybe<Organization>;
  organizations?: Maybe<OrganizationConnection>;
  otpGeneration?: Maybe<OtpElement>;
  pendingFiles?: Maybe<FileConnection>;
  platform_theme?: Maybe<Scalars['String']>;
  position?: Maybe<Position>;
  positions?: Maybe<PositionConnection>;
  rabbitMQMetrics?: Maybe<RabbitMqMetrics>;
  region?: Maybe<Region>;
  regions?: Maybe<RegionConnection>;
  report?: Maybe<Report>;
  reportContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  reports?: Maybe<ReportConnection>;
  reportsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  reportsNumber?: Maybe<Number>;
  reportsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  retentionRule?: Maybe<RetentionRule>;
  retentionRules?: Maybe<RetentionRuleConnection>;
  role?: Maybe<Role>;
  roles?: Maybe<RoleConnection>;
  rule?: Maybe<Rule>;
  ruleManagerInfo?: Maybe<RuleManager>;
  rules?: Maybe<Array<Maybe<Rule>>>;
  runtimeAttributes?: Maybe<AttributeConnection>;
  schemaAttributes?: Maybe<AttributeConnection>;
  sector?: Maybe<Sector>;
  sectors?: Maybe<SectorConnection>;
  sessions?: Maybe<Array<Maybe<UserSession>>>;
  settings: Settings;
  status?: Maybe<Status>;
  statusTemplate?: Maybe<StatusTemplate>;
  statusTemplates?: Maybe<StatusTemplateConnection>;
  statuses?: Maybe<StatusConnection>;
  stix?: Maybe<Scalars['String']>;
  stixCoreObject?: Maybe<StixCoreObject>;
  stixCoreObjectOrStixCoreRelationship?: Maybe<StixCoreObjectOrStixCoreRelationship>;
  stixCoreObjectRaw?: Maybe<Scalars['String']>;
  stixCoreObjects?: Maybe<StixCoreObjectConnection>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreObjectsExportFiles?: Maybe<FileConnection>;
  stixCoreObjectsMultiDistribution?: Maybe<Array<Maybe<MultiDistribution>>>;
  stixCoreObjectsMultiNumber?: Maybe<Array<Maybe<Number>>>;
  stixCoreObjectsMultiTimeSeries?: Maybe<Array<Maybe<MultiTimeSeries>>>;
  stixCoreObjectsNumber?: Maybe<Number>;
  stixCoreObjectsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixCoreRelationship?: Maybe<StixCoreRelationship>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationshipsExportFiles?: Maybe<FileConnection>;
  stixCoreRelationshipsMultiTimeSeries?: Maybe<Array<Maybe<MultiTimeSeries>>>;
  stixCoreRelationshipsNumber?: Maybe<Number>;
  stixCoreRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixCyberObservable?: Maybe<StixCyberObservable>;
  stixCyberObservableRelationship?: Maybe<StixCyberObservableRelationship>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  stixCyberObservableRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationshipsNumber?: Maybe<Number>;
  stixCyberObservableRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixCyberObservables?: Maybe<StixCyberObservableConnection>;
  stixCyberObservablesDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservablesExportFiles?: Maybe<FileConnection>;
  stixCyberObservablesNumber?: Maybe<Number>;
  stixCyberObservablesTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixDomainObject?: Maybe<StixDomainObject>;
  stixDomainObjects?: Maybe<StixDomainObjectConnection>;
  stixDomainObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixDomainObjectsExportFiles?: Maybe<FileConnection>;
  stixDomainObjectsNumber?: Maybe<Number>;
  stixDomainObjectsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixMetaRelationship?: Maybe<StixMetaRelationship>;
  stixMetaRelationships?: Maybe<StixMetaRelationshipConnection>;
  stixMetaRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixMetaRelationshipsNumber?: Maybe<Number>;
  stixObjectOrStixRelationship?: Maybe<StixObjectOrStixRelationship>;
  stixRelationship?: Maybe<StixRelationship>;
  stixRelationships?: Maybe<StixRelationshipConnection>;
  stixSightingRelationship?: Maybe<StixSightingRelationship>;
  stixSightingRelationships?: Maybe<StixSightingRelationshipConnection>;
  stixSightingRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixSightingRelationshipsNumber?: Maybe<Number>;
  stixSightingRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  streamCollection?: Maybe<StreamCollection>;
  streamCollections?: Maybe<StreamCollectionConnection>;
  subType?: Maybe<SubType>;
  subTypes: SubTypeConnection;
  synchronizer?: Maybe<Synchronizer>;
  synchronizers?: Maybe<SynchronizerConnection>;
  system?: Maybe<System>;
  systems?: Maybe<SystemConnection>;
  task?: Maybe<Task>;
  tasks?: Maybe<TaskConnection>;
  taxiiCollection?: Maybe<TaxiiCollection>;
  taxiiCollections?: Maybe<TaxiiCollectionConnection>;
  threatActor?: Maybe<ThreatActor>;
  threatActors?: Maybe<ThreatActorConnection>;
  tool?: Maybe<Tool>;
  tools?: Maybe<ToolConnection>;
  user?: Maybe<User>;
  userSubscription?: Maybe<UserSubscription>;
  userSubscriptions?: Maybe<UserSubscriptionConnection>;
  users?: Maybe<UserConnection>;
  vocabularies?: Maybe<VocabularyConnection>;
  vocabulary?: Maybe<Vocabulary>;
  vocabularyCategories: Array<VocabularyDefinition>;
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  vulnerability?: Maybe<Vulnerability>;
  work?: Maybe<Work>;
  works?: Maybe<WorkConnection>;
  workspace?: Maybe<Workspace>;
  workspaces?: Maybe<WorkspaceConnection>;
};


export type QueryAdministrativeAreaArgs = {
  id: Scalars['String'];
};


export type QueryAdministrativeAreasArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<AdministrativeAreasFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AdministrativeAreasOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryAssigneesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryAttackPatternArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryAttackPatternsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<AttackPatternsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AttackPatternsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryCampaignArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCampaignsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CampaignsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CampaignsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCampaignsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  startDate: Scalars['DateTime'];
};


export type QueryCapabilitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryCaseArgs = {
  id: Scalars['String'];
};


export type QueryCasesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<CasesFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CasesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryChannelArgs = {
  id: Scalars['String'];
};


export type QueryChannelsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<ChannelsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ChannelsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryCitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCityArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryConnectorArgs = {
  id: Scalars['String'];
};


export type QueryContainerArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryContainersObjectsOfObjectArgs = {
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  id: Scalars['String'];
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryCountriesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CountriesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CountriesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCountryArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCourseOfActionArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCoursesOfActionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CoursesOfActionFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CoursesOfActionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCreatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryDataComponentArgs = {
  id: Scalars['String'];
};


export type QueryDataComponentsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<DataComponentsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DataComponentsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryDataSourceArgs = {
  id: Scalars['String'];
};


export type QueryDataSourcesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<DataSourcesFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DataSourcesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryEnrichmentConnectorsArgs = {
  type: Scalars['String'];
};


export type QueryEntitySettingArgs = {
  id: Scalars['String'];
};


export type QueryEntitySettingByTypeArgs = {
  targetType: Scalars['String'];
};


export type QueryEntitySettingsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<EntitySettingsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EntitySettingsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryEventArgs = {
  id: Scalars['String'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<EventsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EventsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryExternalReferenceArgs = {
  id: Scalars['String'];
};


export type QueryExternalReferencesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ExternalReferencesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ExternalReferencesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryFeedArgs = {
  id: Scalars['String'];
};


export type QueryFeedsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FeedOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryFileArgs = {
  id: Scalars['String'];
};


export type QueryGroupArgs = {
  id: Scalars['String'];
};


export type QueryGroupingArgs = {
  id: Scalars['String'];
};


export type QueryGroupingContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryGroupingsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<GroupingsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GroupingsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryGroupingsDistributionArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<GroupingsFiltering>>;
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryGroupingsNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<GroupingsFiltering>>;
  groupingContext?: InputMaybe<Scalars['String']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryGroupingsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<GroupingsFiltering>>;
  groupingType?: InputMaybe<Scalars['String']>;
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GroupsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIdentitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IdentitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IdentitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryIdentityArgs = {
  id: Scalars['String'];
};


export type QueryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryIncidentArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryIncidentsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IncidentsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IncidentsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryIncidentsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  startDate: Scalars['DateTime'];
};


export type QueryIndicatorArgs = {
  id: Scalars['String'];
};


export type QueryIndicatorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IndicatorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndicatorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIndicatorsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryIndicatorsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
  pattern_type?: InputMaybe<Scalars['String']>;
};


export type QueryIndicatorsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IndicatorsFiltering>>>;
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryIndividualArgs = {
  id: Scalars['String'];
};


export type QueryIndividualsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IndividualsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndividualsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryInfrastructureArgs = {
  id: Scalars['String'];
};


export type QueryInfrastructuresArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<InfrastructuresFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<InfrastructuresOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIntrusionSetArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryIntrusionSetsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IntrusionSetsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IntrusionSetsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryKillChainPhaseArgs = {
  id: Scalars['String'];
};


export type QueryKillChainPhasesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<KillChainPhasesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<KillChainPhasesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLabelArgs = {
  id: Scalars['String'];
};


export type QueryLabelsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<LabelsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLanguageArgs = {
  id: Scalars['String'];
};


export type QueryLanguagesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<LanguagesFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LanguagesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLocationArgs = {
  id: Scalars['String'];
};


export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<LocationsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LocationsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryLogsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<LogsFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LogsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLogsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<LogsFiltering>>;
  interval: Scalars['String'];
  operation: StatsOperation;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  userId?: InputMaybe<Scalars['String']>;
};


export type QueryMalwareArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryMalwaresArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<MalwaresFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MalwaresOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryMarkingDefinitionArgs = {
  id: Scalars['String'];
};


export type QueryMarkingDefinitionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<MarkingDefinitionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MarkingDefinitionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryMyOpinionArgs = {
  id: Scalars['String'];
};


export type QueryNarrativeArgs = {
  id: Scalars['String'];
};


export type QueryNarrativesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<NarrativesFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NarrativesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryNoteArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryNotesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<NotesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NotesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryObservedDataArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDataContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryObservedDatasArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ObservedDatasFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ObservedDatasOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryObservedDatasDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDatasNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDatasTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryOpinionArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryOpinionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<OpinionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OpinionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryOpinionsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryOrganizationArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<OrganizationsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrganizationsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryPositionArgs = {
  id: Scalars['String'];
};


export type QueryPositionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<PositionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PositionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRabbitMqMetricsArgs = {
  prefix?: InputMaybe<Scalars['String']>;
};


export type QueryRegionArgs = {
  id: Scalars['String'];
};


export type QueryRegionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<RegionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RegionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryReportArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryReportContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryReportsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ReportsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ReportsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryReportsDistributionArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ReportsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryReportsNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ReportsFiltering>>>;
  objectId?: InputMaybe<Scalars['String']>;
  reportType?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryReportsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ReportsFiltering>>>;
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  reportType?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryRetentionRuleArgs = {
  id: Scalars['String'];
};


export type QueryRetentionRulesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryRoleArgs = {
  id: Scalars['String'];
};


export type QueryRolesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RolesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryRuleArgs = {
  id: Scalars['String'];
};


export type QueryRuntimeAttributesArgs = {
  attributeName: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySchemaAttributesArgs = {
  elementType: Array<InputMaybe<Scalars['String']>>;
};


export type QuerySectorArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QuerySectorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<SectorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SectorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryStatusArgs = {
  id: Scalars['String'];
};


export type QueryStatusTemplateArgs = {
  id: Scalars['String'];
};


export type QueryStatusTemplatesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StatusTemplateOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryStatusesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<StatusesFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StatusOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryStixArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectOrStixCoreRelationshipArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectRawArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixCoreObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreObjectsExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  type: Scalars['String'];
};


export type QueryStixCoreObjectsMultiDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  distributionParameters?: InputMaybe<StixCoreObjectsDistributionParameters>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryStixCoreObjectsMultiNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  numberParameters?: InputMaybe<Array<InputMaybe<StixCoreObjectsNumberParameters>>>;
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryStixCoreObjectsMultiTimeSeriesArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  interval: Scalars['String'];
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
  timeSeriesParameters?: InputMaybe<Array<InputMaybe<StixCoreObjectsTimeSeriesParameters>>>;
};


export type QueryStixCoreObjectsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreObjectsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  interval: Scalars['String'];
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  dynamicFrom?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  dynamicTo?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipsExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  type: Scalars['String'];
};


export type QueryStixCoreRelationshipsMultiTimeSeriesArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  interval: Scalars['String'];
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
  timeSeriesParameters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsTimeSeriesParameters>>>;
};


export type QueryStixCoreRelationshipsNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  noDirection?: InputMaybe<Scalars['Boolean']>;
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipsTimeSeriesArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  interval: Scalars['String'];
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableArgs = {
  id: Scalars['String'];
};


export type QueryStixCyberObservableRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  fromId: Scalars['StixRef'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableRelationshipsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
};


export type QueryStixCyberObservableRelationshipsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  fromId?: InputMaybe<Scalars['StixRef']>;
  interval: Scalars['String'];
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryStixCyberObservablesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixCyberObservablesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservablesDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: Scalars['String'];
  search?: InputMaybe<Scalars['String']>;
};


export type QueryStixCyberObservablesExportFilesArgs = {
  context?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryStixCyberObservablesNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservablesTimeSeriesArgs = {
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectArgs = {
  id: Scalars['String'];
};


export type QueryStixDomainObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixDomainObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  type: Scalars['String'];
};


export type QueryStixDomainObjectsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  interval: Scalars['String'];
  onlyInferred?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixMetaRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixMetaRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixMetaRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixMetaRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixMetaRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixMetaRelationshipsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
};


export type QueryStixRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixSightingRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixSightingRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixSightingRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixSightingRelationshipsFiltering>>>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipsNumberArgs = {
  elementId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixSightingRelationshipsFiltering>>>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipsTimeSeriesArgs = {
  elementId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixSightingRelationshipsFiltering>>>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  interval: Scalars['String'];
  operation: StatsOperation;
  search?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStreamCollectionArgs = {
  id: Scalars['String'];
};


export type QueryStreamCollectionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamCollectionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySubTypeArgs = {
  id: Scalars['String'];
};


export type QuerySubTypesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  includeParents?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<SubTypesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};


export type QuerySynchronizerArgs = {
  id: Scalars['String'];
};


export type QuerySynchronizersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SynchronizersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySystemArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QuerySystemsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<SystemsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SystemsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryTaskArgs = {
  id: Scalars['String'];
};


export type QueryTasksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<TasksFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TasksOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryTaxiiCollectionArgs = {
  id: Scalars['String'];
};


export type QueryTaxiiCollectionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TaxiiCollectionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryThreatActorArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryThreatActorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ThreatActorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ThreatActorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryToolArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryToolsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ToolsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ToolsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryUserArgs = {
  id: Scalars['String'];
};


export type QueryUserSubscriptionArgs = {
  id: Scalars['String'];
};


export type QueryUserSubscriptionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserSubscriptionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<UsersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UsersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryVocabulariesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  category?: InputMaybe<VocabularyCategory>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<VocabularyFiltering>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<VocabularyOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryVocabularyArgs = {
  id: Scalars['String'];
};


export type QueryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<VulnerabilitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<VulnerabilitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryVulnerabilityArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryWorkArgs = {
  id: Scalars['ID'];
};


export type QueryWorksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<WorksFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WorksOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryWorkspaceArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryWorkspacesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<WorkspacesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WorkspacesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryTask = Task & {
  __typename?: 'QueryTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<Creator>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_filters: Scalars['String'];
  task_processed_number?: Maybe<Scalars['Int']>;
  task_search?: Maybe<Scalars['String']>;
  type?: Maybe<TaskType>;
};

export type QueryTaskAddInput = {
  actions: Array<InputMaybe<TaskActionInput>>;
  excluded_ids?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  filters: Scalars['String'];
  search?: InputMaybe<Scalars['String']>;
};

export type QueueArguments = {
  __typename?: 'QueueArguments';
  config?: Maybe<Scalars['String']>;
};

export type QueueMetrics = {
  __typename?: 'QueueMetrics';
  arguments?: Maybe<QueueArguments>;
  consumers?: Maybe<Scalars['String']>;
  idle_since?: Maybe<Scalars['DateTime']>;
  message_stats?: Maybe<MessagesStats>;
  messages?: Maybe<Scalars['String']>;
  messages_ready?: Maybe<Scalars['String']>;
  messages_unacknowledged?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

export type QueueTotals = {
  __typename?: 'QueueTotals';
  messages?: Maybe<Scalars['String']>;
  messages_ready?: Maybe<Scalars['String']>;
  messages_unacknowledged?: Maybe<Scalars['String']>;
};

export type RabbitMqConnection = {
  __typename?: 'RabbitMQConnection';
  ca?: Maybe<Array<Maybe<Scalars['String']>>>;
  host: Scalars['String'];
  pass: Scalars['String'];
  port: Scalars['Int'];
  use_ssl: Scalars['Boolean'];
  user: Scalars['String'];
  vhost: Scalars['String'];
};

export type RabbitMqMetrics = {
  __typename?: 'RabbitMQMetrics';
  consumers?: Maybe<Scalars['String']>;
  overview?: Maybe<OverviewMetrics>;
  queues?: Maybe<Array<Maybe<QueueMetrics>>>;
};

export type Region = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Region';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  countries?: Maybe<CountryConnection>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  isSubRegion?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentRegions?: Maybe<RegionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  subRegions?: Maybe<RegionConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type RegionCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type RegionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type RegionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type RegionStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type RegionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type RegionConnection = {
  __typename?: 'RegionConnection';
  edges?: Maybe<Array<Maybe<RegionEdge>>>;
  pageInfo: PageInfo;
};

export type RegionEdge = {
  __typename?: 'RegionEdge';
  cursor: Scalars['String'];
  node: Region;
};

export type RegionEditMutations = {
  __typename?: 'RegionEditMutations';
  contextClean?: Maybe<Region>;
  contextPatch?: Maybe<Region>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Region>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Region>;
};


export type RegionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type RegionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type RegionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type RegionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum RegionsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type RegionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<RegionsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum RegionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type RegisterConnectorInput = {
  auto?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  only_contextual?: InputMaybe<Scalars['Boolean']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
  type: ConnectorType;
};

export type Report = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Report';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  deleteWithElementsCount?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  published?: Maybe<Scalars['DateTime']>;
  relatedContainers?: Maybe<ContainerConnection>;
  report_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ReportCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ReportExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ReportAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  published: Scalars['DateTime'];
  report_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ReportConnection = {
  __typename?: 'ReportConnection';
  edges?: Maybe<Array<Maybe<ReportEdge>>>;
  pageInfo: PageInfo;
};

export type ReportEdge = {
  __typename?: 'ReportEdge';
  cursor: Scalars['String'];
  node: Report;
};

export type ReportEditMutations = {
  __typename?: 'ReportEditMutations';
  contextClean?: Maybe<Report>;
  contextPatch?: Maybe<Report>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Report>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Report>;
};


export type ReportEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ReportEditMutationsDeleteArgs = {
  purgeElements?: InputMaybe<Scalars['Boolean']>;
};


export type ReportEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ReportEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum ReportsFilter {
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Name = 'name',
  ObjectContains = 'objectContains',
  ObjectLabel = 'objectLabel',
  Published = 'published',
  PublishedDay = 'published_day',
  ReportTypes = 'report_types',
  Revoked = 'revoked',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ReportsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ReportsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ReportsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  ReportTypes = 'report_types',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type RetentionRule = {
  __typename?: 'RetentionRule';
  filters: Scalars['String'];
  id: Scalars['ID'];
  last_deleted_count?: Maybe<Scalars['Int']>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  max_retention: Scalars['Int'];
  name: Scalars['String'];
  remaining_count?: Maybe<Scalars['Int']>;
  standard_id: Scalars['String'];
};

export type RetentionRuleAddInput = {
  filters: Scalars['String'];
  max_retention: Scalars['Int'];
  name: Scalars['String'];
};

export type RetentionRuleConnection = {
  __typename?: 'RetentionRuleConnection';
  edges?: Maybe<Array<Maybe<RetentionRuleEdge>>>;
  pageInfo: PageInfo;
};

export type RetentionRuleEdge = {
  __typename?: 'RetentionRuleEdge';
  cursor: Scalars['String'];
  node: RetentionRule;
};

export type RetentionRuleEditMutations = {
  __typename?: 'RetentionRuleEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<RetentionRule>;
};


export type RetentionRuleEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export type Role = BasicObject & InternalObject & {
  __typename?: 'Role';
  capabilities?: Maybe<Array<Maybe<Capability>>>;
  created_at: Scalars['DateTime'];
  default_assignation?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type RoleAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type RoleConnection = {
  __typename?: 'RoleConnection';
  edges?: Maybe<Array<Maybe<RoleEdge>>>;
  pageInfo: PageInfo;
};

export type RoleEdge = {
  __typename?: 'RoleEdge';
  cursor: Scalars['String'];
  node: Role;
};

export type RoleEditMutations = {
  __typename?: 'RoleEditMutations';
  contextClean?: Maybe<Role>;
  contextPatch?: Maybe<Role>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Role>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<Role>;
};


export type RoleEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type RoleEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type RoleEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type RoleEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum RolesOrdering {
  CreatedAt = 'created_at',
  DefaultAssignation = 'default_assignation',
  Name = 'name',
  UpdatedAt = 'updated_at'
}

export type Rule = {
  __typename?: 'Rule';
  activated: Scalars['Boolean'];
  category?: Maybe<Scalars['String']>;
  description: Scalars['String'];
  display?: Maybe<Display>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type RuleExecutionError = {
  __typename?: 'RuleExecutionError';
  error?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export type RuleManager = {
  __typename?: 'RuleManager';
  activated: Scalars['Boolean'];
  errors?: Maybe<Array<Maybe<RuleExecutionError>>>;
  id: Scalars['ID'];
  lastEventId?: Maybe<Scalars['String']>;
};

export type RuleTask = Task & {
  __typename?: 'RuleTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  enable?: Maybe<Scalars['Boolean']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<Creator>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  rule: Scalars['ID'];
  task_expected_number?: Maybe<Scalars['Int']>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type SearchMetrics = {
  __typename?: 'SearchMetrics';
  fetch_total?: Maybe<Scalars['String']>;
  query_total?: Maybe<Scalars['String']>;
};

export type Sector = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Sector';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  isSubSector?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentSectors?: Maybe<SectorConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  subSectors?: Maybe<SectorConnection>;
  targetedOrganizations?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type SectorCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SectorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SectorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SectorStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SectorAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type SectorConnection = {
  __typename?: 'SectorConnection';
  edges?: Maybe<Array<Maybe<SectorEdge>>>;
  pageInfo: PageInfo;
};

export type SectorEdge = {
  __typename?: 'SectorEdge';
  cursor: Scalars['String'];
  node: Sector;
};

export type SectorEditMutations = {
  __typename?: 'SectorEditMutations';
  contextClean?: Maybe<Sector>;
  contextPatch?: Maybe<Sector>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Sector>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Sector>;
};


export type SectorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SectorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SectorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type SectorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum SectorsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  PartOf = 'partOf',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type SectorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<SectorsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum SectorsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type SessionDetail = {
  __typename?: 'SessionDetail';
  created?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  ttl?: Maybe<Scalars['Int']>;
};

export type Settings = BasicObject & InternalObject & {
  __typename?: 'Settings';
  created_at: Scalars['DateTime'];
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  otp_mandatory?: Maybe<Scalars['Boolean']>;
  parent_types: Array<Scalars['String']>;
  platform_cluster: Cluster;
  platform_email?: Maybe<Scalars['String']>;
  platform_favicon?: Maybe<Scalars['String']>;
  platform_feature_flags?: Maybe<Array<Module>>;
  platform_language?: Maybe<Scalars['String']>;
  platform_login_message?: Maybe<Scalars['String']>;
  platform_map_tile_server_dark?: Maybe<Scalars['String']>;
  platform_map_tile_server_light?: Maybe<Scalars['String']>;
  platform_modules?: Maybe<Array<Module>>;
  platform_organization?: Maybe<Organization>;
  platform_providers: Array<Provider>;
  platform_reference_attachment?: Maybe<Scalars['Boolean']>;
  platform_theme?: Maybe<Scalars['String']>;
  platform_theme_dark_accent?: Maybe<Scalars['String']>;
  platform_theme_dark_background?: Maybe<Scalars['String']>;
  platform_theme_dark_logo?: Maybe<Scalars['String']>;
  platform_theme_dark_logo_collapsed?: Maybe<Scalars['String']>;
  platform_theme_dark_logo_login?: Maybe<Scalars['String']>;
  platform_theme_dark_nav?: Maybe<Scalars['String']>;
  platform_theme_dark_paper?: Maybe<Scalars['String']>;
  platform_theme_dark_primary?: Maybe<Scalars['String']>;
  platform_theme_dark_secondary?: Maybe<Scalars['String']>;
  platform_theme_light_accent?: Maybe<Scalars['String']>;
  platform_theme_light_background?: Maybe<Scalars['String']>;
  platform_theme_light_logo?: Maybe<Scalars['String']>;
  platform_theme_light_logo_collapsed?: Maybe<Scalars['String']>;
  platform_theme_light_logo_login?: Maybe<Scalars['String']>;
  platform_theme_light_nav?: Maybe<Scalars['String']>;
  platform_theme_light_paper?: Maybe<Scalars['String']>;
  platform_theme_light_primary?: Maybe<Scalars['String']>;
  platform_theme_light_secondary?: Maybe<Scalars['String']>;
  platform_title?: Maybe<Scalars['String']>;
  platform_url?: Maybe<Scalars['String']>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type SettingsEditMutations = {
  __typename?: 'SettingsEditMutations';
  contextClean?: Maybe<Settings>;
  contextPatch?: Maybe<Settings>;
  fieldPatch?: Maybe<Settings>;
};


export type SettingsEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SettingsEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export type Software = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Software';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  cpe?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  languages?: Maybe<Array<Maybe<Scalars['String']>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  swid?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  vendor?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type SoftwareCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SoftwareExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwarePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SoftwareStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SoftwareStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SoftwareStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SoftwareAddInput = {
  cpe?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name?: InputMaybe<Scalars['String']>;
  swid?: InputMaybe<Scalars['String']>;
  vendor?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

export enum State {
  Complete = 'complete',
  Progress = 'progress',
  Timeout = 'timeout',
  Wait = 'wait'
}

export enum StatsOperation {
  Count = 'count',
  Sum = 'sum'
}

export type Status = {
  __typename?: 'Status';
  disabled?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  order: Scalars['Int'];
  template?: Maybe<StatusTemplate>;
  template_id: Scalars['String'];
  type: Scalars['String'];
};

export type StatusAddInput = {
  order: Scalars['Int'];
  template_id: Scalars['String'];
};

export type StatusConnection = {
  __typename?: 'StatusConnection';
  edges: Array<StatusEdge>;
  pageInfo: PageInfo;
};

export type StatusEdge = {
  __typename?: 'StatusEdge';
  cursor: Scalars['String'];
  node: Status;
};

export enum StatusFilter {
  Type = 'type'
}

export enum StatusOrdering {
  Order = 'order',
  Type = 'type'
}

export type StatusTemplate = {
  __typename?: 'StatusTemplate';
  color: Scalars['String'];
  editContext?: Maybe<Array<EditUserContext>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  usages?: Maybe<Scalars['Int']>;
};

export type StatusTemplateAddInput = {
  color: Scalars['String'];
  name: Scalars['String'];
};

export type StatusTemplateConnection = {
  __typename?: 'StatusTemplateConnection';
  edges?: Maybe<Array<Maybe<StatusTemplateEdge>>>;
  pageInfo: PageInfo;
};

export type StatusTemplateEdge = {
  __typename?: 'StatusTemplateEdge';
  cursor: Scalars['String'];
  node: StatusTemplate;
};

export enum StatusTemplateOrdering {
  Name = 'name'
}

export type StatusesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StatusFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<Scalars['String']>>;
};

export type StixCoreObject = {
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixCoreObjectCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixCoreObjectExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCoreObjectStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCoreObjectStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreObjectConnection = {
  __typename?: 'StixCoreObjectConnection';
  edges?: Maybe<Array<Maybe<StixCoreObjectEdge>>>;
  pageInfo: PageInfo;
};

export type StixCoreObjectEdge = {
  __typename?: 'StixCoreObjectEdge';
  cursor: Scalars['String'];
  node: StixCoreObject;
};

export type StixCoreObjectEditMutations = {
  __typename?: 'StixCoreObjectEditMutations';
  askEnrichment?: Maybe<Work>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  importPush?: Maybe<File>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCoreObject>;
  relationsAdd?: Maybe<StixCoreObject>;
  restrictionOrganizationAdd?: Maybe<StixCoreObject>;
  restrictionOrganizationDelete?: Maybe<StixCoreObject>;
};


export type StixCoreObjectEditMutationsAskEnrichmentArgs = {
  connectorId: Scalars['ID'];
};


export type StixCoreObjectEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixCoreObjectEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCoreObjectEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
  noTriggerImport?: InputMaybe<Scalars['Boolean']>;
};


export type StixCoreObjectEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCoreObjectEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type StixCoreObjectEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};


export type StixCoreObjectEditMutationsRestrictionOrganizationAddArgs = {
  organizationId: Scalars['ID'];
};


export type StixCoreObjectEditMutationsRestrictionOrganizationDeleteArgs = {
  organizationId: Scalars['ID'];
};

export type StixCoreObjectOrStixCoreRelationship = AdministrativeArea | Artifact | AttackPattern | AutonomousSystem | BankAccount | Campaign | Case | Channel | City | Country | CourseOfAction | CryptocurrencyWallet | CryptographicKey | DataComponent | DataSource | Directory | DomainName | EmailAddr | EmailMessage | EmailMimePartType | EntitySetting | Event | Grouping | Hostname | IPv4Addr | IPv6Addr | Incident | Indicator | Individual | Infrastructure | IntrusionSet | Language | MacAddr | Malware | MediaContent | Mutex | Narrative | NetworkTraffic | Note | ObservedData | Opinion | Organization | PaymentCard | PhoneNumber | Position | Process | Region | Report | Sector | Software | StixCoreRelationship | StixFile | Text | ThreatActor | Tool | Url | UserAccount | UserAgent | Vulnerability | WindowsRegistryKey | WindowsRegistryValueType | X509Certificate;

export type StixCoreObjectsDistributionParameters = {
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  objectId?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreObjectsFilter {
  Abstract = 'abstract',
  Aliases = 'aliases',
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  IncidentTypes = 'incident_types',
  Indicates = 'indicates',
  IndicatorTypes = 'indicator_types',
  KillChainPhase = 'killChainPhase',
  LabelledBy = 'labelledBy',
  MalwareTypes = 'malware_types',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContains = 'objectContains',
  PatternType = 'pattern_type',
  Published = 'published',
  RelatedTo = 'relatedTo',
  ReportTypes = 'report_types',
  Subject = 'subject',
  Targets = 'targets',
  ThreatActorTypes = 'threat_actor_types',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  Value = 'value',
  XMitreId = 'x_mitre_id',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiDetection = 'x_opencti_detection',
  XOpenctiMainObservableType = 'x_opencti_main_observable_type',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixCoreObjectsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixCoreObjectsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreObjectsNumberParameters = {
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreObjectsOrdering {
  Score = '_score',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  IndicatorPattern = 'indicator_pattern',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  ObservableValue = 'observable_value',
  Published = 'published',
  Subject = 'subject',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  Value = 'value',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixCoreObjectsTimeSeriesParameters = {
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixCoreRelationship';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_time?: Maybe<Scalars['DateTime']>;
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stop_time?: Maybe<Scalars['DateTime']>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixCoreRelationshipCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreRelationshipAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromId: Scalars['StixRef'];
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type: Scalars['String'];
  revoked?: InputMaybe<Scalars['Boolean']>;
  start_time?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  stop_time?: InputMaybe<Scalars['DateTime']>;
  toId: Scalars['StixRef'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type StixCoreRelationshipConnection = {
  __typename?: 'StixCoreRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixCoreRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixCoreRelationshipEdge = {
  __typename?: 'StixCoreRelationshipEdge';
  cursor: Scalars['String'];
  node: StixCoreRelationship;
};

export type StixCoreRelationshipEditMutations = {
  __typename?: 'StixCoreRelationshipEditMutations';
  contextClean?: Maybe<StixCoreRelationship>;
  contextPatch?: Maybe<StixCoreRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixCoreRelationship>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCoreRelationship>;
  restrictionOrganizationAdd?: Maybe<StixCoreRelationship>;
  restrictionOrganizationDelete?: Maybe<StixCoreRelationship>;
};


export type StixCoreRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCoreRelationshipEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCoreRelationshipEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCoreRelationshipEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type StixCoreRelationshipEditMutationsRestrictionOrganizationAddArgs = {
  organizationId: Scalars['ID'];
};


export type StixCoreRelationshipEditMutationsRestrictionOrganizationDeleteArgs = {
  organizationId: Scalars['ID'];
};

export type StixCoreRelationshipsDistributionParameters = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreRelationshipsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  ElementId = 'elementId',
  ElementWithTargetTypes = 'elementWithTargetTypes',
  EntityType = 'entity_type',
  FromId = 'fromId',
  FromName = 'fromName',
  FromTypes = 'fromTypes',
  KillChainPhase = 'killChainPhase',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  RelationshipType = 'relationship_type',
  Revoked = 'revoked',
  ToCreatedAt = 'toCreatedAt',
  ToId = 'toId',
  ToMainObservableType = 'toMainObservableType',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToTypes = 'toTypes',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixCoreRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixCoreRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  KillChainPhase = 'killChainPhase',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StopTime = 'stop_time',
  ToName = 'toName',
  ToObservableValue = 'toObservableValue',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixCoreRelationshipsTimeSeriesParameters = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCyberObservable = {
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixCyberObservableCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixCyberObservableExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservablePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCyberObservableConnection = {
  __typename?: 'StixCyberObservableConnection';
  edges: Array<StixCyberObservableEdge>;
  pageInfo: PageInfo;
};

export type StixCyberObservableEdge = {
  __typename?: 'StixCyberObservableEdge';
  cursor: Scalars['String'];
  node: StixCyberObservable;
};

export type StixCyberObservableEditMutations = {
  __typename?: 'StixCyberObservableEditMutations';
  contextClean?: Maybe<StixCyberObservable>;
  contextPatch?: Maybe<StixCyberObservable>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  fieldPatch?: Maybe<StixCyberObservable>;
  importPush?: Maybe<File>;
  promote?: Maybe<StixCyberObservable>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCyberObservable>;
  relationsAdd?: Maybe<StixCyberObservable>;
};


export type StixCyberObservableEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCyberObservableEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixCyberObservableEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCyberObservableEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
  noTriggerImport?: InputMaybe<Scalars['Boolean']>;
};


export type StixCyberObservableEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCyberObservableEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type StixCyberObservableEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};

export type StixCyberObservableRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixCyberObservableRelationship';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  notes?: Maybe<NoteConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_time?: Maybe<Scalars['DateTime']>;
  stop_time?: Maybe<Scalars['DateTime']>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixCyberObservableRelationshipCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableRelationshipGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableRelationshipNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableRelationshipOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableRelationshipReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type StixCyberObservableRelationshipAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  fromId: Scalars['StixRef'];
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type: Scalars['String'];
  start_time?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  stop_time?: InputMaybe<Scalars['DateTime']>;
  toId: Scalars['StixRef'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type StixCyberObservableRelationshipConnection = {
  __typename?: 'StixCyberObservableRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixCyberObservableRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixCyberObservableRelationshipEdge = {
  __typename?: 'StixCyberObservableRelationshipEdge';
  cursor: Scalars['String'];
  node: StixCyberObservableRelationship;
};

export type StixCyberObservableRelationshipEditMutations = {
  __typename?: 'StixCyberObservableRelationshipEditMutations';
  contextClean?: Maybe<StixCyberObservableRelationship>;
  contextPatch?: Maybe<StixCyberObservableRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixCyberObservableRelationship>;
};


export type StixCyberObservableRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCyberObservableRelationshipEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum StixCyberObservableRelationshipsFilter {
  CreatedAt = 'created_at'
}

export type StixCyberObservableRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixCyberObservableRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCyberObservableRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  Modified = 'modified',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StopTime = 'stop_time',
  ToCreatedAt = 'toCreatedAt',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at'
}

export enum StixCyberObservablesFilter {
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  HashesMd5 = 'hashes_MD5',
  HashesSha1 = 'hashes_SHA1',
  HashesSha256 = 'hashes_SHA256',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContained = 'objectContained',
  RelatedTo = 'relatedTo',
  SightedBy = 'sightedBy',
  Subject = 'subject',
  UpdatedAt = 'updated_at',
  Value = 'value',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiScore = 'x_opencti_score'
}

export type StixCyberObservablesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixCyberObservablesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCyberObservablesOrdering {
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  ObjectMarking = 'objectMarking',
  ObservableValue = 'observable_value',
  UpdatedAt = 'updated_at'
}

export type StixDomainObject = {
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixDomainObjectCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixDomainObjectExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixDomainObjectStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixDomainObjectStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixDomainObjectAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  context?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  pattern?: InputMaybe<Scalars['String']>;
  pattern_type?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  type: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type StixDomainObjectConnection = {
  __typename?: 'StixDomainObjectConnection';
  edges?: Maybe<Array<Maybe<StixDomainObjectEdge>>>;
  pageInfo: PageInfo;
};

export type StixDomainObjectEdge = {
  __typename?: 'StixDomainObjectEdge';
  cursor: Scalars['String'];
  node: StixDomainObject;
};

export type StixDomainObjectEditMutations = {
  __typename?: 'StixDomainObjectEditMutations';
  changeType?: Maybe<StixDomainObject>;
  contextClean?: Maybe<StixDomainObject>;
  contextPatch?: Maybe<StixDomainObject>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  fieldPatch?: Maybe<StixDomainObject>;
  importPush?: Maybe<File>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixDomainObject>;
  relationsAdd?: Maybe<StixDomainObject>;
};


export type StixDomainObjectEditMutationsChangeTypeArgs = {
  newType: Scalars['String'];
};


export type StixDomainObjectEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixDomainObjectEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixDomainObjectEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixDomainObjectEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixDomainObjectEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
  noTriggerImport?: InputMaybe<Scalars['Boolean']>;
};


export type StixDomainObjectEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixDomainObjectEditMutationsRelationDeleteArgs = {
  relationship_type?: InputMaybe<Scalars['String']>;
  toId: Scalars['StixRef'];
};


export type StixDomainObjectEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};

export enum StixDomainObjectsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Context = 'context',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  Indicates = 'indicates',
  IndicatorTypes = 'indicator_types',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContains = 'objectContains',
  PatternType = 'pattern_type',
  Published = 'published',
  ReportTypes = 'report_types',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XMitreId = 'x_mitre_id',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiMainObservableType = 'x_opencti_main_observable_type',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixDomainObjectsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixDomainObjectsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixDomainObjectsOrdering {
  Score = '_score',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  IndicatorPattern = 'indicator_pattern',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixEditMutations = {
  __typename?: 'StixEditMutations';
  delete?: Maybe<Scalars['ID']>;
  merge?: Maybe<StixObject>;
};


export type StixEditMutationsMergeArgs = {
  stixObjectsIds: Array<InputMaybe<Scalars['String']>>;
};

export type StixFile = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'StixFile';
  atime?: Maybe<Scalars['DateTime']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  ctime?: Maybe<Scalars['DateTime']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  magic_number_hex?: Maybe<Scalars['String']>;
  mime_type?: Maybe<Scalars['String']>;
  mtime?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  name_enc?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  obsContent?: Maybe<Artifact>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  size?: Maybe<Scalars['Int']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_additional_names?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixFileCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixFileExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFilePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixFileStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixFileStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixFileStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixFileAddInput = {
  atime?: InputMaybe<Scalars['DateTime']>;
  ctime?: InputMaybe<Scalars['DateTime']>;
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  magic_number_hex?: InputMaybe<Scalars['String']>;
  mime_type?: InputMaybe<Scalars['String']>;
  mtime?: InputMaybe<Scalars['DateTime']>;
  name?: InputMaybe<Scalars['String']>;
  name_enc?: InputMaybe<Scalars['String']>;
  obsContent?: InputMaybe<Scalars['ID']>;
  size?: InputMaybe<Scalars['Int']>;
  x_opencti_additional_names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixFileConnection = {
  __typename?: 'StixFileConnection';
  edges?: Maybe<Array<Maybe<StixFileEdge>>>;
  pageInfo: PageInfo;
};

export type StixFileEdge = {
  __typename?: 'StixFileEdge';
  cursor: Scalars['String'];
  node: StixFile;
};

export type StixMetaObject = {
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type StixMetaRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixMetaRelationship';
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type StixMetaRelationshipAddInput = {
  fromId?: InputMaybe<Scalars['ID']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['ID']>;
};

export type StixMetaRelationshipConnection = {
  __typename?: 'StixMetaRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixMetaRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixMetaRelationshipEdge = {
  __typename?: 'StixMetaRelationshipEdge';
  cursor: Scalars['String'];
  node: StixMetaRelationship;
};

export type StixMetaRelationshipsAddInput = {
  fromIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  relationship_type: Scalars['String'];
  toIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export enum StixMetaRelationshipsFilter {
  CreatedAt = 'created_at'
}

export type StixMetaRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixMetaRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixMetaRelationshipsOrdering {
  CreatedAt = 'created_at',
  UpdatedAt = 'updated_at'
}

export type StixObject = {
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type StixObjectOrStixRelationship = AdministrativeArea | Artifact | AttackPattern | AutonomousSystem | BankAccount | Campaign | Case | Channel | City | Country | CourseOfAction | CryptocurrencyWallet | CryptographicKey | DataComponent | DataSource | Directory | DomainName | EmailAddr | EmailMessage | EmailMimePartType | EntitySetting | Event | ExternalReference | Grouping | Hostname | IPv4Addr | IPv6Addr | Incident | Indicator | Individual | Infrastructure | IntrusionSet | KillChainPhase | Label | Language | MacAddr | Malware | MarkingDefinition | MediaContent | Mutex | Narrative | NetworkTraffic | Note | ObservedData | Opinion | Organization | PaymentCard | PhoneNumber | Position | Process | Region | Report | Sector | Software | StixCoreRelationship | StixCyberObservableRelationship | StixFile | StixMetaRelationship | StixSightingRelationship | System | Text | ThreatActor | Tool | Url | UserAccount | UserAgent | Vulnerability | WindowsRegistryKey | WindowsRegistryValueType | X509Certificate;

export type StixObjectOrStixRelationshipConnection = {
  __typename?: 'StixObjectOrStixRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixObjectOrStixRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixObjectOrStixRelationshipEdge = {
  __typename?: 'StixObjectOrStixRelationshipEdge';
  cursor: Scalars['String'];
  node: StixObjectOrStixRelationship;
};

export type StixObjectOrStixRelationshipRefConnection = {
  __typename?: 'StixObjectOrStixRelationshipRefConnection';
  edges?: Maybe<Array<Maybe<StixObjectOrStixRelationshipRefEdge>>>;
  pageInfo: PageInfo;
};

export type StixObjectOrStixRelationshipRefEdge = {
  __typename?: 'StixObjectOrStixRelationshipRefEdge';
  cursor: Scalars['String'];
  node: StixObjectOrStixRelationship;
  types: Array<Maybe<Scalars['String']>>;
};

export enum StixObjectOrStixRelationshipsFilter {
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  HashesMd5 = 'hashes_MD5',
  HashesSha1 = 'hashes_SHA1',
  HashesSha256 = 'hashes_SHA256',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContained = 'objectContained',
  RelatedTo = 'relatedTo',
  RelationshipType = 'relationship_type',
  SightedBy = 'sightedBy',
  UpdatedAt = 'updated_at',
  Value = 'value',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiScore = 'x_opencti_score'
}

export type StixObjectOrStixRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixObjectOrStixRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum StixObjectOrStixRelationshipsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  EntityType = 'entity_type',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  ObservableValue = 'observable_value',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  UpdatedAt = 'updated_at'
}

export type StixRelationship = {
  creator?: Maybe<Creator>;
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type StixRelationshipConnection = {
  __typename?: 'StixRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixRelationshipEdge = {
  __typename?: 'StixRelationshipEdge';
  cursor: Scalars['String'];
  node: StixRelationship;
};

export type StixRelationshipEditMutations = {
  __typename?: 'StixRelationshipEditMutations';
  delete?: Maybe<Scalars['ID']>;
};

export enum StixRelationshipsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ToCreatedAt = 'toCreatedAt',
  ToMainObservableType = 'toMainObservableType',
  ToName = 'toName',
  ToPatternType = 'toPatternType'
}

export type StixRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  KillChainPhase = 'killChainPhase',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StopTime = 'stop_time',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at'
}

export type StixSightingRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixSightingRelationship';
  attribute_count: Scalars['Int'];
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_negative: Scalars['Boolean'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type StixSightingRelationshipCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type StixSightingRelationshipAddInput = {
  attribute_count: Scalars['Int'];
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  fromId: Scalars['StixRef'];
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  toId: Scalars['StixRef'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_negative?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type StixSightingRelationshipConnection = {
  __typename?: 'StixSightingRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixSightingRelationshipsEdge>>>;
  pageInfo: PageInfo;
};

export type StixSightingRelationshipEditMutations = {
  __typename?: 'StixSightingRelationshipEditMutations';
  contextClean?: Maybe<StixSightingRelationship>;
  contextPatch?: Maybe<StixSightingRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixSightingRelationship>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixSightingRelationship>;
  restrictionOrganizationAdd?: Maybe<StixSightingRelationship>;
  restrictionOrganizationDelete?: Maybe<StixSightingRelationship>;
};


export type StixSightingRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixSightingRelationshipEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixSightingRelationshipEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixSightingRelationshipEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type StixSightingRelationshipEditMutationsRestrictionOrganizationAddArgs = {
  organizationId: Scalars['ID'];
};


export type StixSightingRelationshipEditMutationsRestrictionOrganizationDeleteArgs = {
  organizationId: Scalars['ID'];
};

export type StixSightingRelationshipsEdge = {
  __typename?: 'StixSightingRelationshipsEdge';
  cursor: Scalars['String'];
  node: StixSightingRelationship;
};

export enum StixSightingRelationshipsFilter {
  AttributeCount = 'attribute_count',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FromId = 'fromId',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ToId = 'toId',
  ToMainObservableType = 'toMainObservableType',
  ToPatternType = 'toPatternType',
  XOpenctiNegative = 'x_opencti_negative',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StixSightingRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<StixSightingRelationshipsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixSightingRelationshipsOrdering {
  AttributeCount = 'attribute_count',
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  ToCreatedAt = 'toCreatedAt',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at',
  XOpenctiNegative = 'x_opencti_negative',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type StreamCollection = {
  __typename?: 'StreamCollection';
  description?: Maybe<Scalars['String']>;
  filters?: Maybe<Scalars['String']>;
  groups?: Maybe<Array<Maybe<Group>>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type StreamCollectionAddInput = {
  description?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<Scalars['String']>;
  groups?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name: Scalars['String'];
};

export type StreamCollectionConnection = {
  __typename?: 'StreamCollectionConnection';
  edges?: Maybe<Array<Maybe<StreamCollectionEdge>>>;
  pageInfo: PageInfo;
};

export type StreamCollectionEdge = {
  __typename?: 'StreamCollectionEdge';
  cursor: Scalars['String'];
  node: StreamCollection;
};

export type StreamCollectionEditMutations = {
  __typename?: 'StreamCollectionEditMutations';
  addGroup?: Maybe<StreamCollection>;
  delete?: Maybe<Scalars['ID']>;
  deleteGroup?: Maybe<StreamCollection>;
  fieldPatch?: Maybe<StreamCollection>;
};


export type StreamCollectionEditMutationsAddGroupArgs = {
  id: Scalars['ID'];
};


export type StreamCollectionEditMutationsDeleteGroupArgs = {
  id: Scalars['ID'];
};


export type StreamCollectionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum StreamCollectionOrdering {
  Description = 'description',
  Name = 'name'
}

export type SubType = {
  __typename?: 'SubType';
  id: Scalars['ID'];
  label: Scalars['String'];
  settings?: Maybe<EntitySetting>;
  statuses?: Maybe<StatusConnection>;
  workflowEnabled?: Maybe<Scalars['Boolean']>;
};

export type SubTypeConnection = {
  __typename?: 'SubTypeConnection';
  edges: Array<SubTypeEdge>;
  pageInfo: PageInfo;
};

export type SubTypeEdge = {
  __typename?: 'SubTypeEdge';
  cursor: Scalars['String'];
  node: SubType;
};

export type SubTypeEditMutations = {
  __typename?: 'SubTypeEditMutations';
  statusAdd?: Maybe<SubType>;
  statusDelete?: Maybe<SubType>;
  statusFieldPatch?: Maybe<SubType>;
};


export type SubTypeEditMutationsStatusAddArgs = {
  input?: InputMaybe<StatusAddInput>;
};


export type SubTypeEditMutationsStatusDeleteArgs = {
  statusId: Scalars['String'];
};


export type SubTypeEditMutationsStatusFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
  statusId: Scalars['String'];
};

export enum SubTypesOrdering {
  Label = 'label'
}

export type Subscription = {
  __typename?: 'Subscription';
  externalReference?: Maybe<ExternalReference>;
  group?: Maybe<Group>;
  killChainPhase?: Maybe<KillChainPhase>;
  label?: Maybe<Label>;
  markingDefinition?: Maybe<MarkingDefinition>;
  settings?: Maybe<Settings>;
  statusTemplate?: Maybe<StatusTemplate>;
  stixCoreObject?: Maybe<StixCoreObject>;
  stixCoreRelationship?: Maybe<StixCoreRelationship>;
  stixCyberObservable?: Maybe<StixCyberObservable>;
  stixCyberObservableRelationship?: Maybe<StixCyberObservableRelationship>;
  stixDomainObject?: Maybe<StixDomainObject>;
  stixSightingRelationship?: Maybe<StixSightingRelationship>;
  user?: Maybe<User>;
  workspace?: Maybe<Workspace>;
};


export type SubscriptionExternalReferenceArgs = {
  id: Scalars['ID'];
};


export type SubscriptionGroupArgs = {
  id: Scalars['ID'];
};


export type SubscriptionKillChainPhaseArgs = {
  id: Scalars['ID'];
};


export type SubscriptionLabelArgs = {
  id: Scalars['ID'];
};


export type SubscriptionMarkingDefinitionArgs = {
  id: Scalars['ID'];
};


export type SubscriptionSettingsArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStatusTemplateArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCoreObjectArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCoreRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCyberObservableArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCyberObservableRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixDomainObjectArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixSightingRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionUserArgs = {
  id: Scalars['ID'];
};


export type SubscriptionWorkspaceArgs = {
  id: Scalars['ID'];
};

export type Synchronizer = {
  __typename?: 'Synchronizer';
  current_state?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  listen_deletion: Scalars['Boolean'];
  name: Scalars['String'];
  no_dependencies: Scalars['Boolean'];
  running: Scalars['Boolean'];
  ssl_verify?: Maybe<Scalars['Boolean']>;
  stream_id: Scalars['String'];
  token: Scalars['String'];
  uri: Scalars['String'];
  user?: Maybe<User>;
};

export type SynchronizerAddInput = {
  current_state?: InputMaybe<Scalars['DateTime']>;
  listen_deletion: Scalars['Boolean'];
  name: Scalars['String'];
  no_dependencies: Scalars['Boolean'];
  recover?: InputMaybe<Scalars['DateTime']>;
  ssl_verify?: InputMaybe<Scalars['Boolean']>;
  stream_id: Scalars['String'];
  token: Scalars['String'];
  uri: Scalars['String'];
  user_id?: InputMaybe<Scalars['String']>;
};

export type SynchronizerConnection = {
  __typename?: 'SynchronizerConnection';
  edges?: Maybe<Array<Maybe<SynchronizerEdge>>>;
  pageInfo: PageInfo;
};

export type SynchronizerEdge = {
  __typename?: 'SynchronizerEdge';
  cursor: Scalars['String'];
  node: Synchronizer;
};

export type SynchronizerEditMutations = {
  __typename?: 'SynchronizerEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Synchronizer>;
};


export type SynchronizerEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum SynchronizersOrdering {
  CurrentState = 'current_state',
  Id = 'id',
  Name = 'name',
  Running = 'running',
  StreamId = 'stream_id',
  Uri = 'uri'
}

export type System = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'System';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  organizations?: Maybe<OrganizationConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_firstname?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_lastname?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type SystemCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SystemExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SystemStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SystemStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SystemAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_firstname?: InputMaybe<Scalars['String']>;
  x_opencti_lastname?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type SystemConnection = {
  __typename?: 'SystemConnection';
  edges?: Maybe<Array<Maybe<SystemEdge>>>;
  pageInfo: PageInfo;
};

export type SystemEdge = {
  __typename?: 'SystemEdge';
  cursor: Scalars['String'];
  node: System;
};

export type SystemEditMutations = {
  __typename?: 'SystemEditMutations';
  contextClean?: Maybe<System>;
  contextPatch?: Maybe<System>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<System>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<System>;
};


export type SystemEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SystemEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SystemEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type SystemEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum SystemsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type SystemsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<SystemsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum SystemsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Firstname = 'firstname',
  Lastname = 'lastname',
  Modified = 'modified',
  Name = 'name',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Task = {
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<Creator>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type TaskAction = {
  __typename?: 'TaskAction';
  context?: Maybe<TaskContext>;
  type?: Maybe<TaskActionType>;
};

export type TaskActionInput = {
  context?: InputMaybe<TaskContextInput>;
  type: TaskActionType;
};

export enum TaskActionType {
  Add = 'ADD',
  Delete = 'DELETE',
  Enrichment = 'ENRICHMENT',
  Merge = 'MERGE',
  Promote = 'PROMOTE',
  Remove = 'REMOVE',
  Replace = 'REPLACE',
  RuleElementRescan = 'RULE_ELEMENT_RESCAN',
  Share = 'SHARE',
  Unshare = 'UNSHARE'
}

export type TaskConnection = {
  __typename?: 'TaskConnection';
  edges?: Maybe<Array<Maybe<TaskConnectionEdge>>>;
  pageInfo: PageInfo;
};

export type TaskConnectionEdge = {
  __typename?: 'TaskConnectionEdge';
  cursor: Scalars['String'];
  node: Task;
};

export type TaskContext = {
  __typename?: 'TaskContext';
  field?: Maybe<Scalars['String']>;
  type?: Maybe<TaskContextType>;
  values: Array<Maybe<Scalars['String']>>;
};

export type TaskContextInput = {
  field?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<TaskContextType>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum TaskContextType {
  Attribute = 'ATTRIBUTE',
  Relation = 'RELATION',
  ReversedRelation = 'REVERSED_RELATION'
}

export type TaskError = {
  __typename?: 'TaskError';
  id: Scalars['ID'];
  message?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export enum TaskType {
  List = 'LIST',
  Query = 'QUERY',
  Rule = 'RULE'
}

export enum TasksFilter {
  Completed = 'completed',
  Initiator = 'initiator',
  Type = 'type'
}

export type TasksFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<TasksFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum TasksOrdering {
  Completed = 'completed',
  CreatedAt = 'created_at',
  Id = 'id',
  LastExecutionDate = 'last_execution_date',
  Type = 'type'
}

export type TaxiiCollection = {
  __typename?: 'TaxiiCollection';
  description?: Maybe<Scalars['String']>;
  filters?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type TaxiiCollectionAddInput = {
  description?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type TaxiiCollectionConnection = {
  __typename?: 'TaxiiCollectionConnection';
  edges?: Maybe<Array<Maybe<TaxiiCollectionEdge>>>;
  pageInfo: PageInfo;
};

export type TaxiiCollectionEdge = {
  __typename?: 'TaxiiCollectionEdge';
  cursor: Scalars['String'];
  node: TaxiiCollection;
};

export type TaxiiCollectionEditMutations = {
  __typename?: 'TaxiiCollectionEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<TaxiiCollection>;
};


export type TaxiiCollectionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum TaxiiCollectionOrdering {
  Description = 'description',
  Name = 'name'
}

export type Text = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Text';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type TextCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type TextExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type TextStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type TextStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type TextStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type TextAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type ThreatActor = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'ThreatActor';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  countries?: Maybe<CountryConnection>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  goals?: Maybe<Array<Maybe<Scalars['String']>>>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  locations?: Maybe<LocationConnection>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  personal_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  primary_motivation?: Maybe<Scalars['String']>;
  reports?: Maybe<ReportConnection>;
  resource_level?: Maybe<Scalars['String']>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  secondary_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  sophistication?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  threat_actor_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ThreatActorCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ThreatActorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ThreatActorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ThreatActorStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ThreatActorAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  goals?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectAssignee?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectOrganization?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  personal_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  primary_motivation?: InputMaybe<Scalars['String']>;
  resource_level?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  secondary_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sophistication?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  threat_actor_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ThreatActorConnection = {
  __typename?: 'ThreatActorConnection';
  edges?: Maybe<Array<Maybe<ThreatActorEdge>>>;
  pageInfo: PageInfo;
};

export type ThreatActorEdge = {
  __typename?: 'ThreatActorEdge';
  cursor: Scalars['String'];
  node: ThreatActor;
};

export type ThreatActorEditMutations = {
  __typename?: 'ThreatActorEditMutations';
  contextClean?: Maybe<ThreatActor>;
  contextPatch?: Maybe<ThreatActor>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ThreatActor>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ThreatActor>;
};


export type ThreatActorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ThreatActorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ThreatActorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ThreatActorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum ThreatActorsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ThreatActorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ThreatActorsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ThreatActorsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type TimeSeries = {
  __typename?: 'TimeSeries';
  date: Scalars['DateTime'];
  value: Scalars['Int'];
};

export type Tool = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Tool';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  tool_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  tool_version?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type ToolCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ToolExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ToolStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ToolStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ToolAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  tool_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  tool_version?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type ToolConnection = {
  __typename?: 'ToolConnection';
  edges?: Maybe<Array<Maybe<ToolEdge>>>;
  pageInfo: PageInfo;
};

export type ToolEdge = {
  __typename?: 'ToolEdge';
  cursor: Scalars['String'];
  node: Tool;
};

export type ToolEditMutations = {
  __typename?: 'ToolEditMutations';
  contextClean?: Maybe<Tool>;
  contextPatch?: Maybe<Tool>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Tool>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Tool>;
};


export type ToolEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ToolEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ToolEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ToolEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export enum ToolsFilter {
  Aliases = 'aliases',
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type ToolsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<ToolsFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ToolsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Url = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Url';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type UrlCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UrlExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UrlStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UrlStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UrlStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UrlAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type User = BasicObject & InternalObject & {
  __typename?: 'User';
  allowed_marking?: Maybe<Array<Maybe<MarkingDefinition>>>;
  api_token: Scalars['String'];
  capabilities: Array<Maybe<Capability>>;
  created_at: Scalars['DateTime'];
  dashboard?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  external?: Maybe<Scalars['Boolean']>;
  firstname?: Maybe<Scalars['String']>;
  groups?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  individual_id?: Maybe<Scalars['String']>;
  language?: Maybe<Scalars['String']>;
  lastname?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  objectOrganization?: Maybe<OrganizationConnection>;
  otp_activated?: Maybe<Scalars['Boolean']>;
  otp_mandatory?: Maybe<Scalars['Boolean']>;
  otp_qr?: Maybe<Scalars['String']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  roles: Array<Maybe<Role>>;
  sessions?: Maybe<Array<Maybe<SessionDetail>>>;
  standard_id: Scalars['String'];
  theme?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  userSubscriptions?: Maybe<UserSubscriptionConnection>;
  user_email: Scalars['String'];
};


export type UserUserSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type UserAccount = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'UserAccount';
  account_created?: Maybe<Scalars['DateTime']>;
  account_expires?: Maybe<Scalars['DateTime']>;
  account_first_login?: Maybe<Scalars['DateTime']>;
  account_last_login?: Maybe<Scalars['DateTime']>;
  account_login?: Maybe<Scalars['String']>;
  account_type?: Maybe<Scalars['String']>;
  can_escalate_privs?: Maybe<Scalars['Boolean']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  credential?: Maybe<Scalars['String']>;
  credential_last_changed?: Maybe<Scalars['DateTime']>;
  display_name?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_disabled?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  is_privileged?: Maybe<Scalars['Boolean']>;
  is_service_account?: Maybe<Scalars['Boolean']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  user_id?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type UserAccountCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UserAccountExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAccountStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAccountStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAccountStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserAccountAddInput = {
  account_created?: InputMaybe<Scalars['DateTime']>;
  account_expires?: InputMaybe<Scalars['DateTime']>;
  account_first_login?: InputMaybe<Scalars['DateTime']>;
  account_last_login?: InputMaybe<Scalars['DateTime']>;
  account_login?: InputMaybe<Scalars['String']>;
  account_type?: InputMaybe<Scalars['String']>;
  can_escalate_privs?: InputMaybe<Scalars['Boolean']>;
  credential?: InputMaybe<Scalars['String']>;
  credential_last_changed?: InputMaybe<Scalars['DateTime']>;
  display_name?: InputMaybe<Scalars['String']>;
  is_disabled?: InputMaybe<Scalars['Boolean']>;
  is_privileged?: InputMaybe<Scalars['Boolean']>;
  is_service_account?: InputMaybe<Scalars['Boolean']>;
  user_id?: InputMaybe<Scalars['String']>;
};

export type UserAddInput = {
  description?: InputMaybe<Scalars['String']>;
  firstname?: InputMaybe<Scalars['String']>;
  language?: InputMaybe<Scalars['String']>;
  lastname?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  objectOrganization?: InputMaybe<Array<Scalars['ID']>>;
  password?: InputMaybe<Scalars['String']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  theme?: InputMaybe<Scalars['String']>;
  user_email?: InputMaybe<Scalars['String']>;
};

export type UserAgent = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'UserAgent';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type UserAgentCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UserAgentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAgentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAgentStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAgentStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserAgentAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['String'];
  node: User;
};

export type UserEditMutations = {
  __typename?: 'UserEditMutations';
  contextClean?: Maybe<User>;
  contextPatch?: Maybe<User>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<User>;
  organizationAdd?: Maybe<User>;
  organizationDelete?: Maybe<User>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<User>;
  tokenRenew?: Maybe<User>;
};


export type UserEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type UserEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type UserEditMutationsOrganizationAddArgs = {
  organizationId: Scalars['ID'];
};


export type UserEditMutationsOrganizationDeleteArgs = {
  organizationId: Scalars['ID'];
};


export type UserEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type UserEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type UserLoginInput = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type UserOtpActivationInput = {
  code: Scalars['String'];
  secret: Scalars['String'];
};

export type UserOtpLoginInput = {
  code: Scalars['String'];
};

export type UserSession = {
  __typename?: 'UserSession';
  sessions?: Maybe<Array<Maybe<SessionDetail>>>;
  user?: Maybe<User>;
};

export type UserSubscription = {
  __typename?: 'UserSubscription';
  cron?: Maybe<Scalars['String']>;
  entities?: Maybe<Array<Maybe<StixDomainObject>>>;
  entities_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
  filters?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  last_run: Scalars['DateTime'];
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Array<Maybe<Scalars['String']>>>;
  user?: Maybe<User>;
  user_id?: Maybe<Scalars['String']>;
};

export type UserSubscriptionAddInput = {
  cron?: InputMaybe<Scalars['String']>;
  entities_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  filters?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  options?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserSubscriptionConnection = {
  __typename?: 'UserSubscriptionConnection';
  edges?: Maybe<Array<Maybe<UserSubscriptionEdge>>>;
  pageInfo: PageInfo;
};

export type UserSubscriptionEdge = {
  __typename?: 'UserSubscriptionEdge';
  cursor: Scalars['String'];
  node: UserSubscription;
};

export type UserSubscriptionEditMutations = {
  __typename?: 'UserSubscriptionEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<UserSubscription>;
};


export type UserSubscriptionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum UserSubscriptionOrdering {
  CreatedAt = 'created_at'
}

export enum UsersFilter {
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  Name = 'name'
}

export type UsersFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<UsersFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum UsersOrdering {
  CreatedAt = 'created_at',
  External = 'external',
  Firstname = 'firstname',
  Language = 'language',
  Lastname = 'lastname',
  Name = 'name',
  UpdatedAt = 'updated_at',
  UserEmail = 'user_email'
}

export type Vocabulary = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'Vocabulary';
  aliases?: Maybe<Array<Scalars['String']>>;
  builtIn?: Maybe<Scalars['Boolean']>;
  category: VocabularyDefinition;
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  usages: Array<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};

export type VocabularyAddInput = {
  aliases?: InputMaybe<Array<Scalars['String']>>;
  category: VocabularyCategory;
  created?: InputMaybe<Scalars['DateTime']>;
  description?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export enum VocabularyCategory {
  AccountTypeOv = 'account_type_ov',
  AttackMotivationOv = 'attack_motivation_ov',
  AttackResourceLevelOv = 'attack_resource_level_ov',
  CasePriorityOv = 'case_priority_ov',
  CaseSeverityOv = 'case_severity_ov',
  CaseTypesOv = 'case_types_ov',
  ChannelTypesOv = 'channel_types_ov',
  CollectionLayersOv = 'collection_layers_ov',
  EventTypeOv = 'event_type_ov',
  GroupingContextOv = 'grouping_context_ov',
  ImplementationLanguageOv = 'implementation_language_ov',
  IncidentSeverityOv = 'incident_severity_ov',
  IncidentTypeOv = 'incident_type_ov',
  IndicatorTypeOv = 'indicator_type_ov',
  InfrastructureTypeOv = 'infrastructure_type_ov',
  IntegrityLevelOv = 'integrity_level_ov',
  MalwareCapabilitiesOv = 'malware_capabilities_ov',
  MalwareTypeOv = 'malware_type_ov',
  NoteTypesOv = 'note_types_ov',
  OpinionOv = 'opinion_ov',
  PatternTypeOv = 'pattern_type_ov',
  PermissionsOv = 'permissions_ov',
  PlatformsOv = 'platforms_ov',
  ProcessorArchitectureOv = 'processor_architecture_ov',
  ReportTypesOv = 'report_types_ov',
  ServiceStatusOv = 'service_status_ov',
  ServiceTypeOv = 'service_type_ov',
  StartTypeOv = 'start_type_ov',
  ThreatActorRoleOv = 'threat_actor_role_ov',
  ThreatActorSophisticationOv = 'threat_actor_sophistication_ov',
  ThreatActorTypeOv = 'threat_actor_type_ov',
  ToolTypesOv = 'tool_types_ov'
}

export type VocabularyConnection = {
  __typename?: 'VocabularyConnection';
  edges: Array<VocabularyEdge>;
  pageInfo: PageInfo;
};

export type VocabularyDefinition = {
  __typename?: 'VocabularyDefinition';
  description?: Maybe<Scalars['String']>;
  entity_types: Array<Scalars['String']>;
  fields: Array<VocabularyFieldDefinition>;
  key: VocabularyCategory;
};

export type VocabularyEdge = {
  __typename?: 'VocabularyEdge';
  cursor: Scalars['String'];
  node: Vocabulary;
};

export type VocabularyFieldDefinition = {
  __typename?: 'VocabularyFieldDefinition';
  key: Scalars['String'];
  multiple: Scalars['Boolean'];
  required: Scalars['Boolean'];
};

export enum VocabularyFilter {
  Aliases = 'aliases',
  Category = 'category',
  Description = 'description',
  EntityTypes = 'entity_types',
  Name = 'name'
}

export type VocabularyFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<VocabularyFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<Scalars['String']>;
};

export enum VocabularyOrdering {
  Category = 'category',
  Description = 'description',
  Name = 'name'
}

export enum VulnerabilitiesFilter {
  AssigneeTo = 'assigneeTo',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Creator = 'creator',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiAttackVector = 'x_opencti_attack_vector',
  XOpenctiBaseScore = 'x_opencti_base_score',
  XOpenctiBaseSeverity = 'x_opencti_base_severity',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type VulnerabilitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<VulnerabilitiesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum VulnerabilitiesOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Creator = 'creator',
  Modified = 'modified',
  Name = 'name',
  UpdatedAt = 'updated_at',
  XOpenctiAttackVector = 'x_opencti_attack_vector',
  XOpenctiBaseScore = 'x_opencti_base_score',
  XOpenctiBaseSeverity = 'x_opencti_base_severity',
  XOpenctiWorkflowId = 'x_opencti_workflow_id'
}

export type Vulnerability = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Vulnerability';
  cases?: Maybe<CaseConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectAssignee?: Maybe<AssigneeConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  softwares?: Maybe<StixCyberObservableConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_attack_vector?: Maybe<Scalars['String']>;
  x_opencti_availability_impact?: Maybe<Scalars['String']>;
  x_opencti_base_score?: Maybe<Scalars['Float']>;
  x_opencti_base_severity?: Maybe<Scalars['String']>;
  x_opencti_confidentiality_impact?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_integrity_impact?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type VulnerabilityCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type VulnerabilityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type VulnerabilityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type VulnerabilityStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type VulnerabilityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['StixId']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_attack_vector?: InputMaybe<Scalars['String']>;
  x_opencti_availability_impact?: InputMaybe<Scalars['String']>;
  x_opencti_base_score?: InputMaybe<Scalars['Float']>;
  x_opencti_base_severity?: InputMaybe<Scalars['String']>;
  x_opencti_confidentiality_impact?: InputMaybe<Scalars['String']>;
  x_opencti_integrity_impact?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['StixId']>>>;
};

export type VulnerabilityConnection = {
  __typename?: 'VulnerabilityConnection';
  edges?: Maybe<Array<Maybe<VulnerabilityEdge>>>;
  pageInfo: PageInfo;
};

export type VulnerabilityEdge = {
  __typename?: 'VulnerabilityEdge';
  cursor: Scalars['String'];
  node: Vulnerability;
};

export type VulnerabilityEditMutations = {
  __typename?: 'VulnerabilityEditMutations';
  contextClean?: Maybe<Vulnerability>;
  contextPatch?: Maybe<Vulnerability>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Vulnerability>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Vulnerability>;
};


export type VulnerabilityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type VulnerabilityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type VulnerabilityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type VulnerabilityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};

export type WindowsRegistryKey = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'WindowsRegistryKey';
  attribute_key?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  modified_time?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  number_of_subkeys?: Maybe<Scalars['Int']>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type WindowsRegistryKeyCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type WindowsRegistryKeyExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryKeyStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryKeyStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryKeyStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WindowsRegistryKeyAddInput = {
  attribute_key?: InputMaybe<Scalars['String']>;
  modified_time?: InputMaybe<Scalars['DateTime']>;
  number_of_subkeys?: InputMaybe<Scalars['Int']>;
};

export type WindowsRegistryValueType = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'WindowsRegistryValueType';
  cases?: Maybe<CaseConnection>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  data?: Maybe<Scalars['String']>;
  data_type?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type WindowsRegistryValueTypeCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type WindowsRegistryValueTypeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryValueTypeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryValueTypeStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryValueTypeStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WindowsRegistryValueTypeAddInput = {
  data?: InputMaybe<Scalars['String']>;
  data_type?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type Work = {
  __typename?: 'Work';
  completed_number?: Maybe<Scalars['Int']>;
  completed_time?: Maybe<Scalars['DateTime']>;
  connector?: Maybe<Connector>;
  errors?: Maybe<Array<Maybe<WorkMessage>>>;
  event_source_id?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  messages?: Maybe<Array<Maybe<WorkMessage>>>;
  name?: Maybe<Scalars['String']>;
  processed_time?: Maybe<Scalars['DateTime']>;
  received_time?: Maybe<Scalars['DateTime']>;
  status: State;
  timestamp: Scalars['DateTime'];
  tracking?: Maybe<WorkTracking>;
  user?: Maybe<User>;
};

export type WorkConnection = {
  __typename?: 'WorkConnection';
  edges?: Maybe<Array<Maybe<WorkEdge>>>;
  pageInfo: PageInfo;
};

export type WorkEdge = {
  __typename?: 'WorkEdge';
  cursor: Scalars['String'];
  node: Work;
};

export type WorkEditMutations = {
  __typename?: 'WorkEditMutations';
  addExpectations: Scalars['ID'];
  delete: Scalars['ID'];
  ping: Scalars['ID'];
  reportExpectation: Scalars['ID'];
  toProcessed: Scalars['ID'];
  toReceived: Scalars['ID'];
};


export type WorkEditMutationsAddExpectationsArgs = {
  expectations?: InputMaybe<Scalars['Int']>;
};


export type WorkEditMutationsReportExpectationArgs = {
  error?: InputMaybe<WorkErrorInput>;
};


export type WorkEditMutationsToProcessedArgs = {
  inError?: InputMaybe<Scalars['Boolean']>;
  message?: InputMaybe<Scalars['String']>;
};


export type WorkEditMutationsToReceivedArgs = {
  message?: InputMaybe<Scalars['String']>;
};

export type WorkErrorInput = {
  error?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

export type WorkMessage = {
  __typename?: 'WorkMessage';
  message?: Maybe<Scalars['String']>;
  sequence?: Maybe<Scalars['Int']>;
  source?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export type WorkTracking = {
  __typename?: 'WorkTracking';
  import_expected_number?: Maybe<Scalars['Int']>;
  import_last_processed?: Maybe<Scalars['DateTime']>;
  import_processed_number?: Maybe<Scalars['Int']>;
};

export enum WorksFilter {
  CompletedNumber = 'completed_number',
  CompletedTime = 'completed_time',
  ConnectorId = 'connector_id',
  ProcessedTime = 'processed_time',
  ReceivedTime = 'received_time',
  Status = 'status'
}

export type WorksFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<WorksFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum WorksOrdering {
  Status = 'status',
  Timestamp = 'timestamp'
}

export type Workspace = {
  __typename?: 'Workspace';
  created_at?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  graph_data?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  manifest?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  objects?: Maybe<StixObjectOrStixRelationshipRefConnection>;
  owner?: Maybe<User>;
  tags?: Maybe<Array<Maybe<Scalars['String']>>>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['DateTime']>;
};


export type WorkspaceObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WorkspaceAddInput = {
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type: Scalars['String'];
};

export type WorkspaceConnection = {
  __typename?: 'WorkspaceConnection';
  edges?: Maybe<Array<Maybe<WorkspaceEdge>>>;
  pageInfo: PageInfo;
};

export type WorkspaceEdge = {
  __typename?: 'WorkspaceEdge';
  cursor: Scalars['String'];
  node: Workspace;
};

export type WorkspaceEditMutations = {
  __typename?: 'WorkspaceEditMutations';
  contextClean?: Maybe<Workspace>;
  contextPatch?: Maybe<Workspace>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Workspace>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Workspace>;
  relationsAdd?: Maybe<Workspace>;
  relationsDelete?: Maybe<Workspace>;
};


export type WorkspaceEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type WorkspaceEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type WorkspaceEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type WorkspaceEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['StixRef'];
};


export type WorkspaceEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};


export type WorkspaceEditMutationsRelationsDeleteArgs = {
  relationship_type: Scalars['String'];
  toIds: Array<InputMaybe<Scalars['String']>>;
};

export enum WorkspacesFilter {
  Name = 'name',
  Owner = 'owner',
  Tag = 'tag',
  Type = 'type'
}

export type WorkspacesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: Array<WorkspacesFilter>;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum WorkspacesOrdering {
  CreatedAt = 'created_at',
  Name = 'name',
  OwnedBy = 'ownedBy',
  UpdatedAt = 'updated_at'
}

export type X509Certificate = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'X509Certificate';
  authority_key_identifier?: Maybe<Scalars['String']>;
  basic_constraints?: Maybe<Scalars['String']>;
  cases?: Maybe<CaseConnection>;
  certificate_policies?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<Creator>;
  crl_distribution_points?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<EditUserContext>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extended_key_usage?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  groupings?: Maybe<GroupingConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  inhibit_any_policy?: Maybe<Scalars['String']>;
  is_inferred: Scalars['Boolean'];
  is_self_signed?: Maybe<Scalars['Boolean']>;
  issuer?: Maybe<Scalars['String']>;
  issuer_alternative_name?: Maybe<Scalars['String']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  key_usage?: Maybe<Scalars['String']>;
  name_constraints?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objectOrganization?: Maybe<OrganizationConnection>;
  observable_value: Scalars['String'];
  observedData?: Maybe<ObservedDataConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  policy_constraints?: Maybe<Scalars['String']>;
  policy_mappings?: Maybe<Scalars['String']>;
  private_key_usage_period_not_after?: Maybe<Scalars['DateTime']>;
  private_key_usage_period_not_before?: Maybe<Scalars['DateTime']>;
  reports?: Maybe<ReportConnection>;
  serial_number?: Maybe<Scalars['String']>;
  signature_algorithm?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  subject?: Maybe<Scalars['String']>;
  subject_alternative_name?: Maybe<Scalars['String']>;
  subject_directory_attributes?: Maybe<Scalars['String']>;
  subject_key_identifier?: Maybe<Scalars['String']>;
  subject_public_key_algorithm?: Maybe<Scalars['String']>;
  subject_public_key_exponent?: Maybe<Scalars['Int']>;
  subject_public_key_modulus?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  validity_not_after?: Maybe<Scalars['DateTime']>;
  validity_not_before?: Maybe<Scalars['DateTime']>;
  version?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['StixId']>>>;
};


export type X509CertificateCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type X509CertificateExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateGroupingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateObservedDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificatePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateStixCoreObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type X509CertificateStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type X509CertificateStixCoreRelationshipsDistributionArgs = {
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  fromId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type X509CertificateStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['StixRef']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['StixRef']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type X509CertificateAddInput = {
  authority_key_identifier?: InputMaybe<Scalars['String']>;
  basic_constraints?: InputMaybe<Scalars['String']>;
  certificate_policies?: InputMaybe<Scalars['String']>;
  crl_distribution_points?: InputMaybe<Scalars['String']>;
  extended_key_usage?: InputMaybe<Scalars['String']>;
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  inhibit_any_policy?: InputMaybe<Scalars['String']>;
  is_self_signed?: InputMaybe<Scalars['Boolean']>;
  issuer?: InputMaybe<Scalars['String']>;
  issuer_alternative_name?: InputMaybe<Scalars['String']>;
  key_usage?: InputMaybe<Scalars['String']>;
  name_constraints?: InputMaybe<Scalars['String']>;
  policy_constraints?: InputMaybe<Scalars['String']>;
  policy_mappings?: InputMaybe<Scalars['String']>;
  private_key_usage_period_not_after?: InputMaybe<Scalars['DateTime']>;
  private_key_usage_period_not_before?: InputMaybe<Scalars['DateTime']>;
  serial_number?: InputMaybe<Scalars['String']>;
  signature_algorithm?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  subject_alternative_name?: InputMaybe<Scalars['String']>;
  subject_directory_attributes?: InputMaybe<Scalars['String']>;
  subject_key_identifier?: InputMaybe<Scalars['String']>;
  subject_public_key_algorithm?: InputMaybe<Scalars['String']>;
  subject_public_key_exponent?: InputMaybe<Scalars['Int']>;
  subject_public_key_modulus?: InputMaybe<Scalars['String']>;
  validity_not_after?: InputMaybe<Scalars['DateTime']>;
  validity_not_before?: InputMaybe<Scalars['DateTime']>;
  version?: InputMaybe<Scalars['String']>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  AckDetails: ResolverTypeWrapper<AckDetails>;
  AdministrativeArea: ResolverTypeWrapper<BasicStoreEntityAdministrativeArea>;
  AdministrativeAreaAddInput: AdministrativeAreaAddInput;
  AdministrativeAreaConnection: ResolverTypeWrapper<Omit<AdministrativeAreaConnection, 'edges'> & { edges?: Maybe<Array<ResolversTypes['AdministrativeAreaEdge']>> }>;
  AdministrativeAreaEdge: ResolverTypeWrapper<Omit<AdministrativeAreaEdge, 'node'> & { node: ResolversTypes['AdministrativeArea'] }>;
  AdministrativeAreasFilter: AdministrativeAreasFilter;
  AdministrativeAreasFiltering: AdministrativeAreasFiltering;
  AdministrativeAreasOrdering: AdministrativeAreasOrdering;
  AppDebugDistribution: ResolverTypeWrapper<AppDebugDistribution>;
  AppDebugStatistics: ResolverTypeWrapper<AppDebugStatistics>;
  AppInfo: ResolverTypeWrapper<AppInfo>;
  AppMemory: ResolverTypeWrapper<AppMemory>;
  Artifact: ResolverTypeWrapper<Omit<Artifact, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  ArtifactAddInput: ArtifactAddInput;
  Assignee: ResolverTypeWrapper<Assignee>;
  AssigneeConnection: ResolverTypeWrapper<AssigneeConnection>;
  AssigneeEdge: ResolverTypeWrapper<AssigneeEdge>;
  AttackPattern: ResolverTypeWrapper<Omit<AttackPattern, 'cases' | 'connectors' | 'coursesOfAction' | 'createdBy' | 'dataComponents' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentAttackPatterns' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subAttackPatterns'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, coursesOfAction?: Maybe<ResolversTypes['CourseOfActionConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, dataComponents?: Maybe<ResolversTypes['DataComponentConnection']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, parentAttackPatterns?: Maybe<ResolversTypes['AttackPatternConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, subAttackPatterns?: Maybe<ResolversTypes['AttackPatternConnection']> }>;
  AttackPatternAddInput: AttackPatternAddInput;
  AttackPatternConnection: ResolverTypeWrapper<Omit<AttackPatternConnection, 'edges'> & { edges: Array<ResolversTypes['AttackPatternEdge']> }>;
  AttackPatternEdge: ResolverTypeWrapper<Omit<AttackPatternEdge, 'node'> & { node: ResolversTypes['AttackPattern'] }>;
  AttackPatternEditMutations: ResolverTypeWrapper<Omit<AttackPatternEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['AttackPattern']>, contextPatch?: Maybe<ResolversTypes['AttackPattern']>, fieldPatch?: Maybe<ResolversTypes['AttackPattern']>, relationDelete?: Maybe<ResolversTypes['AttackPattern']> }>;
  AttackPatternsFilter: AttackPatternsFilter;
  AttackPatternsFiltering: AttackPatternsFiltering;
  AttackPatternsOrdering: AttackPatternsOrdering;
  Attribute: ResolverTypeWrapper<Attribute>;
  AttributeConnection: ResolverTypeWrapper<AttributeConnection>;
  AttributeEdge: ResolverTypeWrapper<AttributeEdge>;
  AttributeEditMutations: ResolverTypeWrapper<AttributeEditMutations>;
  AttributesOrdering: AttributesOrdering;
  AutonomousSystem: ResolverTypeWrapper<Omit<AutonomousSystem, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  AutonomousSystemAddInput: AutonomousSystemAddInput;
  BankAccount: ResolverTypeWrapper<Omit<BankAccount, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  BankAccountAddInput: BankAccountAddInput;
  BasicObject: ResolversTypes['AdministrativeArea'] | ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['Campaign'] | ResolversTypes['Capability'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Connector'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['EntitySetting'] | ResolversTypes['Event'] | ResolversTypes['ExternalReference'] | ResolversTypes['Group'] | ResolversTypes['Grouping'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['Language'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['MeUser'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['Narrative'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Role'] | ResolversTypes['Sector'] | ResolversTypes['Settings'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['User'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vocabulary'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  BasicRelationship: ResolversTypes['InternalRelationship'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'];
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Campaign: ResolverTypeWrapper<Omit<Campaign, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  CampaignAddInput: CampaignAddInput;
  CampaignConnection: ResolverTypeWrapper<Omit<CampaignConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['CampaignEdge']>>> }>;
  CampaignEdge: ResolverTypeWrapper<Omit<CampaignEdge, 'node'> & { node: ResolversTypes['Campaign'] }>;
  CampaignEditMutations: ResolverTypeWrapper<Omit<CampaignEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Campaign']>, contextPatch?: Maybe<ResolversTypes['Campaign']>, fieldPatch?: Maybe<ResolversTypes['Campaign']>, relationDelete?: Maybe<ResolversTypes['Campaign']> }>;
  CampaignsFilter: CampaignsFilter;
  CampaignsFiltering: CampaignsFiltering;
  CampaignsOrdering: CampaignsOrdering;
  Capabilities: Capabilities;
  Capability: ResolverTypeWrapper<Capability>;
  CapabilityConnection: ResolverTypeWrapper<CapabilityConnection>;
  CapabilityEdge: ResolverTypeWrapper<CapabilityEdge>;
  Case: ResolverTypeWrapper<BasicStoreEntityCase>;
  CaseAddInput: CaseAddInput;
  CaseConnection: ResolverTypeWrapper<Omit<CaseConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['CaseEdge']>>> }>;
  CaseEdge: ResolverTypeWrapper<Omit<CaseEdge, 'node'> & { node: ResolversTypes['Case'] }>;
  CasesFilter: CasesFilter;
  CasesFiltering: CasesFiltering;
  CasesOrdering: CasesOrdering;
  Channel: ResolverTypeWrapper<BasicStoreEntityChannel>;
  ChannelAddInput: ChannelAddInput;
  ChannelConnection: ResolverTypeWrapper<Omit<ChannelConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ChannelEdge']>>> }>;
  ChannelEdge: ResolverTypeWrapper<Omit<ChannelEdge, 'node'> & { node: ResolversTypes['Channel'] }>;
  ChannelsFilter: ChannelsFilter;
  ChannelsFiltering: ChannelsFiltering;
  ChannelsOrdering: ChannelsOrdering;
  CitiesFilter: CitiesFilter;
  CitiesFiltering: CitiesFiltering;
  CitiesOrdering: CitiesOrdering;
  City: ResolverTypeWrapper<Omit<City, 'administrativeArea' | 'cases' | 'connectors' | 'country' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { administrativeArea?: Maybe<ResolversTypes['AdministrativeArea']>, cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, country?: Maybe<ResolversTypes['Country']>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  CityAddInput: CityAddInput;
  CityConnection: ResolverTypeWrapper<Omit<CityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['CityEdge']>>> }>;
  CityEdge: ResolverTypeWrapper<Omit<CityEdge, 'node'> & { node: ResolversTypes['City'] }>;
  CityEditMutations: ResolverTypeWrapper<Omit<CityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['City']>, contextPatch?: Maybe<ResolversTypes['City']>, fieldPatch?: Maybe<ResolversTypes['City']>, relationDelete?: Maybe<ResolversTypes['City']> }>;
  Cluster: ResolverTypeWrapper<Cluster>;
  Connector: ResolverTypeWrapper<Omit<Connector, 'works'> & { works?: Maybe<Array<Maybe<ResolversTypes['Work']>>> }>;
  ConnectorConfig: ResolverTypeWrapper<ConnectorConfig>;
  ConnectorType: ConnectorType;
  ConstraintNumber: ResolverTypeWrapper<Scalars['ConstraintNumber']>;
  ConstraintString: ResolverTypeWrapper<Scalars['ConstraintString']>;
  Container: ResolversTypes['Case'] | ResolversTypes['Grouping'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Report'];
  ContainerConnection: ResolverTypeWrapper<Omit<ContainerConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ContainerEdge']>>> }>;
  ContainerEdge: ResolverTypeWrapper<Omit<ContainerEdge, 'node'> & { node: ResolversTypes['Container'] }>;
  ContainerEditMutations: ResolverTypeWrapper<Omit<ContainerEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Container']>, contextPatch?: Maybe<ResolversTypes['Container']>, fieldPatch?: Maybe<ResolversTypes['Container']>, relationDelete?: Maybe<ResolversTypes['Container']> }>;
  ContainersFilter: ContainersFilter;
  ContainersFiltering: ContainersFiltering;
  ContainersOrdering: ContainersOrdering;
  ContextData: ResolverTypeWrapper<Omit<ContextData, 'external_references'> & { external_references?: Maybe<Array<ResolversTypes['ExternalReference']>> }>;
  CountriesFilter: CountriesFilter;
  CountriesFiltering: CountriesFiltering;
  CountriesOrdering: CountriesOrdering;
  Country: ResolverTypeWrapper<Omit<Country, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'region' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, region?: Maybe<ResolversTypes['Region']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  CountryAddInput: CountryAddInput;
  CountryConnection: ResolverTypeWrapper<Omit<CountryConnection, 'edges'> & { edges: Array<ResolversTypes['CountryEdge']> }>;
  CountryEdge: ResolverTypeWrapper<Omit<CountryEdge, 'node'> & { node: ResolversTypes['Country'] }>;
  CountryEditMutations: ResolverTypeWrapper<Omit<CountryEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Country']>, contextPatch?: Maybe<ResolversTypes['Country']>, fieldPatch?: Maybe<ResolversTypes['Country']>, relationDelete?: Maybe<ResolversTypes['Country']> }>;
  CourseOfAction: ResolverTypeWrapper<Omit<CourseOfAction, 'attackPatterns' | 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { attackPatterns?: Maybe<ResolversTypes['AttackPatternConnection']>, cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  CourseOfActionAddInput: CourseOfActionAddInput;
  CourseOfActionConnection: ResolverTypeWrapper<Omit<CourseOfActionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['CourseOfActionEdge']>>> }>;
  CourseOfActionEdge: ResolverTypeWrapper<Omit<CourseOfActionEdge, 'node'> & { node: ResolversTypes['CourseOfAction'] }>;
  CourseOfActionEditMutations: ResolverTypeWrapper<Omit<CourseOfActionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['CourseOfAction']>, contextPatch?: Maybe<ResolversTypes['CourseOfAction']>, fieldPatch?: Maybe<ResolversTypes['CourseOfAction']>, relationDelete?: Maybe<ResolversTypes['CourseOfAction']> }>;
  CoursesOfActionFilter: CoursesOfActionFilter;
  CoursesOfActionFiltering: CoursesOfActionFiltering;
  CoursesOfActionOrdering: CoursesOfActionOrdering;
  Creator: ResolverTypeWrapper<Creator>;
  CreatorConnection: ResolverTypeWrapper<CreatorConnection>;
  CreatorEdge: ResolverTypeWrapper<CreatorEdge>;
  CryptocurrencyWallet: ResolverTypeWrapper<Omit<CryptocurrencyWallet, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  CryptocurrencyWalletAddInput: CryptocurrencyWalletAddInput;
  CryptographicKey: ResolverTypeWrapper<Omit<CryptographicKey, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  CryptographicKeyAddInput: CryptographicKeyAddInput;
  DataComponent: ResolverTypeWrapper<BasicStoreEntityDataComponent>;
  DataComponentAddInput: DataComponentAddInput;
  DataComponentConnection: ResolverTypeWrapper<Omit<DataComponentConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['DataComponentEdge']>>> }>;
  DataComponentEdge: ResolverTypeWrapper<Omit<DataComponentEdge, 'node'> & { node: ResolversTypes['DataComponent'] }>;
  DataComponentsFilter: DataComponentsFilter;
  DataComponentsFiltering: DataComponentsFiltering;
  DataComponentsOrdering: DataComponentsOrdering;
  DataSource: ResolverTypeWrapper<BasicStoreEntityDataSource>;
  DataSourceAddInput: DataSourceAddInput;
  DataSourceConnection: ResolverTypeWrapper<Omit<DataSourceConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['DataSourceEdge']>>> }>;
  DataSourceEdge: ResolverTypeWrapper<Omit<DataSourceEdge, 'node'> & { node: ResolversTypes['DataSource'] }>;
  DataSourcesFilter: DataSourcesFilter;
  DataSourcesFiltering: DataSourcesFiltering;
  DataSourcesOrdering: DataSourcesOrdering;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  DependencyVersion: ResolverTypeWrapper<DependencyVersion>;
  Dictionary: ResolverTypeWrapper<Dictionary>;
  DictionaryInput: DictionaryInput;
  Directory: ResolverTypeWrapper<Omit<Directory, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  DirectoryAddInput: DirectoryAddInput;
  Display: ResolverTypeWrapper<Display>;
  DisplayStep: ResolverTypeWrapper<DisplayStep>;
  Distribution: ResolverTypeWrapper<Omit<Distribution, 'entity'> & { entity?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  DocsMetrics: ResolverTypeWrapper<DocsMetrics>;
  DomainName: ResolverTypeWrapper<Omit<DomainName, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  DomainNameAddInput: DomainNameAddInput;
  EditContext: EditContext;
  EditInput: EditInput;
  EditOperation: EditOperation;
  EditUserContext: ResolverTypeWrapper<EditUserContext>;
  ElasticSearchMetrics: ResolverTypeWrapper<ElasticSearchMetrics>;
  EmailAddr: ResolverTypeWrapper<Omit<EmailAddr, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  EmailAddrAddInput: EmailAddrAddInput;
  EmailMessage: ResolverTypeWrapper<Omit<EmailMessage, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  EmailMessageAddInput: EmailMessageAddInput;
  EmailMimePartType: ResolverTypeWrapper<Omit<EmailMimePartType, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  EmailMimePartTypeAddInput: EmailMimePartTypeAddInput;
  EntitySetting: ResolverTypeWrapper<BasicStoreEntityEntitySetting>;
  EntitySettingConnection: ResolverTypeWrapper<Omit<EntitySettingConnection, 'edges'> & { edges: Array<ResolversTypes['EntitySettingEdge']> }>;
  EntitySettingEdge: ResolverTypeWrapper<Omit<EntitySettingEdge, 'node'> & { node: ResolversTypes['EntitySetting'] }>;
  EntitySettingsFilter: EntitySettingsFilter;
  EntitySettingsFiltering: EntitySettingsFiltering;
  EntitySettingsOrdering: EntitySettingsOrdering;
  Event: ResolverTypeWrapper<BasicStoreEntityEvent>;
  EventAddInput: EventAddInput;
  EventConnection: ResolverTypeWrapper<Omit<EventConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['EventEdge']>>> }>;
  EventEdge: ResolverTypeWrapper<Omit<EventEdge, 'node'> & { node: ResolversTypes['Event'] }>;
  EventsFilter: EventsFilter;
  EventsFiltering: EventsFiltering;
  EventsOrdering: EventsOrdering;
  ExternalReference: ResolverTypeWrapper<Omit<ExternalReference, 'connectors' | 'exportFiles' | 'importFiles' | 'jobs' | 'pendingFiles'> & { connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, pendingFiles?: Maybe<ResolversTypes['FileConnection']> }>;
  ExternalReferenceAddInput: ExternalReferenceAddInput;
  ExternalReferenceConnection: ResolverTypeWrapper<Omit<ExternalReferenceConnection, 'edges'> & { edges: Array<ResolversTypes['ExternalReferenceEdge']> }>;
  ExternalReferenceEdge: ResolverTypeWrapper<Omit<ExternalReferenceEdge, 'node'> & { node: ResolversTypes['ExternalReference'] }>;
  ExternalReferenceEditMutations: ResolverTypeWrapper<Omit<ExternalReferenceEditMutations, 'askEnrichment' | 'contextClean' | 'contextPatch' | 'fieldPatch' | 'importPush' | 'relationDelete'> & { askEnrichment?: Maybe<ResolversTypes['Work']>, contextClean?: Maybe<ResolversTypes['ExternalReference']>, contextPatch?: Maybe<ResolversTypes['ExternalReference']>, fieldPatch?: Maybe<ResolversTypes['ExternalReference']>, importPush?: Maybe<ResolversTypes['File']>, relationDelete?: Maybe<ResolversTypes['ExternalReference']> }>;
  ExternalReferencesFilter: ExternalReferencesFilter;
  ExternalReferencesFiltering: ExternalReferencesFiltering;
  ExternalReferencesOrdering: ExternalReferencesOrdering;
  Feed: ResolverTypeWrapper<Feed>;
  FeedAddInput: FeedAddInput;
  FeedAttribute: ResolverTypeWrapper<FeedAttribute>;
  FeedAttributeMappingInput: FeedAttributeMappingInput;
  FeedConnection: ResolverTypeWrapper<FeedConnection>;
  FeedEdge: ResolverTypeWrapper<FeedEdge>;
  FeedMapping: ResolverTypeWrapper<FeedMapping>;
  FeedMappingInput: FeedMappingInput;
  FeedOrdering: FeedOrdering;
  File: ResolverTypeWrapper<Omit<File, 'metaData' | 'works'> & { metaData?: Maybe<ResolversTypes['FileMetadata']>, works?: Maybe<Array<Maybe<ResolversTypes['Work']>>> }>;
  FileConnection: ResolverTypeWrapper<Omit<FileConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['FileEdge']>>> }>;
  FileEdge: ResolverTypeWrapper<Omit<FileEdge, 'node'> & { node: ResolversTypes['File'] }>;
  FileMetadata: ResolverTypeWrapper<Omit<FileMetadata, 'entity'> & { entity?: Maybe<ResolversTypes['StixCoreObject']> }>;
  FilterMode: FilterMode;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  GetMetrics: ResolverTypeWrapper<GetMetrics>;
  Group: ResolverTypeWrapper<Omit<Group, 'members'> & { members?: Maybe<ResolversTypes['UserConnection']> }>;
  GroupAddInput: GroupAddInput;
  GroupConnection: ResolverTypeWrapper<Omit<GroupConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['GroupEdge']>>> }>;
  GroupEdge: ResolverTypeWrapper<Omit<GroupEdge, 'node'> & { node: ResolversTypes['Group'] }>;
  GroupEditMutations: ResolverTypeWrapper<Omit<GroupEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Group']>, contextPatch?: Maybe<ResolversTypes['Group']>, fieldPatch?: Maybe<ResolversTypes['Group']>, relationDelete?: Maybe<ResolversTypes['Group']> }>;
  Grouping: ResolverTypeWrapper<BasicStoreEntityGrouping>;
  GroupingAddInput: GroupingAddInput;
  GroupingConnection: ResolverTypeWrapper<Omit<GroupingConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['GroupingEdge']>>> }>;
  GroupingEdge: ResolverTypeWrapper<Omit<GroupingEdge, 'node'> & { node: ResolversTypes['Grouping'] }>;
  GroupingsFilter: GroupingsFilter;
  GroupingsFiltering: GroupingsFiltering;
  GroupingsOrdering: GroupingsOrdering;
  GroupsOrdering: GroupsOrdering;
  Hash: ResolverTypeWrapper<Hash>;
  HashInput: HashInput;
  HashedObservable: ResolversTypes['Artifact'] | ResolversTypes['StixFile'] | ResolversTypes['X509Certificate'];
  Hostname: ResolverTypeWrapper<Omit<Hostname, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  HostnameAddInput: HostnameAddInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  IPv4Addr: ResolverTypeWrapper<Omit<IPv4Addr, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, countries?: Maybe<ResolversTypes['CountryConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  IPv4AddrAddInput: IPv4AddrAddInput;
  IPv6Addr: ResolverTypeWrapper<Omit<IPv6Addr, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, countries?: Maybe<ResolversTypes['CountryConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  IPv6AddrAddInput: IPv6AddrAddInput;
  IdentitiesFilter: IdentitiesFilter;
  IdentitiesFiltering: IdentitiesFiltering;
  IdentitiesOrdering: IdentitiesOrdering;
  Identity: ResolversTypes['Individual'] | ResolversTypes['Organization'] | ResolversTypes['Sector'] | ResolversTypes['System'];
  IdentityAddInput: IdentityAddInput;
  IdentityConnection: ResolverTypeWrapper<Omit<IdentityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['IdentityEdge']>>> }>;
  IdentityEdge: ResolverTypeWrapper<Omit<IdentityEdge, 'node'> & { node: ResolversTypes['Identity'] }>;
  IdentityEditMutations: ResolverTypeWrapper<Omit<IdentityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Identity']>, contextPatch?: Maybe<ResolversTypes['Identity']>, fieldPatch?: Maybe<ResolversTypes['Identity']>, relationDelete?: Maybe<ResolversTypes['Identity']> }>;
  IdentityType: IdentityType;
  Incident: ResolverTypeWrapper<Omit<Incident, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  IncidentAddInput: IncidentAddInput;
  IncidentConnection: ResolverTypeWrapper<Omit<IncidentConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['IncidentEdge']>>> }>;
  IncidentEdge: ResolverTypeWrapper<Omit<IncidentEdge, 'node'> & { node: ResolversTypes['Incident'] }>;
  IncidentEditMutations: ResolverTypeWrapper<Omit<IncidentEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Incident']>, contextPatch?: Maybe<ResolversTypes['Incident']>, fieldPatch?: Maybe<ResolversTypes['Incident']>, relationDelete?: Maybe<ResolversTypes['Incident']> }>;
  IncidentsFilter: IncidentsFilter;
  IncidentsFiltering: IncidentsFiltering;
  IncidentsOrdering: IncidentsOrdering;
  IndexingMetrics: ResolverTypeWrapper<IndexingMetrics>;
  Indicator: ResolverTypeWrapper<Omit<Indicator, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observables' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observables?: Maybe<ResolversTypes['StixCyberObservableConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  IndicatorAddInput: IndicatorAddInput;
  IndicatorConnection: ResolverTypeWrapper<Omit<IndicatorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['IndicatorEdge']>>> }>;
  IndicatorEdge: ResolverTypeWrapper<Omit<IndicatorEdge, 'node'> & { node: ResolversTypes['Indicator'] }>;
  IndicatorEditMutations: ResolverTypeWrapper<Omit<IndicatorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Indicator']>, contextPatch?: Maybe<ResolversTypes['Indicator']>, fieldPatch?: Maybe<ResolversTypes['Indicator']>, relationDelete?: Maybe<ResolversTypes['Indicator']> }>;
  IndicatorsFilter: IndicatorsFilter;
  IndicatorsFiltering: IndicatorsFiltering;
  IndicatorsOrdering: IndicatorsOrdering;
  Individual: ResolverTypeWrapper<Omit<Individual, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'organizations' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, organizations?: Maybe<ResolversTypes['OrganizationConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  IndividualAddInput: IndividualAddInput;
  IndividualConnection: ResolverTypeWrapper<Omit<IndividualConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['IndividualEdge']>>> }>;
  IndividualEdge: ResolverTypeWrapper<Omit<IndividualEdge, 'node'> & { node: ResolversTypes['Individual'] }>;
  IndividualEditMutations: ResolverTypeWrapper<Omit<IndividualEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Individual']>, contextPatch?: Maybe<ResolversTypes['Individual']>, fieldPatch?: Maybe<ResolversTypes['Individual']>, relationDelete?: Maybe<ResolversTypes['Individual']> }>;
  IndividualsFilter: IndividualsFilter;
  IndividualsFiltering: IndividualsFiltering;
  IndividualsOrdering: IndividualsOrdering;
  Inference: ResolverTypeWrapper<Omit<Inference, 'explanation'> & { explanation: Array<Maybe<ResolversTypes['StixObjectOrStixRelationship']>> }>;
  InferenceAttribute: ResolverTypeWrapper<InferenceAttribute>;
  Infrastructure: ResolverTypeWrapper<Omit<Infrastructure, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  InfrastructureAddInput: InfrastructureAddInput;
  InfrastructureConnection: ResolverTypeWrapper<Omit<InfrastructureConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['InfrastructureEdge']>>> }>;
  InfrastructureEdge: ResolverTypeWrapper<Omit<InfrastructureEdge, 'node'> & { node: ResolversTypes['Infrastructure'] }>;
  InfrastructureEditMutations: ResolverTypeWrapper<Omit<InfrastructureEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Infrastructure']>, contextPatch?: Maybe<ResolversTypes['Infrastructure']>, fieldPatch?: Maybe<ResolversTypes['Infrastructure']>, relationDelete?: Maybe<ResolversTypes['Infrastructure']> }>;
  InfrastructuresFilter: InfrastructuresFilter;
  InfrastructuresFiltering: InfrastructuresFiltering;
  InfrastructuresOrdering: InfrastructuresOrdering;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  InternalObject: ResolversTypes['Capability'] | ResolversTypes['Connector'] | ResolversTypes['EntitySetting'] | ResolversTypes['Group'] | ResolversTypes['MeUser'] | ResolversTypes['Role'] | ResolversTypes['Settings'] | ResolversTypes['User'];
  InternalRelationship: ResolverTypeWrapper<InternalRelationship>;
  InternalRelationshipAddInput: InternalRelationshipAddInput;
  IntrusionSet: ResolverTypeWrapper<Omit<IntrusionSet, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'locations' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, locations?: Maybe<ResolversTypes['LocationConnection']>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  IntrusionSetAddInput: IntrusionSetAddInput;
  IntrusionSetConnection: ResolverTypeWrapper<Omit<IntrusionSetConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['IntrusionSetEdge']>>> }>;
  IntrusionSetEdge: ResolverTypeWrapper<Omit<IntrusionSetEdge, 'node'> & { node: ResolversTypes['IntrusionSet'] }>;
  IntrusionSetEditMutations: ResolverTypeWrapper<Omit<IntrusionSetEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['IntrusionSet']>, contextPatch?: Maybe<ResolversTypes['IntrusionSet']>, fieldPatch?: Maybe<ResolversTypes['IntrusionSet']>, relationDelete?: Maybe<ResolversTypes['IntrusionSet']> }>;
  IntrusionSetsFilter: IntrusionSetsFilter;
  IntrusionSetsFiltering: IntrusionSetsFiltering;
  IntrusionSetsOrdering: IntrusionSetsOrdering;
  KillChainPhase: ResolverTypeWrapper<KillChainPhase>;
  KillChainPhaseAddInput: KillChainPhaseAddInput;
  KillChainPhaseConnection: ResolverTypeWrapper<KillChainPhaseConnection>;
  KillChainPhaseEdge: ResolverTypeWrapper<KillChainPhaseEdge>;
  KillChainPhaseEditMutations: ResolverTypeWrapper<KillChainPhaseEditMutations>;
  KillChainPhasesFilter: KillChainPhasesFilter;
  KillChainPhasesFiltering: KillChainPhasesFiltering;
  KillChainPhasesOrdering: KillChainPhasesOrdering;
  Label: ResolverTypeWrapper<Label>;
  LabelAddInput: LabelAddInput;
  LabelConnection: ResolverTypeWrapper<LabelConnection>;
  LabelEdge: ResolverTypeWrapper<LabelEdge>;
  LabelEditMutations: ResolverTypeWrapper<LabelEditMutations>;
  LabelsFilter: LabelsFilter;
  LabelsFiltering: LabelsFiltering;
  LabelsOrdering: LabelsOrdering;
  Language: ResolverTypeWrapper<BasicStoreEntityLanguage>;
  LanguageAddInput: LanguageAddInput;
  LanguageConnection: ResolverTypeWrapper<Omit<LanguageConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['LanguageEdge']>>> }>;
  LanguageEdge: ResolverTypeWrapper<Omit<LanguageEdge, 'node'> & { node: ResolversTypes['Language'] }>;
  LanguagesFilter: LanguagesFilter;
  LanguagesFiltering: LanguagesFiltering;
  LanguagesOrdering: LanguagesOrdering;
  ListTask: ResolverTypeWrapper<ListTask>;
  ListTaskAddInput: ListTaskAddInput;
  Location: ResolversTypes['AdministrativeArea'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['Position'] | ResolversTypes['Region'];
  LocationAddInput: LocationAddInput;
  LocationConnection: ResolverTypeWrapper<Omit<LocationConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['LocationEdge']>>> }>;
  LocationEdge: ResolverTypeWrapper<Omit<LocationEdge, 'node'> & { node: ResolversTypes['Location'] }>;
  LocationEditMutations: ResolverTypeWrapper<Omit<LocationEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Location']>, contextPatch?: Maybe<ResolversTypes['Location']>, fieldPatch?: Maybe<ResolversTypes['Location']>, relationDelete?: Maybe<ResolversTypes['Location']> }>;
  LocationsFilter: LocationsFilter;
  LocationsFiltering: LocationsFiltering;
  LocationsOrdering: LocationsOrdering;
  Log: ResolverTypeWrapper<Omit<Log, 'context_data' | 'user'> & { context_data?: Maybe<ResolversTypes['ContextData']>, user?: Maybe<ResolversTypes['User']> }>;
  LogConnection: ResolverTypeWrapper<Omit<LogConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['LogEdge']>>> }>;
  LogEdge: ResolverTypeWrapper<Omit<LogEdge, 'node'> & { node: ResolversTypes['Log'] }>;
  LogsFilter: LogsFilter;
  LogsFiltering: LogsFiltering;
  LogsOrdering: LogsOrdering;
  LogsWorkerConfig: ResolverTypeWrapper<LogsWorkerConfig>;
  MacAddr: ResolverTypeWrapper<Omit<MacAddr, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  MacAddrAddInput: MacAddrAddInput;
  Malware: ResolverTypeWrapper<Omit<Malware, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  MalwareAddInput: MalwareAddInput;
  MalwareConnection: ResolverTypeWrapper<Omit<MalwareConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['MalwareEdge']>>> }>;
  MalwareEdge: ResolverTypeWrapper<Omit<MalwareEdge, 'node'> & { node: ResolversTypes['Malware'] }>;
  MalwareEditMutations: ResolverTypeWrapper<Omit<MalwareEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Malware']>, contextPatch?: Maybe<ResolversTypes['Malware']>, fieldPatch?: Maybe<ResolversTypes['Malware']>, relationDelete?: Maybe<ResolversTypes['Malware']> }>;
  MalwaresFilter: MalwaresFilter;
  MalwaresFiltering: MalwaresFiltering;
  MalwaresOrdering: MalwaresOrdering;
  MarkingDefinition: ResolverTypeWrapper<MarkingDefinition>;
  MarkingDefinitionAddInput: MarkingDefinitionAddInput;
  MarkingDefinitionConnection: ResolverTypeWrapper<MarkingDefinitionConnection>;
  MarkingDefinitionEdge: ResolverTypeWrapper<MarkingDefinitionEdge>;
  MarkingDefinitionEditMutations: ResolverTypeWrapper<MarkingDefinitionEditMutations>;
  MarkingDefinitionsFilter: MarkingDefinitionsFilter;
  MarkingDefinitionsFiltering: MarkingDefinitionsFiltering;
  MarkingDefinitionsOrdering: MarkingDefinitionsOrdering;
  MeOrganization: ResolverTypeWrapper<MeOrganization>;
  MeOrganizationConnection: ResolverTypeWrapper<MeOrganizationConnection>;
  MeOrganizationEdge: ResolverTypeWrapper<MeOrganizationEdge>;
  MeUser: ResolverTypeWrapper<Omit<MeUser, 'userSubscriptions'> & { userSubscriptions?: Maybe<ResolversTypes['UserSubscriptionConnection']> }>;
  MediaContent: ResolverTypeWrapper<Omit<MediaContent, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  MediaContentAddInput: MediaContentAddInput;
  MessagesStats: ResolverTypeWrapper<MessagesStats>;
  Module: ResolverTypeWrapper<Module>;
  MultiDistribution: ResolverTypeWrapper<MultiDistribution>;
  MultiTimeSeries: ResolverTypeWrapper<MultiTimeSeries>;
  Mutation: ResolverTypeWrapper<{}>;
  Mutex: ResolverTypeWrapper<Omit<Mutex, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  MutexAddInput: MutexAddInput;
  Narrative: ResolverTypeWrapper<BasicStoreEntityNarrative>;
  NarrativeAddInput: NarrativeAddInput;
  NarrativeConnection: ResolverTypeWrapper<Omit<NarrativeConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['NarrativeEdge']>>> }>;
  NarrativeEdge: ResolverTypeWrapper<Omit<NarrativeEdge, 'node'> & { node: ResolversTypes['Narrative'] }>;
  NarrativesFilter: NarrativesFilter;
  NarrativesFiltering: NarrativesFiltering;
  NarrativesOrdering: NarrativesOrdering;
  NetworkTraffic: ResolverTypeWrapper<Omit<NetworkTraffic, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  NetworkTrafficAddInput: NetworkTrafficAddInput;
  Note: ResolverTypeWrapper<Omit<Note, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, relatedContainers?: Maybe<ResolversTypes['ContainerConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  NoteAddInput: NoteAddInput;
  NoteConnection: ResolverTypeWrapper<Omit<NoteConnection, 'edges'> & { edges: Array<ResolversTypes['NoteEdge']> }>;
  NoteEdge: ResolverTypeWrapper<Omit<NoteEdge, 'node'> & { node: ResolversTypes['Note'] }>;
  NoteEditMutations: ResolverTypeWrapper<Omit<NoteEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Note']>, contextPatch?: Maybe<ResolversTypes['Note']>, fieldPatch?: Maybe<ResolversTypes['Note']>, relationDelete?: Maybe<ResolversTypes['Note']> }>;
  NoteUserAddInput: NoteUserAddInput;
  NotesFilter: NotesFilter;
  NotesFiltering: NotesFiltering;
  NotesOrdering: NotesOrdering;
  Number: ResolverTypeWrapper<Number>;
  ObjectTotals: ResolverTypeWrapper<ObjectTotals>;
  ObservedData: ResolverTypeWrapper<Omit<ObservedData, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, relatedContainers?: Maybe<ResolversTypes['ContainerConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  ObservedDataAddInput: ObservedDataAddInput;
  ObservedDataConnection: ResolverTypeWrapper<Omit<ObservedDataConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ObservedDataEdge']>>> }>;
  ObservedDataEdge: ResolverTypeWrapper<Omit<ObservedDataEdge, 'node'> & { node: ResolversTypes['ObservedData'] }>;
  ObservedDataEditMutations: ResolverTypeWrapper<Omit<ObservedDataEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['ObservedData']>, contextPatch?: Maybe<ResolversTypes['ObservedData']>, fieldPatch?: Maybe<ResolversTypes['ObservedData']>, relationDelete?: Maybe<ResolversTypes['ObservedData']> }>;
  ObservedDatasFilter: ObservedDatasFilter;
  ObservedDatasFiltering: ObservedDatasFiltering;
  ObservedDatasOrdering: ObservedDatasOrdering;
  Opinion: ResolverTypeWrapper<Omit<Opinion, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, relatedContainers?: Maybe<ResolversTypes['ContainerConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  OpinionAddInput: OpinionAddInput;
  OpinionConnection: ResolverTypeWrapper<Omit<OpinionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['OpinionEdge']>>> }>;
  OpinionEdge: ResolverTypeWrapper<Omit<OpinionEdge, 'node'> & { node: ResolversTypes['Opinion'] }>;
  OpinionEditMutations: ResolverTypeWrapper<Omit<OpinionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Opinion']>, contextPatch?: Maybe<ResolversTypes['Opinion']>, fieldPatch?: Maybe<ResolversTypes['Opinion']>, relationDelete?: Maybe<ResolversTypes['Opinion']> }>;
  OpinionsFilter: OpinionsFilter;
  OpinionsFiltering: OpinionsFiltering;
  OpinionsOrdering: OpinionsOrdering;
  OrderingMode: OrderingMode;
  Organization: ResolverTypeWrapper<Omit<Organization, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'sectors' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, sectors?: Maybe<ResolversTypes['SectorConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  OrganizationAddInput: OrganizationAddInput;
  OrganizationConnection: ResolverTypeWrapper<Omit<OrganizationConnection, 'edges'> & { edges: Array<ResolversTypes['OrganizationEdge']> }>;
  OrganizationEdge: ResolverTypeWrapper<Omit<OrganizationEdge, 'node'> & { node: ResolversTypes['Organization'] }>;
  OrganizationEditMutations: ResolverTypeWrapper<Omit<OrganizationEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Organization']>, contextPatch?: Maybe<ResolversTypes['Organization']>, fieldPatch?: Maybe<ResolversTypes['Organization']>, relationDelete?: Maybe<ResolversTypes['Organization']> }>;
  OrganizationOrIndividual: ResolversTypes['Individual'] | ResolversTypes['Organization'];
  OrganizationReliability: OrganizationReliability;
  OrganizationsFilter: OrganizationsFilter;
  OrganizationsFiltering: OrganizationsFiltering;
  OrganizationsOrdering: OrganizationsOrdering;
  OtpElement: ResolverTypeWrapper<OtpElement>;
  OverviewMetrics: ResolverTypeWrapper<OverviewMetrics>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PaymentCard: ResolverTypeWrapper<Omit<PaymentCard, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  PaymentCardAddInput: PaymentCardAddInput;
  PhoneNumber: ResolverTypeWrapper<Omit<PhoneNumber, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  PhoneNumberAddInput: PhoneNumberAddInput;
  Position: ResolverTypeWrapper<Omit<Position, 'cases' | 'city' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, city?: Maybe<ResolversTypes['City']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  PositionAddInput: PositionAddInput;
  PositionConnection: ResolverTypeWrapper<Omit<PositionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['PositionEdge']>>> }>;
  PositionEdge: ResolverTypeWrapper<Omit<PositionEdge, 'node'> & { node: ResolversTypes['Position'] }>;
  PositionEditMutations: ResolverTypeWrapper<Omit<PositionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Position']>, contextPatch?: Maybe<ResolversTypes['Position']>, fieldPatch?: Maybe<ResolversTypes['Position']>, relationDelete?: Maybe<ResolversTypes['Position']> }>;
  PositionsFilter: PositionsFilter;
  PositionsFiltering: PositionsFiltering;
  PositionsOrdering: PositionsOrdering;
  Process: ResolverTypeWrapper<Omit<Process, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'serviceDlls' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, serviceDlls?: Maybe<ResolversTypes['StixFileConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  ProcessAddInput: ProcessAddInput;
  Provider: ResolverTypeWrapper<Provider>;
  Query: ResolverTypeWrapper<{}>;
  QueryTask: ResolverTypeWrapper<QueryTask>;
  QueryTaskAddInput: QueryTaskAddInput;
  QueueArguments: ResolverTypeWrapper<QueueArguments>;
  QueueMetrics: ResolverTypeWrapper<QueueMetrics>;
  QueueTotals: ResolverTypeWrapper<QueueTotals>;
  RabbitMQConnection: ResolverTypeWrapper<RabbitMqConnection>;
  RabbitMQMetrics: ResolverTypeWrapper<RabbitMqMetrics>;
  Region: ResolverTypeWrapper<Omit<Region, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentRegions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subRegions'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, countries?: Maybe<ResolversTypes['CountryConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, parentRegions?: Maybe<ResolversTypes['RegionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, subRegions?: Maybe<ResolversTypes['RegionConnection']> }>;
  RegionAddInput: RegionAddInput;
  RegionConnection: ResolverTypeWrapper<Omit<RegionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['RegionEdge']>>> }>;
  RegionEdge: ResolverTypeWrapper<Omit<RegionEdge, 'node'> & { node: ResolversTypes['Region'] }>;
  RegionEditMutations: ResolverTypeWrapper<Omit<RegionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Region']>, contextPatch?: Maybe<ResolversTypes['Region']>, fieldPatch?: Maybe<ResolversTypes['Region']>, relationDelete?: Maybe<ResolversTypes['Region']> }>;
  RegionsFilter: RegionsFilter;
  RegionsFiltering: RegionsFiltering;
  RegionsOrdering: RegionsOrdering;
  RegisterConnectorInput: RegisterConnectorInput;
  Report: ResolverTypeWrapper<Omit<Report, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, relatedContainers?: Maybe<ResolversTypes['ContainerConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  ReportAddInput: ReportAddInput;
  ReportConnection: ResolverTypeWrapper<Omit<ReportConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ReportEdge']>>> }>;
  ReportEdge: ResolverTypeWrapper<Omit<ReportEdge, 'node'> & { node: ResolversTypes['Report'] }>;
  ReportEditMutations: ResolverTypeWrapper<Omit<ReportEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Report']>, contextPatch?: Maybe<ResolversTypes['Report']>, fieldPatch?: Maybe<ResolversTypes['Report']>, relationDelete?: Maybe<ResolversTypes['Report']> }>;
  ReportsFilter: ReportsFilter;
  ReportsFiltering: ReportsFiltering;
  ReportsOrdering: ReportsOrdering;
  RetentionRule: ResolverTypeWrapper<RetentionRule>;
  RetentionRuleAddInput: RetentionRuleAddInput;
  RetentionRuleConnection: ResolverTypeWrapper<RetentionRuleConnection>;
  RetentionRuleEdge: ResolverTypeWrapper<RetentionRuleEdge>;
  RetentionRuleEditMutations: ResolverTypeWrapper<RetentionRuleEditMutations>;
  Role: ResolverTypeWrapper<Role>;
  RoleAddInput: RoleAddInput;
  RoleConnection: ResolverTypeWrapper<RoleConnection>;
  RoleEdge: ResolverTypeWrapper<RoleEdge>;
  RoleEditMutations: ResolverTypeWrapper<RoleEditMutations>;
  RolesOrdering: RolesOrdering;
  Rule: ResolverTypeWrapper<Rule>;
  RuleExecutionError: ResolverTypeWrapper<RuleExecutionError>;
  RuleManager: ResolverTypeWrapper<RuleManager>;
  RuleTask: ResolverTypeWrapper<RuleTask>;
  SearchMetrics: ResolverTypeWrapper<SearchMetrics>;
  Sector: ResolverTypeWrapper<Omit<Sector, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentSectors' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subSectors' | 'targetedOrganizations'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, parentSectors?: Maybe<ResolversTypes['SectorConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, subSectors?: Maybe<ResolversTypes['SectorConnection']>, targetedOrganizations?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  SectorAddInput: SectorAddInput;
  SectorConnection: ResolverTypeWrapper<Omit<SectorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['SectorEdge']>>> }>;
  SectorEdge: ResolverTypeWrapper<Omit<SectorEdge, 'node'> & { node: ResolversTypes['Sector'] }>;
  SectorEditMutations: ResolverTypeWrapper<Omit<SectorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Sector']>, contextPatch?: Maybe<ResolversTypes['Sector']>, fieldPatch?: Maybe<ResolversTypes['Sector']>, relationDelete?: Maybe<ResolversTypes['Sector']> }>;
  SectorsFilter: SectorsFilter;
  SectorsFiltering: SectorsFiltering;
  SectorsOrdering: SectorsOrdering;
  SessionDetail: ResolverTypeWrapper<SessionDetail>;
  Settings: ResolverTypeWrapper<Omit<Settings, 'platform_organization'> & { platform_organization?: Maybe<ResolversTypes['Organization']> }>;
  SettingsEditMutations: ResolverTypeWrapper<Omit<SettingsEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch'> & { contextClean?: Maybe<ResolversTypes['Settings']>, contextPatch?: Maybe<ResolversTypes['Settings']>, fieldPatch?: Maybe<ResolversTypes['Settings']> }>;
  Software: ResolverTypeWrapper<Omit<Software, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships' | 'vulnerabilities'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, vulnerabilities?: Maybe<ResolversTypes['VulnerabilityConnection']> }>;
  SoftwareAddInput: SoftwareAddInput;
  State: State;
  StatsOperation: StatsOperation;
  Status: ResolverTypeWrapper<Status>;
  StatusAddInput: StatusAddInput;
  StatusConnection: ResolverTypeWrapper<StatusConnection>;
  StatusEdge: ResolverTypeWrapper<StatusEdge>;
  StatusFilter: StatusFilter;
  StatusOrdering: StatusOrdering;
  StatusTemplate: ResolverTypeWrapper<StatusTemplate>;
  StatusTemplateAddInput: StatusTemplateAddInput;
  StatusTemplateConnection: ResolverTypeWrapper<StatusTemplateConnection>;
  StatusTemplateEdge: ResolverTypeWrapper<StatusTemplateEdge>;
  StatusTemplateOrdering: StatusTemplateOrdering;
  StatusesFiltering: StatusesFiltering;
  StixCoreObject: ResolversTypes['AdministrativeArea'] | ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['Campaign'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Event'] | ResolversTypes['Grouping'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['Language'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['Narrative'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  StixCoreObjectConnection: ResolverTypeWrapper<Omit<StixCoreObjectConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixCoreObjectEdge']>>> }>;
  StixCoreObjectEdge: ResolverTypeWrapper<Omit<StixCoreObjectEdge, 'node'> & { node: ResolversTypes['StixCoreObject'] }>;
  StixCoreObjectEditMutations: ResolverTypeWrapper<Omit<StixCoreObjectEditMutations, 'askEnrichment' | 'exportAsk' | 'importPush' | 'relationDelete' | 'relationsAdd' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { askEnrichment?: Maybe<ResolversTypes['Work']>, exportAsk?: Maybe<Array<Maybe<ResolversTypes['File']>>>, importPush?: Maybe<ResolversTypes['File']>, relationDelete?: Maybe<ResolversTypes['StixCoreObject']>, relationsAdd?: Maybe<ResolversTypes['StixCoreObject']>, restrictionOrganizationAdd?: Maybe<ResolversTypes['StixCoreObject']>, restrictionOrganizationDelete?: Maybe<ResolversTypes['StixCoreObject']> }>;
  StixCoreObjectOrStixCoreRelationship: ResolversTypes['AdministrativeArea'] | ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['Campaign'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['EntitySetting'] | ResolversTypes['Event'] | ResolversTypes['Grouping'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['Language'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['Narrative'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixFile'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  StixCoreObjectsDistributionParameters: StixCoreObjectsDistributionParameters;
  StixCoreObjectsFilter: StixCoreObjectsFilter;
  StixCoreObjectsFiltering: StixCoreObjectsFiltering;
  StixCoreObjectsNumberParameters: StixCoreObjectsNumberParameters;
  StixCoreObjectsOrdering: StixCoreObjectsOrdering;
  StixCoreObjectsTimeSeriesParameters: StixCoreObjectsTimeSeriesParameters;
  StixCoreRelationship: ResolverTypeWrapper<Omit<StixCoreRelationship, 'cases' | 'createdBy' | 'externalReferences' | 'from' | 'groupings' | 'notes' | 'objectOrganization' | 'opinions' | 'reports' | 'stixCoreRelationships' | 'to'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixCoreRelationshipAddInput: StixCoreRelationshipAddInput;
  StixCoreRelationshipConnection: ResolverTypeWrapper<Omit<StixCoreRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixCoreRelationshipEdge']>>> }>;
  StixCoreRelationshipEdge: ResolverTypeWrapper<Omit<StixCoreRelationshipEdge, 'node'> & { node: ResolversTypes['StixCoreRelationship'] }>;
  StixCoreRelationshipEditMutations: ResolverTypeWrapper<Omit<StixCoreRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { contextClean?: Maybe<ResolversTypes['StixCoreRelationship']>, contextPatch?: Maybe<ResolversTypes['StixCoreRelationship']>, fieldPatch?: Maybe<ResolversTypes['StixCoreRelationship']>, relationDelete?: Maybe<ResolversTypes['StixCoreRelationship']>, restrictionOrganizationAdd?: Maybe<ResolversTypes['StixCoreRelationship']>, restrictionOrganizationDelete?: Maybe<ResolversTypes['StixCoreRelationship']> }>;
  StixCoreRelationshipsDistributionParameters: StixCoreRelationshipsDistributionParameters;
  StixCoreRelationshipsFilter: StixCoreRelationshipsFilter;
  StixCoreRelationshipsFiltering: StixCoreRelationshipsFiltering;
  StixCoreRelationshipsOrdering: StixCoreRelationshipsOrdering;
  StixCoreRelationshipsTimeSeriesParameters: StixCoreRelationshipsTimeSeriesParameters;
  StixCyberObservable: ResolversTypes['Artifact'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['MacAddr'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Process'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['Text'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  StixCyberObservableConnection: ResolverTypeWrapper<Omit<StixCyberObservableConnection, 'edges'> & { edges: Array<ResolversTypes['StixCyberObservableEdge']> }>;
  StixCyberObservableEdge: ResolverTypeWrapper<Omit<StixCyberObservableEdge, 'node'> & { node: ResolversTypes['StixCyberObservable'] }>;
  StixCyberObservableEditMutations: ResolverTypeWrapper<Omit<StixCyberObservableEditMutations, 'contextClean' | 'contextPatch' | 'exportAsk' | 'fieldPatch' | 'importPush' | 'promote' | 'relationDelete' | 'relationsAdd'> & { contextClean?: Maybe<ResolversTypes['StixCyberObservable']>, contextPatch?: Maybe<ResolversTypes['StixCyberObservable']>, exportAsk?: Maybe<Array<Maybe<ResolversTypes['File']>>>, fieldPatch?: Maybe<ResolversTypes['StixCyberObservable']>, importPush?: Maybe<ResolversTypes['File']>, promote?: Maybe<ResolversTypes['StixCyberObservable']>, relationDelete?: Maybe<ResolversTypes['StixCyberObservable']>, relationsAdd?: Maybe<ResolversTypes['StixCyberObservable']> }>;
  StixCyberObservableRelationship: ResolverTypeWrapper<Omit<StixCyberObservableRelationship, 'cases' | 'from' | 'groupings' | 'notes' | 'opinions' | 'reports' | 'to'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, notes?: Maybe<ResolversTypes['NoteConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixCyberObservableRelationshipAddInput: StixCyberObservableRelationshipAddInput;
  StixCyberObservableRelationshipConnection: ResolverTypeWrapper<Omit<StixCyberObservableRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixCyberObservableRelationshipEdge']>>> }>;
  StixCyberObservableRelationshipEdge: ResolverTypeWrapper<Omit<StixCyberObservableRelationshipEdge, 'node'> & { node: ResolversTypes['StixCyberObservableRelationship'] }>;
  StixCyberObservableRelationshipEditMutations: ResolverTypeWrapper<Omit<StixCyberObservableRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch'> & { contextClean?: Maybe<ResolversTypes['StixCyberObservableRelationship']>, contextPatch?: Maybe<ResolversTypes['StixCyberObservableRelationship']>, fieldPatch?: Maybe<ResolversTypes['StixCyberObservableRelationship']> }>;
  StixCyberObservableRelationshipsFilter: StixCyberObservableRelationshipsFilter;
  StixCyberObservableRelationshipsFiltering: StixCyberObservableRelationshipsFiltering;
  StixCyberObservableRelationshipsOrdering: StixCyberObservableRelationshipsOrdering;
  StixCyberObservablesFilter: StixCyberObservablesFilter;
  StixCyberObservablesFiltering: StixCyberObservablesFiltering;
  StixCyberObservablesOrdering: StixCyberObservablesOrdering;
  StixDomainObject: ResolversTypes['AdministrativeArea'] | ResolversTypes['AttackPattern'] | ResolversTypes['Campaign'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Event'] | ResolversTypes['Grouping'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['Language'] | ResolversTypes['Malware'] | ResolversTypes['Narrative'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['System'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Vulnerability'];
  StixDomainObjectAddInput: StixDomainObjectAddInput;
  StixDomainObjectConnection: ResolverTypeWrapper<Omit<StixDomainObjectConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixDomainObjectEdge']>>> }>;
  StixDomainObjectEdge: ResolverTypeWrapper<Omit<StixDomainObjectEdge, 'node'> & { node: ResolversTypes['StixDomainObject'] }>;
  StixDomainObjectEditMutations: ResolverTypeWrapper<Omit<StixDomainObjectEditMutations, 'changeType' | 'contextClean' | 'contextPatch' | 'exportAsk' | 'fieldPatch' | 'importPush' | 'relationDelete' | 'relationsAdd'> & { changeType?: Maybe<ResolversTypes['StixDomainObject']>, contextClean?: Maybe<ResolversTypes['StixDomainObject']>, contextPatch?: Maybe<ResolversTypes['StixDomainObject']>, exportAsk?: Maybe<Array<Maybe<ResolversTypes['File']>>>, fieldPatch?: Maybe<ResolversTypes['StixDomainObject']>, importPush?: Maybe<ResolversTypes['File']>, relationDelete?: Maybe<ResolversTypes['StixDomainObject']>, relationsAdd?: Maybe<ResolversTypes['StixDomainObject']> }>;
  StixDomainObjectsFilter: StixDomainObjectsFilter;
  StixDomainObjectsFiltering: StixDomainObjectsFiltering;
  StixDomainObjectsOrdering: StixDomainObjectsOrdering;
  StixEditMutations: ResolverTypeWrapper<StixEditMutations>;
  StixFile: ResolverTypeWrapper<Omit<StixFile, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'obsContent' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, obsContent?: Maybe<ResolversTypes['Artifact']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  StixFileAddInput: StixFileAddInput;
  StixFileConnection: ResolverTypeWrapper<Omit<StixFileConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixFileEdge']>>> }>;
  StixFileEdge: ResolverTypeWrapper<Omit<StixFileEdge, 'node'> & { node: ResolversTypes['StixFile'] }>;
  StixId: ResolverTypeWrapper<Scalars['StixId']>;
  StixMetaObject: ResolversTypes['ExternalReference'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['Vocabulary'];
  StixMetaRelationship: ResolverTypeWrapper<Omit<StixMetaRelationship, 'from' | 'to'> & { from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixMetaRelationshipAddInput: StixMetaRelationshipAddInput;
  StixMetaRelationshipConnection: ResolverTypeWrapper<StixMetaRelationshipConnection>;
  StixMetaRelationshipEdge: ResolverTypeWrapper<StixMetaRelationshipEdge>;
  StixMetaRelationshipsAddInput: StixMetaRelationshipsAddInput;
  StixMetaRelationshipsFilter: StixMetaRelationshipsFilter;
  StixMetaRelationshipsFiltering: StixMetaRelationshipsFiltering;
  StixMetaRelationshipsOrdering: StixMetaRelationshipsOrdering;
  StixObject: ResolversTypes['AdministrativeArea'] | ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['Campaign'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Event'] | ResolversTypes['ExternalReference'] | ResolversTypes['Grouping'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['Language'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['Narrative'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vocabulary'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  StixObjectOrStixRelationship: ResolversTypes['AdministrativeArea'] | ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['BankAccount'] | ResolversTypes['Campaign'] | ResolversTypes['Case'] | ResolversTypes['Channel'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['DataComponent'] | ResolversTypes['DataSource'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['EntitySetting'] | ResolversTypes['Event'] | ResolversTypes['ExternalReference'] | ResolversTypes['Grouping'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['Language'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['MediaContent'] | ResolversTypes['Mutex'] | ResolversTypes['Narrative'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['PaymentCard'] | ResolversTypes['PhoneNumber'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixFile'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'];
  StixObjectOrStixRelationshipConnection: ResolverTypeWrapper<StixObjectOrStixRelationshipConnection>;
  StixObjectOrStixRelationshipEdge: ResolverTypeWrapper<Omit<StixObjectOrStixRelationshipEdge, 'node'> & { node: ResolversTypes['StixObjectOrStixRelationship'] }>;
  StixObjectOrStixRelationshipRefConnection: ResolverTypeWrapper<StixObjectOrStixRelationshipRefConnection>;
  StixObjectOrStixRelationshipRefEdge: ResolverTypeWrapper<Omit<StixObjectOrStixRelationshipRefEdge, 'node'> & { node: ResolversTypes['StixObjectOrStixRelationship'] }>;
  StixObjectOrStixRelationshipsFilter: StixObjectOrStixRelationshipsFilter;
  StixObjectOrStixRelationshipsFiltering: StixObjectOrStixRelationshipsFiltering;
  StixObjectOrStixRelationshipsOrdering: StixObjectOrStixRelationshipsOrdering;
  StixRef: ResolverTypeWrapper<Scalars['StixRef']>;
  StixRelationship: ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'];
  StixRelationshipConnection: ResolverTypeWrapper<StixRelationshipConnection>;
  StixRelationshipEdge: ResolverTypeWrapper<StixRelationshipEdge>;
  StixRelationshipEditMutations: ResolverTypeWrapper<StixRelationshipEditMutations>;
  StixRelationshipsFilter: StixRelationshipsFilter;
  StixRelationshipsFiltering: StixRelationshipsFiltering;
  StixRelationshipsOrdering: StixRelationshipsOrdering;
  StixSightingRelationship: ResolverTypeWrapper<Omit<StixSightingRelationship, 'cases' | 'createdBy' | 'externalReferences' | 'from' | 'groupings' | 'notes' | 'objectOrganization' | 'opinions' | 'reports' | 'to'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixSightingRelationshipAddInput: StixSightingRelationshipAddInput;
  StixSightingRelationshipConnection: ResolverTypeWrapper<Omit<StixSightingRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StixSightingRelationshipsEdge']>>> }>;
  StixSightingRelationshipEditMutations: ResolverTypeWrapper<Omit<StixSightingRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { contextClean?: Maybe<ResolversTypes['StixSightingRelationship']>, contextPatch?: Maybe<ResolversTypes['StixSightingRelationship']>, fieldPatch?: Maybe<ResolversTypes['StixSightingRelationship']>, relationDelete?: Maybe<ResolversTypes['StixSightingRelationship']>, restrictionOrganizationAdd?: Maybe<ResolversTypes['StixSightingRelationship']>, restrictionOrganizationDelete?: Maybe<ResolversTypes['StixSightingRelationship']> }>;
  StixSightingRelationshipsEdge: ResolverTypeWrapper<Omit<StixSightingRelationshipsEdge, 'node'> & { node: ResolversTypes['StixSightingRelationship'] }>;
  StixSightingRelationshipsFilter: StixSightingRelationshipsFilter;
  StixSightingRelationshipsFiltering: StixSightingRelationshipsFiltering;
  StixSightingRelationshipsOrdering: StixSightingRelationshipsOrdering;
  StreamCollection: ResolverTypeWrapper<Omit<StreamCollection, 'groups'> & { groups?: Maybe<Array<Maybe<ResolversTypes['Group']>>> }>;
  StreamCollectionAddInput: StreamCollectionAddInput;
  StreamCollectionConnection: ResolverTypeWrapper<Omit<StreamCollectionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['StreamCollectionEdge']>>> }>;
  StreamCollectionEdge: ResolverTypeWrapper<Omit<StreamCollectionEdge, 'node'> & { node: ResolversTypes['StreamCollection'] }>;
  StreamCollectionEditMutations: ResolverTypeWrapper<Omit<StreamCollectionEditMutations, 'addGroup' | 'deleteGroup' | 'fieldPatch'> & { addGroup?: Maybe<ResolversTypes['StreamCollection']>, deleteGroup?: Maybe<ResolversTypes['StreamCollection']>, fieldPatch?: Maybe<ResolversTypes['StreamCollection']> }>;
  StreamCollectionOrdering: StreamCollectionOrdering;
  String: ResolverTypeWrapper<Scalars['String']>;
  SubType: ResolverTypeWrapper<Omit<SubType, 'settings'> & { settings?: Maybe<ResolversTypes['EntitySetting']> }>;
  SubTypeConnection: ResolverTypeWrapper<Omit<SubTypeConnection, 'edges'> & { edges: Array<ResolversTypes['SubTypeEdge']> }>;
  SubTypeEdge: ResolverTypeWrapper<Omit<SubTypeEdge, 'node'> & { node: ResolversTypes['SubType'] }>;
  SubTypeEditMutations: ResolverTypeWrapper<Omit<SubTypeEditMutations, 'statusAdd' | 'statusDelete' | 'statusFieldPatch'> & { statusAdd?: Maybe<ResolversTypes['SubType']>, statusDelete?: Maybe<ResolversTypes['SubType']>, statusFieldPatch?: Maybe<ResolversTypes['SubType']> }>;
  SubTypesOrdering: SubTypesOrdering;
  Subscription: ResolverTypeWrapper<{}>;
  Synchronizer: ResolverTypeWrapper<Omit<Synchronizer, 'user'> & { user?: Maybe<ResolversTypes['User']> }>;
  SynchronizerAddInput: SynchronizerAddInput;
  SynchronizerConnection: ResolverTypeWrapper<Omit<SynchronizerConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['SynchronizerEdge']>>> }>;
  SynchronizerEdge: ResolverTypeWrapper<Omit<SynchronizerEdge, 'node'> & { node: ResolversTypes['Synchronizer'] }>;
  SynchronizerEditMutations: ResolverTypeWrapper<Omit<SynchronizerEditMutations, 'fieldPatch'> & { fieldPatch?: Maybe<ResolversTypes['Synchronizer']> }>;
  SynchronizersOrdering: SynchronizersOrdering;
  System: ResolverTypeWrapper<Omit<System, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'organizations' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, organizations?: Maybe<ResolversTypes['OrganizationConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  SystemAddInput: SystemAddInput;
  SystemConnection: ResolverTypeWrapper<Omit<SystemConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['SystemEdge']>>> }>;
  SystemEdge: ResolverTypeWrapper<Omit<SystemEdge, 'node'> & { node: ResolversTypes['System'] }>;
  SystemEditMutations: ResolverTypeWrapper<Omit<SystemEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['System']>, contextPatch?: Maybe<ResolversTypes['System']>, fieldPatch?: Maybe<ResolversTypes['System']>, relationDelete?: Maybe<ResolversTypes['System']> }>;
  SystemsFilter: SystemsFilter;
  SystemsFiltering: SystemsFiltering;
  SystemsOrdering: SystemsOrdering;
  Task: ResolversTypes['ListTask'] | ResolversTypes['QueryTask'] | ResolversTypes['RuleTask'];
  TaskAction: ResolverTypeWrapper<TaskAction>;
  TaskActionInput: TaskActionInput;
  TaskActionType: TaskActionType;
  TaskConnection: ResolverTypeWrapper<TaskConnection>;
  TaskConnectionEdge: ResolverTypeWrapper<TaskConnectionEdge>;
  TaskContext: ResolverTypeWrapper<TaskContext>;
  TaskContextInput: TaskContextInput;
  TaskContextType: TaskContextType;
  TaskError: ResolverTypeWrapper<TaskError>;
  TaskType: TaskType;
  TasksFilter: TasksFilter;
  TasksFiltering: TasksFiltering;
  TasksOrdering: TasksOrdering;
  TaxiiCollection: ResolverTypeWrapper<TaxiiCollection>;
  TaxiiCollectionAddInput: TaxiiCollectionAddInput;
  TaxiiCollectionConnection: ResolverTypeWrapper<TaxiiCollectionConnection>;
  TaxiiCollectionEdge: ResolverTypeWrapper<TaxiiCollectionEdge>;
  TaxiiCollectionEditMutations: ResolverTypeWrapper<TaxiiCollectionEditMutations>;
  TaxiiCollectionOrdering: TaxiiCollectionOrdering;
  Text: ResolverTypeWrapper<Omit<Text, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  TextAddInput: TextAddInput;
  ThreatActor: ResolverTypeWrapper<Omit<ThreatActor, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'locations' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, countries?: Maybe<ResolversTypes['CountryConnection']>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, locations?: Maybe<ResolversTypes['LocationConnection']>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  ThreatActorAddInput: ThreatActorAddInput;
  ThreatActorConnection: ResolverTypeWrapper<Omit<ThreatActorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ThreatActorEdge']>>> }>;
  ThreatActorEdge: ResolverTypeWrapper<Omit<ThreatActorEdge, 'node'> & { node: ResolversTypes['ThreatActor'] }>;
  ThreatActorEditMutations: ResolverTypeWrapper<Omit<ThreatActorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['ThreatActor']>, contextPatch?: Maybe<ResolversTypes['ThreatActor']>, fieldPatch?: Maybe<ResolversTypes['ThreatActor']>, relationDelete?: Maybe<ResolversTypes['ThreatActor']> }>;
  ThreatActorsFilter: ThreatActorsFilter;
  ThreatActorsFiltering: ThreatActorsFiltering;
  ThreatActorsOrdering: ThreatActorsOrdering;
  TimeSeries: ResolverTypeWrapper<TimeSeries>;
  Tool: ResolverTypeWrapper<Omit<Tool, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  ToolAddInput: ToolAddInput;
  ToolConnection: ResolverTypeWrapper<Omit<ToolConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['ToolEdge']>>> }>;
  ToolEdge: ResolverTypeWrapper<Omit<ToolEdge, 'node'> & { node: ResolversTypes['Tool'] }>;
  ToolEditMutations: ResolverTypeWrapper<Omit<ToolEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Tool']>, contextPatch?: Maybe<ResolversTypes['Tool']>, fieldPatch?: Maybe<ResolversTypes['Tool']>, relationDelete?: Maybe<ResolversTypes['Tool']> }>;
  ToolsFilter: ToolsFilter;
  ToolsFiltering: ToolsFiltering;
  ToolsOrdering: ToolsOrdering;
  Upload: ResolverTypeWrapper<Scalars['Upload']>;
  Url: ResolverTypeWrapper<Omit<Url, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  UrlAddInput: UrlAddInput;
  User: ResolverTypeWrapper<Omit<User, 'groups' | 'objectOrganization' | 'userSubscriptions'> & { groups?: Maybe<ResolversTypes['GroupConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, userSubscriptions?: Maybe<ResolversTypes['UserSubscriptionConnection']> }>;
  UserAccount: ResolverTypeWrapper<Omit<UserAccount, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  UserAccountAddInput: UserAccountAddInput;
  UserAddInput: UserAddInput;
  UserAgent: ResolverTypeWrapper<Omit<UserAgent, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  UserAgentAddInput: UserAgentAddInput;
  UserConnection: ResolverTypeWrapper<Omit<UserConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['UserEdge']>>> }>;
  UserEdge: ResolverTypeWrapper<Omit<UserEdge, 'node'> & { node: ResolversTypes['User'] }>;
  UserEditMutations: ResolverTypeWrapper<Omit<UserEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'organizationAdd' | 'organizationDelete' | 'relationDelete' | 'tokenRenew'> & { contextClean?: Maybe<ResolversTypes['User']>, contextPatch?: Maybe<ResolversTypes['User']>, fieldPatch?: Maybe<ResolversTypes['User']>, organizationAdd?: Maybe<ResolversTypes['User']>, organizationDelete?: Maybe<ResolversTypes['User']>, relationDelete?: Maybe<ResolversTypes['User']>, tokenRenew?: Maybe<ResolversTypes['User']> }>;
  UserLoginInput: UserLoginInput;
  UserOTPActivationInput: UserOtpActivationInput;
  UserOTPLoginInput: UserOtpLoginInput;
  UserSession: ResolverTypeWrapper<Omit<UserSession, 'user'> & { user?: Maybe<ResolversTypes['User']> }>;
  UserSubscription: ResolverTypeWrapper<Omit<UserSubscription, 'entities' | 'user'> & { entities?: Maybe<Array<Maybe<ResolversTypes['StixDomainObject']>>>, user?: Maybe<ResolversTypes['User']> }>;
  UserSubscriptionAddInput: UserSubscriptionAddInput;
  UserSubscriptionConnection: ResolverTypeWrapper<Omit<UserSubscriptionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['UserSubscriptionEdge']>>> }>;
  UserSubscriptionEdge: ResolverTypeWrapper<Omit<UserSubscriptionEdge, 'node'> & { node: ResolversTypes['UserSubscription'] }>;
  UserSubscriptionEditMutations: ResolverTypeWrapper<Omit<UserSubscriptionEditMutations, 'fieldPatch'> & { fieldPatch?: Maybe<ResolversTypes['UserSubscription']> }>;
  UserSubscriptionOrdering: UserSubscriptionOrdering;
  UsersFilter: UsersFilter;
  UsersFiltering: UsersFiltering;
  UsersOrdering: UsersOrdering;
  Vocabulary: ResolverTypeWrapper<BasicStoreEntityVocabulary>;
  VocabularyAddInput: VocabularyAddInput;
  VocabularyCategory: VocabularyCategory;
  VocabularyConnection: ResolverTypeWrapper<Omit<VocabularyConnection, 'edges'> & { edges: Array<ResolversTypes['VocabularyEdge']> }>;
  VocabularyDefinition: ResolverTypeWrapper<VocabularyDefinition>;
  VocabularyEdge: ResolverTypeWrapper<Omit<VocabularyEdge, 'node'> & { node: ResolversTypes['Vocabulary'] }>;
  VocabularyFieldDefinition: ResolverTypeWrapper<VocabularyFieldDefinition>;
  VocabularyFilter: VocabularyFilter;
  VocabularyFiltering: VocabularyFiltering;
  VocabularyOrdering: VocabularyOrdering;
  VulnerabilitiesFilter: VulnerabilitiesFilter;
  VulnerabilitiesFiltering: VulnerabilitiesFiltering;
  VulnerabilitiesOrdering: VulnerabilitiesOrdering;
  Vulnerability: ResolverTypeWrapper<Omit<Vulnerability, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'softwares' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, softwares?: Maybe<ResolversTypes['StixCyberObservableConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']> }>;
  VulnerabilityAddInput: VulnerabilityAddInput;
  VulnerabilityConnection: ResolverTypeWrapper<Omit<VulnerabilityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['VulnerabilityEdge']>>> }>;
  VulnerabilityEdge: ResolverTypeWrapper<Omit<VulnerabilityEdge, 'node'> & { node: ResolversTypes['Vulnerability'] }>;
  VulnerabilityEditMutations: ResolverTypeWrapper<Omit<VulnerabilityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversTypes['Vulnerability']>, contextPatch?: Maybe<ResolversTypes['Vulnerability']>, fieldPatch?: Maybe<ResolversTypes['Vulnerability']>, relationDelete?: Maybe<ResolversTypes['Vulnerability']> }>;
  WindowsRegistryKey: ResolverTypeWrapper<Omit<WindowsRegistryKey, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  WindowsRegistryKeyAddInput: WindowsRegistryKeyAddInput;
  WindowsRegistryValueType: ResolverTypeWrapper<Omit<WindowsRegistryValueType, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  WindowsRegistryValueTypeAddInput: WindowsRegistryValueTypeAddInput;
  Work: ResolverTypeWrapper<Omit<Work, 'connector' | 'user'> & { connector?: Maybe<ResolversTypes['Connector']>, user?: Maybe<ResolversTypes['User']> }>;
  WorkConnection: ResolverTypeWrapper<Omit<WorkConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['WorkEdge']>>> }>;
  WorkEdge: ResolverTypeWrapper<Omit<WorkEdge, 'node'> & { node: ResolversTypes['Work'] }>;
  WorkEditMutations: ResolverTypeWrapper<WorkEditMutations>;
  WorkErrorInput: WorkErrorInput;
  WorkMessage: ResolverTypeWrapper<WorkMessage>;
  WorkTracking: ResolverTypeWrapper<WorkTracking>;
  WorksFilter: WorksFilter;
  WorksFiltering: WorksFiltering;
  WorksOrdering: WorksOrdering;
  Workspace: ResolverTypeWrapper<Omit<Workspace, 'owner'> & { owner?: Maybe<ResolversTypes['User']> }>;
  WorkspaceAddInput: WorkspaceAddInput;
  WorkspaceConnection: ResolverTypeWrapper<Omit<WorkspaceConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversTypes['WorkspaceEdge']>>> }>;
  WorkspaceEdge: ResolverTypeWrapper<Omit<WorkspaceEdge, 'node'> & { node: ResolversTypes['Workspace'] }>;
  WorkspaceEditMutations: ResolverTypeWrapper<Omit<WorkspaceEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'relationsAdd' | 'relationsDelete'> & { contextClean?: Maybe<ResolversTypes['Workspace']>, contextPatch?: Maybe<ResolversTypes['Workspace']>, fieldPatch?: Maybe<ResolversTypes['Workspace']>, relationDelete?: Maybe<ResolversTypes['Workspace']>, relationsAdd?: Maybe<ResolversTypes['Workspace']>, relationsDelete?: Maybe<ResolversTypes['Workspace']> }>;
  WorkspacesFilter: WorkspacesFilter;
  WorkspacesFiltering: WorkspacesFiltering;
  WorkspacesOrdering: WorkspacesOrdering;
  X509Certificate: ResolverTypeWrapper<Omit<X509Certificate, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversTypes['Connector']>>>, createdBy?: Maybe<ResolversTypes['Identity']>, exportFiles?: Maybe<ResolversTypes['FileConnection']>, externalReferences?: Maybe<ResolversTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversTypes['GroupingConnection']>, importFiles?: Maybe<ResolversTypes['FileConnection']>, indicators?: Maybe<ResolversTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversTypes['Work']>>>, notes?: Maybe<ResolversTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversTypes['OrganizationConnection']>, observedData?: Maybe<ResolversTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversTypes['FileConnection']>, reports?: Maybe<ResolversTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']> }>;
  X509CertificateAddInput: X509CertificateAddInput;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  AckDetails: AckDetails;
  AdministrativeArea: BasicStoreEntityAdministrativeArea;
  AdministrativeAreaAddInput: AdministrativeAreaAddInput;
  AdministrativeAreaConnection: Omit<AdministrativeAreaConnection, 'edges'> & { edges?: Maybe<Array<ResolversParentTypes['AdministrativeAreaEdge']>> };
  AdministrativeAreaEdge: Omit<AdministrativeAreaEdge, 'node'> & { node: ResolversParentTypes['AdministrativeArea'] };
  AdministrativeAreasFiltering: AdministrativeAreasFiltering;
  AppDebugDistribution: AppDebugDistribution;
  AppDebugStatistics: AppDebugStatistics;
  AppInfo: AppInfo;
  AppMemory: AppMemory;
  Artifact: Omit<Artifact, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  ArtifactAddInput: ArtifactAddInput;
  Assignee: Assignee;
  AssigneeConnection: AssigneeConnection;
  AssigneeEdge: AssigneeEdge;
  AttackPattern: Omit<AttackPattern, 'cases' | 'connectors' | 'coursesOfAction' | 'createdBy' | 'dataComponents' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentAttackPatterns' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subAttackPatterns'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, coursesOfAction?: Maybe<ResolversParentTypes['CourseOfActionConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, dataComponents?: Maybe<ResolversParentTypes['DataComponentConnection']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, parentAttackPatterns?: Maybe<ResolversParentTypes['AttackPatternConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, subAttackPatterns?: Maybe<ResolversParentTypes['AttackPatternConnection']> };
  AttackPatternAddInput: AttackPatternAddInput;
  AttackPatternConnection: Omit<AttackPatternConnection, 'edges'> & { edges: Array<ResolversParentTypes['AttackPatternEdge']> };
  AttackPatternEdge: Omit<AttackPatternEdge, 'node'> & { node: ResolversParentTypes['AttackPattern'] };
  AttackPatternEditMutations: Omit<AttackPatternEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['AttackPattern']>, contextPatch?: Maybe<ResolversParentTypes['AttackPattern']>, fieldPatch?: Maybe<ResolversParentTypes['AttackPattern']>, relationDelete?: Maybe<ResolversParentTypes['AttackPattern']> };
  AttackPatternsFiltering: AttackPatternsFiltering;
  Attribute: Attribute;
  AttributeConnection: AttributeConnection;
  AttributeEdge: AttributeEdge;
  AttributeEditMutations: AttributeEditMutations;
  AutonomousSystem: Omit<AutonomousSystem, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  AutonomousSystemAddInput: AutonomousSystemAddInput;
  BankAccount: Omit<BankAccount, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  BankAccountAddInput: BankAccountAddInput;
  BasicObject: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Capability'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Connector'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['EntitySetting'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Group'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['Language'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['MeUser'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Role'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Settings'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['User'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vocabulary'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  BasicRelationship: ResolversParentTypes['InternalRelationship'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'];
  Boolean: Scalars['Boolean'];
  Campaign: Omit<Campaign, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  CampaignAddInput: CampaignAddInput;
  CampaignConnection: Omit<CampaignConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['CampaignEdge']>>> };
  CampaignEdge: Omit<CampaignEdge, 'node'> & { node: ResolversParentTypes['Campaign'] };
  CampaignEditMutations: Omit<CampaignEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Campaign']>, contextPatch?: Maybe<ResolversParentTypes['Campaign']>, fieldPatch?: Maybe<ResolversParentTypes['Campaign']>, relationDelete?: Maybe<ResolversParentTypes['Campaign']> };
  CampaignsFiltering: CampaignsFiltering;
  Capability: Capability;
  CapabilityConnection: CapabilityConnection;
  CapabilityEdge: CapabilityEdge;
  Case: BasicStoreEntityCase;
  CaseAddInput: CaseAddInput;
  CaseConnection: Omit<CaseConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['CaseEdge']>>> };
  CaseEdge: Omit<CaseEdge, 'node'> & { node: ResolversParentTypes['Case'] };
  CasesFiltering: CasesFiltering;
  Channel: BasicStoreEntityChannel;
  ChannelAddInput: ChannelAddInput;
  ChannelConnection: Omit<ChannelConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ChannelEdge']>>> };
  ChannelEdge: Omit<ChannelEdge, 'node'> & { node: ResolversParentTypes['Channel'] };
  ChannelsFiltering: ChannelsFiltering;
  CitiesFiltering: CitiesFiltering;
  City: Omit<City, 'administrativeArea' | 'cases' | 'connectors' | 'country' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { administrativeArea?: Maybe<ResolversParentTypes['AdministrativeArea']>, cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, country?: Maybe<ResolversParentTypes['Country']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  CityAddInput: CityAddInput;
  CityConnection: Omit<CityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['CityEdge']>>> };
  CityEdge: Omit<CityEdge, 'node'> & { node: ResolversParentTypes['City'] };
  CityEditMutations: Omit<CityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['City']>, contextPatch?: Maybe<ResolversParentTypes['City']>, fieldPatch?: Maybe<ResolversParentTypes['City']>, relationDelete?: Maybe<ResolversParentTypes['City']> };
  Cluster: Cluster;
  Connector: Omit<Connector, 'works'> & { works?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>> };
  ConnectorConfig: ConnectorConfig;
  ConstraintNumber: Scalars['ConstraintNumber'];
  ConstraintString: Scalars['ConstraintString'];
  Container: ResolversParentTypes['Case'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Report'];
  ContainerConnection: Omit<ContainerConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ContainerEdge']>>> };
  ContainerEdge: Omit<ContainerEdge, 'node'> & { node: ResolversParentTypes['Container'] };
  ContainerEditMutations: Omit<ContainerEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Container']>, contextPatch?: Maybe<ResolversParentTypes['Container']>, fieldPatch?: Maybe<ResolversParentTypes['Container']>, relationDelete?: Maybe<ResolversParentTypes['Container']> };
  ContainersFiltering: ContainersFiltering;
  ContextData: Omit<ContextData, 'external_references'> & { external_references?: Maybe<Array<ResolversParentTypes['ExternalReference']>> };
  CountriesFiltering: CountriesFiltering;
  Country: Omit<Country, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'region' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, region?: Maybe<ResolversParentTypes['Region']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  CountryAddInput: CountryAddInput;
  CountryConnection: Omit<CountryConnection, 'edges'> & { edges: Array<ResolversParentTypes['CountryEdge']> };
  CountryEdge: Omit<CountryEdge, 'node'> & { node: ResolversParentTypes['Country'] };
  CountryEditMutations: Omit<CountryEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Country']>, contextPatch?: Maybe<ResolversParentTypes['Country']>, fieldPatch?: Maybe<ResolversParentTypes['Country']>, relationDelete?: Maybe<ResolversParentTypes['Country']> };
  CourseOfAction: Omit<CourseOfAction, 'attackPatterns' | 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { attackPatterns?: Maybe<ResolversParentTypes['AttackPatternConnection']>, cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  CourseOfActionAddInput: CourseOfActionAddInput;
  CourseOfActionConnection: Omit<CourseOfActionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['CourseOfActionEdge']>>> };
  CourseOfActionEdge: Omit<CourseOfActionEdge, 'node'> & { node: ResolversParentTypes['CourseOfAction'] };
  CourseOfActionEditMutations: Omit<CourseOfActionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['CourseOfAction']>, contextPatch?: Maybe<ResolversParentTypes['CourseOfAction']>, fieldPatch?: Maybe<ResolversParentTypes['CourseOfAction']>, relationDelete?: Maybe<ResolversParentTypes['CourseOfAction']> };
  CoursesOfActionFiltering: CoursesOfActionFiltering;
  Creator: Creator;
  CreatorConnection: CreatorConnection;
  CreatorEdge: CreatorEdge;
  CryptocurrencyWallet: Omit<CryptocurrencyWallet, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  CryptocurrencyWalletAddInput: CryptocurrencyWalletAddInput;
  CryptographicKey: Omit<CryptographicKey, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  CryptographicKeyAddInput: CryptographicKeyAddInput;
  DataComponent: BasicStoreEntityDataComponent;
  DataComponentAddInput: DataComponentAddInput;
  DataComponentConnection: Omit<DataComponentConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['DataComponentEdge']>>> };
  DataComponentEdge: Omit<DataComponentEdge, 'node'> & { node: ResolversParentTypes['DataComponent'] };
  DataComponentsFiltering: DataComponentsFiltering;
  DataSource: BasicStoreEntityDataSource;
  DataSourceAddInput: DataSourceAddInput;
  DataSourceConnection: Omit<DataSourceConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['DataSourceEdge']>>> };
  DataSourceEdge: Omit<DataSourceEdge, 'node'> & { node: ResolversParentTypes['DataSource'] };
  DataSourcesFiltering: DataSourcesFiltering;
  DateTime: Scalars['DateTime'];
  DependencyVersion: DependencyVersion;
  Dictionary: Dictionary;
  DictionaryInput: DictionaryInput;
  Directory: Omit<Directory, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  DirectoryAddInput: DirectoryAddInput;
  Display: Display;
  DisplayStep: DisplayStep;
  Distribution: Omit<Distribution, 'entity'> & { entity?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  DocsMetrics: DocsMetrics;
  DomainName: Omit<DomainName, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  DomainNameAddInput: DomainNameAddInput;
  EditContext: EditContext;
  EditInput: EditInput;
  EditUserContext: EditUserContext;
  ElasticSearchMetrics: ElasticSearchMetrics;
  EmailAddr: Omit<EmailAddr, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  EmailAddrAddInput: EmailAddrAddInput;
  EmailMessage: Omit<EmailMessage, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  EmailMessageAddInput: EmailMessageAddInput;
  EmailMimePartType: Omit<EmailMimePartType, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  EmailMimePartTypeAddInput: EmailMimePartTypeAddInput;
  EntitySetting: BasicStoreEntityEntitySetting;
  EntitySettingConnection: Omit<EntitySettingConnection, 'edges'> & { edges: Array<ResolversParentTypes['EntitySettingEdge']> };
  EntitySettingEdge: Omit<EntitySettingEdge, 'node'> & { node: ResolversParentTypes['EntitySetting'] };
  EntitySettingsFiltering: EntitySettingsFiltering;
  Event: BasicStoreEntityEvent;
  EventAddInput: EventAddInput;
  EventConnection: Omit<EventConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['EventEdge']>>> };
  EventEdge: Omit<EventEdge, 'node'> & { node: ResolversParentTypes['Event'] };
  EventsFiltering: EventsFiltering;
  ExternalReference: Omit<ExternalReference, 'connectors' | 'exportFiles' | 'importFiles' | 'jobs' | 'pendingFiles'> & { connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']> };
  ExternalReferenceAddInput: ExternalReferenceAddInput;
  ExternalReferenceConnection: Omit<ExternalReferenceConnection, 'edges'> & { edges: Array<ResolversParentTypes['ExternalReferenceEdge']> };
  ExternalReferenceEdge: Omit<ExternalReferenceEdge, 'node'> & { node: ResolversParentTypes['ExternalReference'] };
  ExternalReferenceEditMutations: Omit<ExternalReferenceEditMutations, 'askEnrichment' | 'contextClean' | 'contextPatch' | 'fieldPatch' | 'importPush' | 'relationDelete'> & { askEnrichment?: Maybe<ResolversParentTypes['Work']>, contextClean?: Maybe<ResolversParentTypes['ExternalReference']>, contextPatch?: Maybe<ResolversParentTypes['ExternalReference']>, fieldPatch?: Maybe<ResolversParentTypes['ExternalReference']>, importPush?: Maybe<ResolversParentTypes['File']>, relationDelete?: Maybe<ResolversParentTypes['ExternalReference']> };
  ExternalReferencesFiltering: ExternalReferencesFiltering;
  Feed: Feed;
  FeedAddInput: FeedAddInput;
  FeedAttribute: FeedAttribute;
  FeedAttributeMappingInput: FeedAttributeMappingInput;
  FeedConnection: FeedConnection;
  FeedEdge: FeedEdge;
  FeedMapping: FeedMapping;
  FeedMappingInput: FeedMappingInput;
  File: Omit<File, 'metaData' | 'works'> & { metaData?: Maybe<ResolversParentTypes['FileMetadata']>, works?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>> };
  FileConnection: Omit<FileConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['FileEdge']>>> };
  FileEdge: Omit<FileEdge, 'node'> & { node: ResolversParentTypes['File'] };
  FileMetadata: Omit<FileMetadata, 'entity'> & { entity?: Maybe<ResolversParentTypes['StixCoreObject']> };
  Float: Scalars['Float'];
  GetMetrics: GetMetrics;
  Group: Omit<Group, 'members'> & { members?: Maybe<ResolversParentTypes['UserConnection']> };
  GroupAddInput: GroupAddInput;
  GroupConnection: Omit<GroupConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['GroupEdge']>>> };
  GroupEdge: Omit<GroupEdge, 'node'> & { node: ResolversParentTypes['Group'] };
  GroupEditMutations: Omit<GroupEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Group']>, contextPatch?: Maybe<ResolversParentTypes['Group']>, fieldPatch?: Maybe<ResolversParentTypes['Group']>, relationDelete?: Maybe<ResolversParentTypes['Group']> };
  Grouping: BasicStoreEntityGrouping;
  GroupingAddInput: GroupingAddInput;
  GroupingConnection: Omit<GroupingConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['GroupingEdge']>>> };
  GroupingEdge: Omit<GroupingEdge, 'node'> & { node: ResolversParentTypes['Grouping'] };
  GroupingsFiltering: GroupingsFiltering;
  Hash: Hash;
  HashInput: HashInput;
  HashedObservable: ResolversParentTypes['Artifact'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['X509Certificate'];
  Hostname: Omit<Hostname, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  HostnameAddInput: HostnameAddInput;
  ID: Scalars['ID'];
  IPv4Addr: Omit<IPv4Addr, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, countries?: Maybe<ResolversParentTypes['CountryConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  IPv4AddrAddInput: IPv4AddrAddInput;
  IPv6Addr: Omit<IPv6Addr, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, countries?: Maybe<ResolversParentTypes['CountryConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  IPv6AddrAddInput: IPv6AddrAddInput;
  IdentitiesFiltering: IdentitiesFiltering;
  Identity: ResolversParentTypes['Individual'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Sector'] | ResolversParentTypes['System'];
  IdentityAddInput: IdentityAddInput;
  IdentityConnection: Omit<IdentityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['IdentityEdge']>>> };
  IdentityEdge: Omit<IdentityEdge, 'node'> & { node: ResolversParentTypes['Identity'] };
  IdentityEditMutations: Omit<IdentityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Identity']>, contextPatch?: Maybe<ResolversParentTypes['Identity']>, fieldPatch?: Maybe<ResolversParentTypes['Identity']>, relationDelete?: Maybe<ResolversParentTypes['Identity']> };
  Incident: Omit<Incident, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  IncidentAddInput: IncidentAddInput;
  IncidentConnection: Omit<IncidentConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['IncidentEdge']>>> };
  IncidentEdge: Omit<IncidentEdge, 'node'> & { node: ResolversParentTypes['Incident'] };
  IncidentEditMutations: Omit<IncidentEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Incident']>, contextPatch?: Maybe<ResolversParentTypes['Incident']>, fieldPatch?: Maybe<ResolversParentTypes['Incident']>, relationDelete?: Maybe<ResolversParentTypes['Incident']> };
  IncidentsFiltering: IncidentsFiltering;
  IndexingMetrics: IndexingMetrics;
  Indicator: Omit<Indicator, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observables' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observables?: Maybe<ResolversParentTypes['StixCyberObservableConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  IndicatorAddInput: IndicatorAddInput;
  IndicatorConnection: Omit<IndicatorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['IndicatorEdge']>>> };
  IndicatorEdge: Omit<IndicatorEdge, 'node'> & { node: ResolversParentTypes['Indicator'] };
  IndicatorEditMutations: Omit<IndicatorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Indicator']>, contextPatch?: Maybe<ResolversParentTypes['Indicator']>, fieldPatch?: Maybe<ResolversParentTypes['Indicator']>, relationDelete?: Maybe<ResolversParentTypes['Indicator']> };
  IndicatorsFiltering: IndicatorsFiltering;
  Individual: Omit<Individual, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'organizations' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, organizations?: Maybe<ResolversParentTypes['OrganizationConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  IndividualAddInput: IndividualAddInput;
  IndividualConnection: Omit<IndividualConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['IndividualEdge']>>> };
  IndividualEdge: Omit<IndividualEdge, 'node'> & { node: ResolversParentTypes['Individual'] };
  IndividualEditMutations: Omit<IndividualEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Individual']>, contextPatch?: Maybe<ResolversParentTypes['Individual']>, fieldPatch?: Maybe<ResolversParentTypes['Individual']>, relationDelete?: Maybe<ResolversParentTypes['Individual']> };
  IndividualsFiltering: IndividualsFiltering;
  Inference: Omit<Inference, 'explanation'> & { explanation: Array<Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>> };
  InferenceAttribute: InferenceAttribute;
  Infrastructure: Omit<Infrastructure, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  InfrastructureAddInput: InfrastructureAddInput;
  InfrastructureConnection: Omit<InfrastructureConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['InfrastructureEdge']>>> };
  InfrastructureEdge: Omit<InfrastructureEdge, 'node'> & { node: ResolversParentTypes['Infrastructure'] };
  InfrastructureEditMutations: Omit<InfrastructureEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Infrastructure']>, contextPatch?: Maybe<ResolversParentTypes['Infrastructure']>, fieldPatch?: Maybe<ResolversParentTypes['Infrastructure']>, relationDelete?: Maybe<ResolversParentTypes['Infrastructure']> };
  InfrastructuresFiltering: InfrastructuresFiltering;
  Int: Scalars['Int'];
  InternalObject: ResolversParentTypes['Capability'] | ResolversParentTypes['Connector'] | ResolversParentTypes['EntitySetting'] | ResolversParentTypes['Group'] | ResolversParentTypes['MeUser'] | ResolversParentTypes['Role'] | ResolversParentTypes['Settings'] | ResolversParentTypes['User'];
  InternalRelationship: InternalRelationship;
  InternalRelationshipAddInput: InternalRelationshipAddInput;
  IntrusionSet: Omit<IntrusionSet, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'locations' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, locations?: Maybe<ResolversParentTypes['LocationConnection']>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  IntrusionSetAddInput: IntrusionSetAddInput;
  IntrusionSetConnection: Omit<IntrusionSetConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['IntrusionSetEdge']>>> };
  IntrusionSetEdge: Omit<IntrusionSetEdge, 'node'> & { node: ResolversParentTypes['IntrusionSet'] };
  IntrusionSetEditMutations: Omit<IntrusionSetEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['IntrusionSet']>, contextPatch?: Maybe<ResolversParentTypes['IntrusionSet']>, fieldPatch?: Maybe<ResolversParentTypes['IntrusionSet']>, relationDelete?: Maybe<ResolversParentTypes['IntrusionSet']> };
  IntrusionSetsFiltering: IntrusionSetsFiltering;
  KillChainPhase: KillChainPhase;
  KillChainPhaseAddInput: KillChainPhaseAddInput;
  KillChainPhaseConnection: KillChainPhaseConnection;
  KillChainPhaseEdge: KillChainPhaseEdge;
  KillChainPhaseEditMutations: KillChainPhaseEditMutations;
  KillChainPhasesFiltering: KillChainPhasesFiltering;
  Label: Label;
  LabelAddInput: LabelAddInput;
  LabelConnection: LabelConnection;
  LabelEdge: LabelEdge;
  LabelEditMutations: LabelEditMutations;
  LabelsFiltering: LabelsFiltering;
  Language: BasicStoreEntityLanguage;
  LanguageAddInput: LanguageAddInput;
  LanguageConnection: Omit<LanguageConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['LanguageEdge']>>> };
  LanguageEdge: Omit<LanguageEdge, 'node'> & { node: ResolversParentTypes['Language'] };
  LanguagesFiltering: LanguagesFiltering;
  ListTask: ListTask;
  ListTaskAddInput: ListTaskAddInput;
  Location: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['Position'] | ResolversParentTypes['Region'];
  LocationAddInput: LocationAddInput;
  LocationConnection: Omit<LocationConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['LocationEdge']>>> };
  LocationEdge: Omit<LocationEdge, 'node'> & { node: ResolversParentTypes['Location'] };
  LocationEditMutations: Omit<LocationEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Location']>, contextPatch?: Maybe<ResolversParentTypes['Location']>, fieldPatch?: Maybe<ResolversParentTypes['Location']>, relationDelete?: Maybe<ResolversParentTypes['Location']> };
  LocationsFiltering: LocationsFiltering;
  Log: Omit<Log, 'context_data' | 'user'> & { context_data?: Maybe<ResolversParentTypes['ContextData']>, user?: Maybe<ResolversParentTypes['User']> };
  LogConnection: Omit<LogConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['LogEdge']>>> };
  LogEdge: Omit<LogEdge, 'node'> & { node: ResolversParentTypes['Log'] };
  LogsFiltering: LogsFiltering;
  LogsWorkerConfig: LogsWorkerConfig;
  MacAddr: Omit<MacAddr, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  MacAddrAddInput: MacAddrAddInput;
  Malware: Omit<Malware, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  MalwareAddInput: MalwareAddInput;
  MalwareConnection: Omit<MalwareConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['MalwareEdge']>>> };
  MalwareEdge: Omit<MalwareEdge, 'node'> & { node: ResolversParentTypes['Malware'] };
  MalwareEditMutations: Omit<MalwareEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Malware']>, contextPatch?: Maybe<ResolversParentTypes['Malware']>, fieldPatch?: Maybe<ResolversParentTypes['Malware']>, relationDelete?: Maybe<ResolversParentTypes['Malware']> };
  MalwaresFiltering: MalwaresFiltering;
  MarkingDefinition: MarkingDefinition;
  MarkingDefinitionAddInput: MarkingDefinitionAddInput;
  MarkingDefinitionConnection: MarkingDefinitionConnection;
  MarkingDefinitionEdge: MarkingDefinitionEdge;
  MarkingDefinitionEditMutations: MarkingDefinitionEditMutations;
  MarkingDefinitionsFiltering: MarkingDefinitionsFiltering;
  MeOrganization: MeOrganization;
  MeOrganizationConnection: MeOrganizationConnection;
  MeOrganizationEdge: MeOrganizationEdge;
  MeUser: Omit<MeUser, 'userSubscriptions'> & { userSubscriptions?: Maybe<ResolversParentTypes['UserSubscriptionConnection']> };
  MediaContent: Omit<MediaContent, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  MediaContentAddInput: MediaContentAddInput;
  MessagesStats: MessagesStats;
  Module: Module;
  MultiDistribution: MultiDistribution;
  MultiTimeSeries: MultiTimeSeries;
  Mutation: {};
  Mutex: Omit<Mutex, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  MutexAddInput: MutexAddInput;
  Narrative: BasicStoreEntityNarrative;
  NarrativeAddInput: NarrativeAddInput;
  NarrativeConnection: Omit<NarrativeConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['NarrativeEdge']>>> };
  NarrativeEdge: Omit<NarrativeEdge, 'node'> & { node: ResolversParentTypes['Narrative'] };
  NarrativesFiltering: NarrativesFiltering;
  NetworkTraffic: Omit<NetworkTraffic, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  NetworkTrafficAddInput: NetworkTrafficAddInput;
  Note: Omit<Note, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, relatedContainers?: Maybe<ResolversParentTypes['ContainerConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  NoteAddInput: NoteAddInput;
  NoteConnection: Omit<NoteConnection, 'edges'> & { edges: Array<ResolversParentTypes['NoteEdge']> };
  NoteEdge: Omit<NoteEdge, 'node'> & { node: ResolversParentTypes['Note'] };
  NoteEditMutations: Omit<NoteEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Note']>, contextPatch?: Maybe<ResolversParentTypes['Note']>, fieldPatch?: Maybe<ResolversParentTypes['Note']>, relationDelete?: Maybe<ResolversParentTypes['Note']> };
  NoteUserAddInput: NoteUserAddInput;
  NotesFiltering: NotesFiltering;
  Number: Number;
  ObjectTotals: ObjectTotals;
  ObservedData: Omit<ObservedData, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, relatedContainers?: Maybe<ResolversParentTypes['ContainerConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  ObservedDataAddInput: ObservedDataAddInput;
  ObservedDataConnection: Omit<ObservedDataConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ObservedDataEdge']>>> };
  ObservedDataEdge: Omit<ObservedDataEdge, 'node'> & { node: ResolversParentTypes['ObservedData'] };
  ObservedDataEditMutations: Omit<ObservedDataEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['ObservedData']>, contextPatch?: Maybe<ResolversParentTypes['ObservedData']>, fieldPatch?: Maybe<ResolversParentTypes['ObservedData']>, relationDelete?: Maybe<ResolversParentTypes['ObservedData']> };
  ObservedDatasFiltering: ObservedDatasFiltering;
  Opinion: Omit<Opinion, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, relatedContainers?: Maybe<ResolversParentTypes['ContainerConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  OpinionAddInput: OpinionAddInput;
  OpinionConnection: Omit<OpinionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['OpinionEdge']>>> };
  OpinionEdge: Omit<OpinionEdge, 'node'> & { node: ResolversParentTypes['Opinion'] };
  OpinionEditMutations: Omit<OpinionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Opinion']>, contextPatch?: Maybe<ResolversParentTypes['Opinion']>, fieldPatch?: Maybe<ResolversParentTypes['Opinion']>, relationDelete?: Maybe<ResolversParentTypes['Opinion']> };
  OpinionsFiltering: OpinionsFiltering;
  Organization: Omit<Organization, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'sectors' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, sectors?: Maybe<ResolversParentTypes['SectorConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  OrganizationAddInput: OrganizationAddInput;
  OrganizationConnection: Omit<OrganizationConnection, 'edges'> & { edges: Array<ResolversParentTypes['OrganizationEdge']> };
  OrganizationEdge: Omit<OrganizationEdge, 'node'> & { node: ResolversParentTypes['Organization'] };
  OrganizationEditMutations: Omit<OrganizationEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Organization']>, contextPatch?: Maybe<ResolversParentTypes['Organization']>, fieldPatch?: Maybe<ResolversParentTypes['Organization']>, relationDelete?: Maybe<ResolversParentTypes['Organization']> };
  OrganizationOrIndividual: ResolversParentTypes['Individual'] | ResolversParentTypes['Organization'];
  OrganizationsFiltering: OrganizationsFiltering;
  OtpElement: OtpElement;
  OverviewMetrics: OverviewMetrics;
  PageInfo: PageInfo;
  PaymentCard: Omit<PaymentCard, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  PaymentCardAddInput: PaymentCardAddInput;
  PhoneNumber: Omit<PhoneNumber, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  PhoneNumberAddInput: PhoneNumberAddInput;
  Position: Omit<Position, 'cases' | 'city' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, city?: Maybe<ResolversParentTypes['City']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  PositionAddInput: PositionAddInput;
  PositionConnection: Omit<PositionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['PositionEdge']>>> };
  PositionEdge: Omit<PositionEdge, 'node'> & { node: ResolversParentTypes['Position'] };
  PositionEditMutations: Omit<PositionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Position']>, contextPatch?: Maybe<ResolversParentTypes['Position']>, fieldPatch?: Maybe<ResolversParentTypes['Position']>, relationDelete?: Maybe<ResolversParentTypes['Position']> };
  PositionsFiltering: PositionsFiltering;
  Process: Omit<Process, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'serviceDlls' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, serviceDlls?: Maybe<ResolversParentTypes['StixFileConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  ProcessAddInput: ProcessAddInput;
  Provider: Provider;
  Query: {};
  QueryTask: QueryTask;
  QueryTaskAddInput: QueryTaskAddInput;
  QueueArguments: QueueArguments;
  QueueMetrics: QueueMetrics;
  QueueTotals: QueueTotals;
  RabbitMQConnection: RabbitMqConnection;
  RabbitMQMetrics: RabbitMqMetrics;
  Region: Omit<Region, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentRegions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subRegions'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, countries?: Maybe<ResolversParentTypes['CountryConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, parentRegions?: Maybe<ResolversParentTypes['RegionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, subRegions?: Maybe<ResolversParentTypes['RegionConnection']> };
  RegionAddInput: RegionAddInput;
  RegionConnection: Omit<RegionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['RegionEdge']>>> };
  RegionEdge: Omit<RegionEdge, 'node'> & { node: ResolversParentTypes['Region'] };
  RegionEditMutations: Omit<RegionEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Region']>, contextPatch?: Maybe<ResolversParentTypes['Region']>, fieldPatch?: Maybe<ResolversParentTypes['Region']>, relationDelete?: Maybe<ResolversParentTypes['Region']> };
  RegionsFiltering: RegionsFiltering;
  RegisterConnectorInput: RegisterConnectorInput;
  Report: Omit<Report, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'relatedContainers' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, relatedContainers?: Maybe<ResolversParentTypes['ContainerConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  ReportAddInput: ReportAddInput;
  ReportConnection: Omit<ReportConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ReportEdge']>>> };
  ReportEdge: Omit<ReportEdge, 'node'> & { node: ResolversParentTypes['Report'] };
  ReportEditMutations: Omit<ReportEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Report']>, contextPatch?: Maybe<ResolversParentTypes['Report']>, fieldPatch?: Maybe<ResolversParentTypes['Report']>, relationDelete?: Maybe<ResolversParentTypes['Report']> };
  ReportsFiltering: ReportsFiltering;
  RetentionRule: RetentionRule;
  RetentionRuleAddInput: RetentionRuleAddInput;
  RetentionRuleConnection: RetentionRuleConnection;
  RetentionRuleEdge: RetentionRuleEdge;
  RetentionRuleEditMutations: RetentionRuleEditMutations;
  Role: Role;
  RoleAddInput: RoleAddInput;
  RoleConnection: RoleConnection;
  RoleEdge: RoleEdge;
  RoleEditMutations: RoleEditMutations;
  Rule: Rule;
  RuleExecutionError: RuleExecutionError;
  RuleManager: RuleManager;
  RuleTask: RuleTask;
  SearchMetrics: SearchMetrics;
  Sector: Omit<Sector, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'parentSectors' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'subSectors' | 'targetedOrganizations'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, parentSectors?: Maybe<ResolversParentTypes['SectorConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, subSectors?: Maybe<ResolversParentTypes['SectorConnection']>, targetedOrganizations?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  SectorAddInput: SectorAddInput;
  SectorConnection: Omit<SectorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['SectorEdge']>>> };
  SectorEdge: Omit<SectorEdge, 'node'> & { node: ResolversParentTypes['Sector'] };
  SectorEditMutations: Omit<SectorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Sector']>, contextPatch?: Maybe<ResolversParentTypes['Sector']>, fieldPatch?: Maybe<ResolversParentTypes['Sector']>, relationDelete?: Maybe<ResolversParentTypes['Sector']> };
  SectorsFiltering: SectorsFiltering;
  SessionDetail: SessionDetail;
  Settings: Omit<Settings, 'platform_organization'> & { platform_organization?: Maybe<ResolversParentTypes['Organization']> };
  SettingsEditMutations: Omit<SettingsEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch'> & { contextClean?: Maybe<ResolversParentTypes['Settings']>, contextPatch?: Maybe<ResolversParentTypes['Settings']>, fieldPatch?: Maybe<ResolversParentTypes['Settings']> };
  Software: Omit<Software, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships' | 'vulnerabilities'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']>, vulnerabilities?: Maybe<ResolversParentTypes['VulnerabilityConnection']> };
  SoftwareAddInput: SoftwareAddInput;
  Status: Status;
  StatusAddInput: StatusAddInput;
  StatusConnection: StatusConnection;
  StatusEdge: StatusEdge;
  StatusTemplate: StatusTemplate;
  StatusTemplateAddInput: StatusTemplateAddInput;
  StatusTemplateConnection: StatusTemplateConnection;
  StatusTemplateEdge: StatusTemplateEdge;
  StatusesFiltering: StatusesFiltering;
  StixCoreObject: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Event'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['Language'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  StixCoreObjectConnection: Omit<StixCoreObjectConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixCoreObjectEdge']>>> };
  StixCoreObjectEdge: Omit<StixCoreObjectEdge, 'node'> & { node: ResolversParentTypes['StixCoreObject'] };
  StixCoreObjectEditMutations: Omit<StixCoreObjectEditMutations, 'askEnrichment' | 'exportAsk' | 'importPush' | 'relationDelete' | 'relationsAdd' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { askEnrichment?: Maybe<ResolversParentTypes['Work']>, exportAsk?: Maybe<Array<Maybe<ResolversParentTypes['File']>>>, importPush?: Maybe<ResolversParentTypes['File']>, relationDelete?: Maybe<ResolversParentTypes['StixCoreObject']>, relationsAdd?: Maybe<ResolversParentTypes['StixCoreObject']>, restrictionOrganizationAdd?: Maybe<ResolversParentTypes['StixCoreObject']>, restrictionOrganizationDelete?: Maybe<ResolversParentTypes['StixCoreObject']> };
  StixCoreObjectOrStixCoreRelationship: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['EntitySetting'] | ResolversParentTypes['Event'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['Language'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  StixCoreObjectsDistributionParameters: StixCoreObjectsDistributionParameters;
  StixCoreObjectsFiltering: StixCoreObjectsFiltering;
  StixCoreObjectsNumberParameters: StixCoreObjectsNumberParameters;
  StixCoreObjectsTimeSeriesParameters: StixCoreObjectsTimeSeriesParameters;
  StixCoreRelationship: Omit<StixCoreRelationship, 'cases' | 'createdBy' | 'externalReferences' | 'from' | 'groupings' | 'notes' | 'objectOrganization' | 'opinions' | 'reports' | 'stixCoreRelationships' | 'to'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixCoreRelationshipAddInput: StixCoreRelationshipAddInput;
  StixCoreRelationshipConnection: Omit<StixCoreRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixCoreRelationshipEdge']>>> };
  StixCoreRelationshipEdge: Omit<StixCoreRelationshipEdge, 'node'> & { node: ResolversParentTypes['StixCoreRelationship'] };
  StixCoreRelationshipEditMutations: Omit<StixCoreRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { contextClean?: Maybe<ResolversParentTypes['StixCoreRelationship']>, contextPatch?: Maybe<ResolversParentTypes['StixCoreRelationship']>, fieldPatch?: Maybe<ResolversParentTypes['StixCoreRelationship']>, relationDelete?: Maybe<ResolversParentTypes['StixCoreRelationship']>, restrictionOrganizationAdd?: Maybe<ResolversParentTypes['StixCoreRelationship']>, restrictionOrganizationDelete?: Maybe<ResolversParentTypes['StixCoreRelationship']> };
  StixCoreRelationshipsDistributionParameters: StixCoreRelationshipsDistributionParameters;
  StixCoreRelationshipsFiltering: StixCoreRelationshipsFiltering;
  StixCoreRelationshipsTimeSeriesParameters: StixCoreRelationshipsTimeSeriesParameters;
  StixCyberObservable: ResolversParentTypes['Artifact'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Process'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['Text'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  StixCyberObservableConnection: Omit<StixCyberObservableConnection, 'edges'> & { edges: Array<ResolversParentTypes['StixCyberObservableEdge']> };
  StixCyberObservableEdge: Omit<StixCyberObservableEdge, 'node'> & { node: ResolversParentTypes['StixCyberObservable'] };
  StixCyberObservableEditMutations: Omit<StixCyberObservableEditMutations, 'contextClean' | 'contextPatch' | 'exportAsk' | 'fieldPatch' | 'importPush' | 'promote' | 'relationDelete' | 'relationsAdd'> & { contextClean?: Maybe<ResolversParentTypes['StixCyberObservable']>, contextPatch?: Maybe<ResolversParentTypes['StixCyberObservable']>, exportAsk?: Maybe<Array<Maybe<ResolversParentTypes['File']>>>, fieldPatch?: Maybe<ResolversParentTypes['StixCyberObservable']>, importPush?: Maybe<ResolversParentTypes['File']>, promote?: Maybe<ResolversParentTypes['StixCyberObservable']>, relationDelete?: Maybe<ResolversParentTypes['StixCyberObservable']>, relationsAdd?: Maybe<ResolversParentTypes['StixCyberObservable']> };
  StixCyberObservableRelationship: Omit<StixCyberObservableRelationship, 'cases' | 'from' | 'groupings' | 'notes' | 'opinions' | 'reports' | 'to'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixCyberObservableRelationshipAddInput: StixCyberObservableRelationshipAddInput;
  StixCyberObservableRelationshipConnection: Omit<StixCyberObservableRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixCyberObservableRelationshipEdge']>>> };
  StixCyberObservableRelationshipEdge: Omit<StixCyberObservableRelationshipEdge, 'node'> & { node: ResolversParentTypes['StixCyberObservableRelationship'] };
  StixCyberObservableRelationshipEditMutations: Omit<StixCyberObservableRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch'> & { contextClean?: Maybe<ResolversParentTypes['StixCyberObservableRelationship']>, contextPatch?: Maybe<ResolversParentTypes['StixCyberObservableRelationship']>, fieldPatch?: Maybe<ResolversParentTypes['StixCyberObservableRelationship']> };
  StixCyberObservableRelationshipsFiltering: StixCyberObservableRelationshipsFiltering;
  StixCyberObservablesFiltering: StixCyberObservablesFiltering;
  StixDomainObject: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Event'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['Language'] | ResolversParentTypes['Malware'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['System'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Vulnerability'];
  StixDomainObjectAddInput: StixDomainObjectAddInput;
  StixDomainObjectConnection: Omit<StixDomainObjectConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixDomainObjectEdge']>>> };
  StixDomainObjectEdge: Omit<StixDomainObjectEdge, 'node'> & { node: ResolversParentTypes['StixDomainObject'] };
  StixDomainObjectEditMutations: Omit<StixDomainObjectEditMutations, 'changeType' | 'contextClean' | 'contextPatch' | 'exportAsk' | 'fieldPatch' | 'importPush' | 'relationDelete' | 'relationsAdd'> & { changeType?: Maybe<ResolversParentTypes['StixDomainObject']>, contextClean?: Maybe<ResolversParentTypes['StixDomainObject']>, contextPatch?: Maybe<ResolversParentTypes['StixDomainObject']>, exportAsk?: Maybe<Array<Maybe<ResolversParentTypes['File']>>>, fieldPatch?: Maybe<ResolversParentTypes['StixDomainObject']>, importPush?: Maybe<ResolversParentTypes['File']>, relationDelete?: Maybe<ResolversParentTypes['StixDomainObject']>, relationsAdd?: Maybe<ResolversParentTypes['StixDomainObject']> };
  StixDomainObjectsFiltering: StixDomainObjectsFiltering;
  StixEditMutations: StixEditMutations;
  StixFile: Omit<StixFile, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'obsContent' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, obsContent?: Maybe<ResolversParentTypes['Artifact']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  StixFileAddInput: StixFileAddInput;
  StixFileConnection: Omit<StixFileConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixFileEdge']>>> };
  StixFileEdge: Omit<StixFileEdge, 'node'> & { node: ResolversParentTypes['StixFile'] };
  StixId: Scalars['StixId'];
  StixMetaObject: ResolversParentTypes['ExternalReference'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['Vocabulary'];
  StixMetaRelationship: Omit<StixMetaRelationship, 'from' | 'to'> & { from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixMetaRelationshipAddInput: StixMetaRelationshipAddInput;
  StixMetaRelationshipConnection: StixMetaRelationshipConnection;
  StixMetaRelationshipEdge: StixMetaRelationshipEdge;
  StixMetaRelationshipsAddInput: StixMetaRelationshipsAddInput;
  StixMetaRelationshipsFiltering: StixMetaRelationshipsFiltering;
  StixObject: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['Language'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vocabulary'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  StixObjectOrStixRelationship: ResolversParentTypes['AdministrativeArea'] | ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['BankAccount'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Case'] | ResolversParentTypes['Channel'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['DataComponent'] | ResolversParentTypes['DataSource'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['EntitySetting'] | ResolversParentTypes['Event'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Grouping'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['Language'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['MediaContent'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['Narrative'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['PaymentCard'] | ResolversParentTypes['PhoneNumber'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'];
  StixObjectOrStixRelationshipConnection: StixObjectOrStixRelationshipConnection;
  StixObjectOrStixRelationshipEdge: Omit<StixObjectOrStixRelationshipEdge, 'node'> & { node: ResolversParentTypes['StixObjectOrStixRelationship'] };
  StixObjectOrStixRelationshipRefConnection: StixObjectOrStixRelationshipRefConnection;
  StixObjectOrStixRelationshipRefEdge: Omit<StixObjectOrStixRelationshipRefEdge, 'node'> & { node: ResolversParentTypes['StixObjectOrStixRelationship'] };
  StixObjectOrStixRelationshipsFiltering: StixObjectOrStixRelationshipsFiltering;
  StixRef: Scalars['StixRef'];
  StixRelationship: ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'];
  StixRelationshipConnection: StixRelationshipConnection;
  StixRelationshipEdge: StixRelationshipEdge;
  StixRelationshipEditMutations: StixRelationshipEditMutations;
  StixRelationshipsFiltering: StixRelationshipsFiltering;
  StixSightingRelationship: Omit<StixSightingRelationship, 'cases' | 'createdBy' | 'externalReferences' | 'from' | 'groupings' | 'notes' | 'objectOrganization' | 'opinions' | 'reports' | 'to'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixSightingRelationshipAddInput: StixSightingRelationshipAddInput;
  StixSightingRelationshipConnection: Omit<StixSightingRelationshipConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StixSightingRelationshipsEdge']>>> };
  StixSightingRelationshipEditMutations: Omit<StixSightingRelationshipEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'restrictionOrganizationAdd' | 'restrictionOrganizationDelete'> & { contextClean?: Maybe<ResolversParentTypes['StixSightingRelationship']>, contextPatch?: Maybe<ResolversParentTypes['StixSightingRelationship']>, fieldPatch?: Maybe<ResolversParentTypes['StixSightingRelationship']>, relationDelete?: Maybe<ResolversParentTypes['StixSightingRelationship']>, restrictionOrganizationAdd?: Maybe<ResolversParentTypes['StixSightingRelationship']>, restrictionOrganizationDelete?: Maybe<ResolversParentTypes['StixSightingRelationship']> };
  StixSightingRelationshipsEdge: Omit<StixSightingRelationshipsEdge, 'node'> & { node: ResolversParentTypes['StixSightingRelationship'] };
  StixSightingRelationshipsFiltering: StixSightingRelationshipsFiltering;
  StreamCollection: Omit<StreamCollection, 'groups'> & { groups?: Maybe<Array<Maybe<ResolversParentTypes['Group']>>> };
  StreamCollectionAddInput: StreamCollectionAddInput;
  StreamCollectionConnection: Omit<StreamCollectionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['StreamCollectionEdge']>>> };
  StreamCollectionEdge: Omit<StreamCollectionEdge, 'node'> & { node: ResolversParentTypes['StreamCollection'] };
  StreamCollectionEditMutations: Omit<StreamCollectionEditMutations, 'addGroup' | 'deleteGroup' | 'fieldPatch'> & { addGroup?: Maybe<ResolversParentTypes['StreamCollection']>, deleteGroup?: Maybe<ResolversParentTypes['StreamCollection']>, fieldPatch?: Maybe<ResolversParentTypes['StreamCollection']> };
  String: Scalars['String'];
  SubType: Omit<SubType, 'settings'> & { settings?: Maybe<ResolversParentTypes['EntitySetting']> };
  SubTypeConnection: Omit<SubTypeConnection, 'edges'> & { edges: Array<ResolversParentTypes['SubTypeEdge']> };
  SubTypeEdge: Omit<SubTypeEdge, 'node'> & { node: ResolversParentTypes['SubType'] };
  SubTypeEditMutations: Omit<SubTypeEditMutations, 'statusAdd' | 'statusDelete' | 'statusFieldPatch'> & { statusAdd?: Maybe<ResolversParentTypes['SubType']>, statusDelete?: Maybe<ResolversParentTypes['SubType']>, statusFieldPatch?: Maybe<ResolversParentTypes['SubType']> };
  Subscription: {};
  Synchronizer: Omit<Synchronizer, 'user'> & { user?: Maybe<ResolversParentTypes['User']> };
  SynchronizerAddInput: SynchronizerAddInput;
  SynchronizerConnection: Omit<SynchronizerConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['SynchronizerEdge']>>> };
  SynchronizerEdge: Omit<SynchronizerEdge, 'node'> & { node: ResolversParentTypes['Synchronizer'] };
  SynchronizerEditMutations: Omit<SynchronizerEditMutations, 'fieldPatch'> & { fieldPatch?: Maybe<ResolversParentTypes['Synchronizer']> };
  System: Omit<System, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'organizations' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, organizations?: Maybe<ResolversParentTypes['OrganizationConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  SystemAddInput: SystemAddInput;
  SystemConnection: Omit<SystemConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['SystemEdge']>>> };
  SystemEdge: Omit<SystemEdge, 'node'> & { node: ResolversParentTypes['System'] };
  SystemEditMutations: Omit<SystemEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['System']>, contextPatch?: Maybe<ResolversParentTypes['System']>, fieldPatch?: Maybe<ResolversParentTypes['System']>, relationDelete?: Maybe<ResolversParentTypes['System']> };
  SystemsFiltering: SystemsFiltering;
  Task: ResolversParentTypes['ListTask'] | ResolversParentTypes['QueryTask'] | ResolversParentTypes['RuleTask'];
  TaskAction: TaskAction;
  TaskActionInput: TaskActionInput;
  TaskConnection: TaskConnection;
  TaskConnectionEdge: TaskConnectionEdge;
  TaskContext: TaskContext;
  TaskContextInput: TaskContextInput;
  TaskError: TaskError;
  TasksFiltering: TasksFiltering;
  TaxiiCollection: TaxiiCollection;
  TaxiiCollectionAddInput: TaxiiCollectionAddInput;
  TaxiiCollectionConnection: TaxiiCollectionConnection;
  TaxiiCollectionEdge: TaxiiCollectionEdge;
  TaxiiCollectionEditMutations: TaxiiCollectionEditMutations;
  Text: Omit<Text, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  TextAddInput: TextAddInput;
  ThreatActor: Omit<ThreatActor, 'cases' | 'connectors' | 'countries' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'locations' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, countries?: Maybe<ResolversParentTypes['CountryConnection']>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, locations?: Maybe<ResolversParentTypes['LocationConnection']>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  ThreatActorAddInput: ThreatActorAddInput;
  ThreatActorConnection: Omit<ThreatActorConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ThreatActorEdge']>>> };
  ThreatActorEdge: Omit<ThreatActorEdge, 'node'> & { node: ResolversParentTypes['ThreatActor'] };
  ThreatActorEditMutations: Omit<ThreatActorEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['ThreatActor']>, contextPatch?: Maybe<ResolversParentTypes['ThreatActor']>, fieldPatch?: Maybe<ResolversParentTypes['ThreatActor']>, relationDelete?: Maybe<ResolversParentTypes['ThreatActor']> };
  ThreatActorsFiltering: ThreatActorsFiltering;
  TimeSeries: TimeSeries;
  Tool: Omit<Tool, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  ToolAddInput: ToolAddInput;
  ToolConnection: Omit<ToolConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['ToolEdge']>>> };
  ToolEdge: Omit<ToolEdge, 'node'> & { node: ResolversParentTypes['Tool'] };
  ToolEditMutations: Omit<ToolEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Tool']>, contextPatch?: Maybe<ResolversParentTypes['Tool']>, fieldPatch?: Maybe<ResolversParentTypes['Tool']>, relationDelete?: Maybe<ResolversParentTypes['Tool']> };
  ToolsFiltering: ToolsFiltering;
  Upload: Scalars['Upload'];
  Url: Omit<Url, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  UrlAddInput: UrlAddInput;
  User: Omit<User, 'groups' | 'objectOrganization' | 'userSubscriptions'> & { groups?: Maybe<ResolversParentTypes['GroupConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, userSubscriptions?: Maybe<ResolversParentTypes['UserSubscriptionConnection']> };
  UserAccount: Omit<UserAccount, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  UserAccountAddInput: UserAccountAddInput;
  UserAddInput: UserAddInput;
  UserAgent: Omit<UserAgent, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  UserAgentAddInput: UserAgentAddInput;
  UserConnection: Omit<UserConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['UserEdge']>>> };
  UserEdge: Omit<UserEdge, 'node'> & { node: ResolversParentTypes['User'] };
  UserEditMutations: Omit<UserEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'organizationAdd' | 'organizationDelete' | 'relationDelete' | 'tokenRenew'> & { contextClean?: Maybe<ResolversParentTypes['User']>, contextPatch?: Maybe<ResolversParentTypes['User']>, fieldPatch?: Maybe<ResolversParentTypes['User']>, organizationAdd?: Maybe<ResolversParentTypes['User']>, organizationDelete?: Maybe<ResolversParentTypes['User']>, relationDelete?: Maybe<ResolversParentTypes['User']>, tokenRenew?: Maybe<ResolversParentTypes['User']> };
  UserLoginInput: UserLoginInput;
  UserOTPActivationInput: UserOtpActivationInput;
  UserOTPLoginInput: UserOtpLoginInput;
  UserSession: Omit<UserSession, 'user'> & { user?: Maybe<ResolversParentTypes['User']> };
  UserSubscription: Omit<UserSubscription, 'entities' | 'user'> & { entities?: Maybe<Array<Maybe<ResolversParentTypes['StixDomainObject']>>>, user?: Maybe<ResolversParentTypes['User']> };
  UserSubscriptionAddInput: UserSubscriptionAddInput;
  UserSubscriptionConnection: Omit<UserSubscriptionConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['UserSubscriptionEdge']>>> };
  UserSubscriptionEdge: Omit<UserSubscriptionEdge, 'node'> & { node: ResolversParentTypes['UserSubscription'] };
  UserSubscriptionEditMutations: Omit<UserSubscriptionEditMutations, 'fieldPatch'> & { fieldPatch?: Maybe<ResolversParentTypes['UserSubscription']> };
  UsersFiltering: UsersFiltering;
  Vocabulary: BasicStoreEntityVocabulary;
  VocabularyAddInput: VocabularyAddInput;
  VocabularyConnection: Omit<VocabularyConnection, 'edges'> & { edges: Array<ResolversParentTypes['VocabularyEdge']> };
  VocabularyDefinition: VocabularyDefinition;
  VocabularyEdge: Omit<VocabularyEdge, 'node'> & { node: ResolversParentTypes['Vocabulary'] };
  VocabularyFieldDefinition: VocabularyFieldDefinition;
  VocabularyFiltering: VocabularyFiltering;
  VulnerabilitiesFiltering: VulnerabilitiesFiltering;
  Vulnerability: Omit<Vulnerability, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'softwares' | 'stixCoreRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, softwares?: Maybe<ResolversParentTypes['StixCyberObservableConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']> };
  VulnerabilityAddInput: VulnerabilityAddInput;
  VulnerabilityConnection: Omit<VulnerabilityConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['VulnerabilityEdge']>>> };
  VulnerabilityEdge: Omit<VulnerabilityEdge, 'node'> & { node: ResolversParentTypes['Vulnerability'] };
  VulnerabilityEditMutations: Omit<VulnerabilityEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete'> & { contextClean?: Maybe<ResolversParentTypes['Vulnerability']>, contextPatch?: Maybe<ResolversParentTypes['Vulnerability']>, fieldPatch?: Maybe<ResolversParentTypes['Vulnerability']>, relationDelete?: Maybe<ResolversParentTypes['Vulnerability']> };
  WindowsRegistryKey: Omit<WindowsRegistryKey, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  WindowsRegistryKeyAddInput: WindowsRegistryKeyAddInput;
  WindowsRegistryValueType: Omit<WindowsRegistryValueType, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  WindowsRegistryValueTypeAddInput: WindowsRegistryValueTypeAddInput;
  Work: Omit<Work, 'connector' | 'user'> & { connector?: Maybe<ResolversParentTypes['Connector']>, user?: Maybe<ResolversParentTypes['User']> };
  WorkConnection: Omit<WorkConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['WorkEdge']>>> };
  WorkEdge: Omit<WorkEdge, 'node'> & { node: ResolversParentTypes['Work'] };
  WorkEditMutations: WorkEditMutations;
  WorkErrorInput: WorkErrorInput;
  WorkMessage: WorkMessage;
  WorkTracking: WorkTracking;
  WorksFiltering: WorksFiltering;
  Workspace: Omit<Workspace, 'owner'> & { owner?: Maybe<ResolversParentTypes['User']> };
  WorkspaceAddInput: WorkspaceAddInput;
  WorkspaceConnection: Omit<WorkspaceConnection, 'edges'> & { edges?: Maybe<Array<Maybe<ResolversParentTypes['WorkspaceEdge']>>> };
  WorkspaceEdge: Omit<WorkspaceEdge, 'node'> & { node: ResolversParentTypes['Workspace'] };
  WorkspaceEditMutations: Omit<WorkspaceEditMutations, 'contextClean' | 'contextPatch' | 'fieldPatch' | 'relationDelete' | 'relationsAdd' | 'relationsDelete'> & { contextClean?: Maybe<ResolversParentTypes['Workspace']>, contextPatch?: Maybe<ResolversParentTypes['Workspace']>, fieldPatch?: Maybe<ResolversParentTypes['Workspace']>, relationDelete?: Maybe<ResolversParentTypes['Workspace']>, relationsAdd?: Maybe<ResolversParentTypes['Workspace']>, relationsDelete?: Maybe<ResolversParentTypes['Workspace']> };
  WorkspacesFiltering: WorkspacesFiltering;
  X509Certificate: Omit<X509Certificate, 'cases' | 'connectors' | 'createdBy' | 'exportFiles' | 'externalReferences' | 'groupings' | 'importFiles' | 'indicators' | 'jobs' | 'notes' | 'objectOrganization' | 'observedData' | 'opinions' | 'pendingFiles' | 'reports' | 'stixCoreRelationships' | 'stixCyberObservableRelationships'> & { cases?: Maybe<ResolversParentTypes['CaseConnection']>, connectors?: Maybe<Array<Maybe<ResolversParentTypes['Connector']>>>, createdBy?: Maybe<ResolversParentTypes['Identity']>, exportFiles?: Maybe<ResolversParentTypes['FileConnection']>, externalReferences?: Maybe<ResolversParentTypes['ExternalReferenceConnection']>, groupings?: Maybe<ResolversParentTypes['GroupingConnection']>, importFiles?: Maybe<ResolversParentTypes['FileConnection']>, indicators?: Maybe<ResolversParentTypes['IndicatorConnection']>, jobs?: Maybe<Array<Maybe<ResolversParentTypes['Work']>>>, notes?: Maybe<ResolversParentTypes['NoteConnection']>, objectOrganization?: Maybe<ResolversParentTypes['OrganizationConnection']>, observedData?: Maybe<ResolversParentTypes['ObservedDataConnection']>, opinions?: Maybe<ResolversParentTypes['OpinionConnection']>, pendingFiles?: Maybe<ResolversParentTypes['FileConnection']>, reports?: Maybe<ResolversParentTypes['ReportConnection']>, stixCoreRelationships?: Maybe<ResolversParentTypes['StixCoreRelationshipConnection']>, stixCyberObservableRelationships?: Maybe<ResolversParentTypes['StixCyberObservableRelationshipConnection']> };
  X509CertificateAddInput: X509CertificateAddInput;
}>;

export type AuthDirectiveArgs = {
  and?: Maybe<Scalars['Boolean']>;
  for?: Maybe<Array<Maybe<Capabilities>>>;
};

export type AuthDirectiveResolver<Result, Parent, ContextType = any, Args = AuthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type ConstraintDirectiveArgs = {
  endsWith?: Maybe<Scalars['String']>;
  exclusiveMax?: Maybe<Scalars['Int']>;
  exclusiveMin?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
  max?: Maybe<Scalars['Int']>;
  maxLength?: Maybe<Scalars['Int']>;
  min?: Maybe<Scalars['Int']>;
  minLength?: Maybe<Scalars['Int']>;
  multipleOf?: Maybe<Scalars['Int']>;
  notContains?: Maybe<Scalars['String']>;
  pattern?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
};

export type ConstraintDirectiveResolver<Result, Parent, ContextType = any, Args = ConstraintDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AckDetailsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AckDetails'] = ResolversParentTypes['AckDetails']> = ResolversObject<{
  rate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdministrativeAreaResolvers<ContextType = any, ParentType extends ResolversParentTypes['AdministrativeArea'] = ResolversParentTypes['AdministrativeArea']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<AdministrativeAreaCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<AdministrativeAreaConnectorsArgs>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AdministrativeAreaExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<AdministrativeAreaExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<AdministrativeAreaGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AdministrativeAreaImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<AdministrativeAreaJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<AdministrativeAreaNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<AdministrativeAreaObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<AdministrativeAreaOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AdministrativeAreaPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<AdministrativeAreaReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AdministrativeAreaStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<AdministrativeAreaStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AdministrativeAreaStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdministrativeAreaConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AdministrativeAreaConnection'] = ResolversParentTypes['AdministrativeAreaConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<ResolversTypes['AdministrativeAreaEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AdministrativeAreaEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AdministrativeAreaEdge'] = ResolversParentTypes['AdministrativeAreaEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AdministrativeArea'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppDebugDistributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDebugDistribution'] = ResolversParentTypes['AppDebugDistribution']> = ResolversObject<{
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppDebugStatisticsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDebugStatistics'] = ResolversParentTypes['AppDebugStatistics']> = ResolversObject<{
  objects?: Resolver<Maybe<Array<Maybe<ResolversTypes['AppDebugDistribution']>>>, ParentType, ContextType>;
  relationships?: Resolver<Maybe<Array<Maybe<ResolversTypes['AppDebugDistribution']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppInfo'] = ResolversParentTypes['AppInfo']> = ResolversObject<{
  debugStats?: Resolver<Maybe<ResolversTypes['AppDebugStatistics']>, ParentType, ContextType>;
  dependencies?: Resolver<Array<ResolversTypes['DependencyVersion']>, ParentType, ContextType>;
  memory?: Resolver<Maybe<ResolversTypes['AppMemory']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AppMemoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppMemory'] = ResolversParentTypes['AppMemory']> = ResolversObject<{
  arrayBuffers?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  does_zap_garbage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heapTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heapUsed?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heap_size_limit?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  malloced_memory?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  peak_malloced_memory?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  rss?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_available_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_heap_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_heap_size_executable?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_physical_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  used_heap_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ArtifactResolvers<ContextType = any, ParentType extends ResolversParentTypes['Artifact'] = ResolversParentTypes['Artifact']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ArtifactCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ArtifactConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  decryption_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  encryption_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ArtifactExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ArtifactGroupingsArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<ArtifactIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ArtifactJobsArgs>>;
  mime_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ArtifactNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ArtifactObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ArtifactOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  payload_bin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ArtifactReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ArtifactStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ArtifactStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ArtifactStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<ArtifactStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_additional_names?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AssigneeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Assignee'] = ResolversParentTypes['Assignee']> = ResolversObject<{
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user_email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AssigneeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssigneeConnection'] = ResolversParentTypes['AssigneeConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['AssigneeEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AssigneeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssigneeEdge'] = ResolversParentTypes['AssigneeEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Assignee'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttackPatternResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPattern'] = ResolversParentTypes['AttackPattern']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<AttackPatternCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<AttackPatternConnectorsArgs>>;
  coursesOfAction?: Resolver<Maybe<ResolversTypes['CourseOfActionConnection']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  dataComponents?: Resolver<Maybe<ResolversTypes['DataComponentConnection']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<AttackPatternExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<AttackPatternGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternImportFilesArgs>>;
  isSubAttackPattern?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<AttackPatternJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<AttackPatternNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<AttackPatternObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<AttackPatternOpinionsArgs>>;
  parentAttackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<AttackPatternReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AttackPatternStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<AttackPatternStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AttackPatternStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  subAttackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_detection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_mitre_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_mitre_permissions_required?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_mitre_platforms?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttackPatternConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternConnection'] = ResolversParentTypes['AttackPatternConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['AttackPatternEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttackPatternEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternEdge'] = ResolversParentTypes['AttackPatternEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AttackPattern'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttackPatternEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternEditMutations'] = ResolversParentTypes['AttackPatternEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<AttackPatternEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, RequireFields<AttackPatternEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<AttackPatternEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, RequireFields<AttackPatternEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attribute'] = ResolversParentTypes['Attribute']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeConnection'] = ResolversParentTypes['AttributeConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['AttributeEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeEdge'] = ResolversParentTypes['AttributeEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Attribute'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AttributeEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeEditMutations'] = ResolversParentTypes['AttributeEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType, RequireFields<AttributeEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AutonomousSystemResolvers<ContextType = any, ParentType extends ResolversParentTypes['AutonomousSystem'] = ResolversParentTypes['AutonomousSystem']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<AutonomousSystemCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<AutonomousSystemConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<AutonomousSystemExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<AutonomousSystemGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<AutonomousSystemIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<AutonomousSystemJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<AutonomousSystemNotesArgs>>;
  number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<AutonomousSystemObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<AutonomousSystemOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<AutonomousSystemReportsArgs>>;
  rir?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AutonomousSystemStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<AutonomousSystemStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<AutonomousSystemStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<AutonomousSystemStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BankAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['BankAccount'] = ResolversParentTypes['BankAccount']> = ResolversObject<{
  account_number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bic?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<BankAccountCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<BankAccountConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<BankAccountExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<BankAccountExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<BankAccountGroupingsArgs>>;
  iban?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<BankAccountImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<BankAccountIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<BankAccountJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<BankAccountNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<BankAccountObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<BankAccountOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<BankAccountPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<BankAccountReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<BankAccountStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<BankAccountStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<BankAccountStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<BankAccountStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BasicObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['BasicObject'] = ResolversParentTypes['BasicObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'BankAccount' | 'Campaign' | 'Capability' | 'Case' | 'Channel' | 'City' | 'Connector' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'DataComponent' | 'DataSource' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'EntitySetting' | 'Event' | 'ExternalReference' | 'Group' | 'Grouping' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'Language' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'MeUser' | 'MediaContent' | 'Mutex' | 'Narrative' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'PaymentCard' | 'PhoneNumber' | 'Position' | 'Process' | 'Region' | 'Report' | 'Role' | 'Sector' | 'Settings' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'User' | 'UserAccount' | 'UserAgent' | 'Vocabulary' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type BasicRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['BasicRelationship'] = ResolversParentTypes['BasicRelationship']> = ResolversObject<{
  __resolveType: TypeResolveFn<'InternalRelationship' | 'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixMetaRelationship' | 'StixSightingRelationship', ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type CampaignResolvers<ContextType = any, ParentType extends ResolversParentTypes['Campaign'] = ResolversParentTypes['Campaign']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CampaignCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CampaignConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CampaignExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CampaignGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CampaignJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CampaignNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objective?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CampaignObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CampaignOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CampaignReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CampaignStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CampaignStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CampaignStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CampaignConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignConnection'] = ResolversParentTypes['CampaignConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CampaignEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CampaignEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignEdge'] = ResolversParentTypes['CampaignEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Campaign'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CampaignEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignEditMutations'] = ResolversParentTypes['CampaignEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<CampaignEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, RequireFields<CampaignEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CampaignEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, RequireFields<CampaignEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CapabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Capability'] = ResolversParentTypes['Capability']> = ResolversObject<{
  attribute_order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CapabilityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CapabilityConnection'] = ResolversParentTypes['CapabilityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CapabilityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CapabilityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CapabilityEdge'] = ResolversParentTypes['CapabilityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Capability'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaseResolvers<ContextType = any, ParentType extends ResolversParentTypes['Case'] = ResolversParentTypes['Case']> = ResolversObject<{
  case_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CaseCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CaseConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CaseExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CaseExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CaseGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CaseImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CaseJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CaseNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<CaseObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CaseObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CaseOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CasePendingFilesArgs>>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<CaseRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CaseReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  severity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CaseStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CaseStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CaseStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaseConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CaseConnection'] = ResolversParentTypes['CaseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CaseEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CaseEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CaseEdge'] = ResolversParentTypes['CaseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Case'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Channel'] = ResolversParentTypes['Channel']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ChannelCasesArgs>>;
  channel_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ChannelConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ChannelExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ChannelExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ChannelGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ChannelImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ChannelJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ChannelNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ChannelObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ChannelOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ChannelPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ChannelReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ChannelStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ChannelStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ChannelStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelConnection'] = ResolversParentTypes['ChannelConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChannelEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ChannelEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelEdge'] = ResolversParentTypes['ChannelEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CityResolvers<ContextType = any, ParentType extends ResolversParentTypes['City'] = ResolversParentTypes['City']> = ResolversObject<{
  administrativeArea?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CityCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CityConnectorsArgs>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CityExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CityGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CityNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CityObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CityStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CityStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CityStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityConnection'] = ResolversParentTypes['CityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityEdge'] = ResolversParentTypes['CityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['City'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityEditMutations'] = ResolversParentTypes['CityEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<CityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<CityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<CityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ClusterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Cluster'] = ResolversParentTypes['Cluster']> = ResolversObject<{
  instances_number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Connector'] = ResolversParentTypes['Connector']> = ResolversObject<{
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  auto?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  config?: Resolver<Maybe<ResolversTypes['ConnectorConfig']>, ParentType, ContextType>;
  connector_scope?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  connector_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connector_state_reset?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  connector_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connector_user_id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  only_contextual?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  works?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ConnectorWorksArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectorConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConnectorConfig'] = ResolversParentTypes['ConnectorConfig']> = ResolversObject<{
  connection?: Resolver<ResolversTypes['RabbitMQConnection'], ParentType, ContextType>;
  listen?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listen_exchange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listen_routing?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  push?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  push_exchange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  push_routing?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface ConstraintNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ConstraintNumber'], any> {
  name: 'ConstraintNumber';
}

export interface ConstraintStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ConstraintString'], any> {
  name: 'ConstraintString';
}

export type ContainerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Container'] = ResolversParentTypes['Container']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Case' | 'Grouping' | 'Note' | 'ObservedData' | 'Opinion' | 'Report', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ContainerCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ContainerExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ContainerGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ContainerNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<ContainerObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ContainerObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ContainerOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ContainerRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ContainerReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ContainerStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ContainerStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ContainerStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type ContainerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerConnection'] = ResolversParentTypes['ContainerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ContainerEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContainerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerEdge'] = ResolversParentTypes['ContainerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Container'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContainerEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerEditMutations'] = ResolversParentTypes['ContainerEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, Partial<ContainerEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, RequireFields<ContainerEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ContainerEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, RequireFields<ContainerEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContextDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContextData'] = ResolversParentTypes['ContextData']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  external_references?: Resolver<Maybe<Array<ResolversTypes['ExternalReference']>>, ParentType, ContextType>;
  from_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Country'] = ResolversParentTypes['Country']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CountryCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CountryConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CountryExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CountryGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CountryJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CountryNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CountryObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CountryOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CountryReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CountryStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CountryStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CountryStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryConnection'] = ResolversParentTypes['CountryConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['CountryEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryEdge'] = ResolversParentTypes['CountryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CountryEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryEditMutations'] = ResolversParentTypes['CountryEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<CountryEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<CountryEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CountryEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<CountryEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CourseOfActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfAction'] = ResolversParentTypes['CourseOfAction']> = ResolversObject<{
  attackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CourseOfActionCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CourseOfActionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CourseOfActionExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CourseOfActionGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CourseOfActionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CourseOfActionNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CourseOfActionObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CourseOfActionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CourseOfActionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CourseOfActionStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CourseOfActionStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CourseOfActionStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_log_sources?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  x_opencti_threat_hunting?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CourseOfActionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionConnection'] = ResolversParentTypes['CourseOfActionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CourseOfActionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CourseOfActionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionEdge'] = ResolversParentTypes['CourseOfActionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CourseOfAction'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CourseOfActionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionEditMutations'] = ResolversParentTypes['CourseOfActionEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<CourseOfActionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, RequireFields<CourseOfActionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CourseOfActionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, RequireFields<CourseOfActionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Creator'] = ResolversParentTypes['Creator']> = ResolversObject<{
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatorConnection'] = ResolversParentTypes['CreatorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CreatorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CreatorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatorEdge'] = ResolversParentTypes['CreatorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Creator'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptocurrencyWalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['CryptocurrencyWallet'] = ResolversParentTypes['CryptocurrencyWallet']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CryptocurrencyWalletConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CryptocurrencyWalletJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CryptocurrencyWalletStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CryptocurrencyWalletStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CryptographicKeyResolvers<ContextType = any, ParentType extends ResolversParentTypes['CryptographicKey'] = ResolversParentTypes['CryptographicKey']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<CryptographicKeyCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CryptographicKeyConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CryptographicKeyExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<CryptographicKeyGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<CryptographicKeyIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CryptographicKeyJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CryptographicKeyNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<CryptographicKeyObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CryptographicKeyOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CryptographicKeyReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CryptographicKeyStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CryptographicKeyStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<CryptographicKeyStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<CryptographicKeyStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataComponentResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataComponent'] = ResolversParentTypes['DataComponent']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  attackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<DataComponentCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DataComponentConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  dataSource?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataComponentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DataComponentExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<DataComponentGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataComponentImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DataComponentJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DataComponentNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<DataComponentObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DataComponentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataComponentPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DataComponentReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DataComponentStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DataComponentStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DataComponentStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataComponentConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataComponentConnection'] = ResolversParentTypes['DataComponentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DataComponentEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataComponentEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataComponentEdge'] = ResolversParentTypes['DataComponentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['DataComponent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataSourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataSource'] = ResolversParentTypes['DataSource']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<DataSourceCasesArgs>>;
  collection_layers?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DataSourceConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  dataComponents?: Resolver<Maybe<ResolversTypes['DataComponentConnection']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataSourceExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DataSourceExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<DataSourceGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataSourceImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DataSourceJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DataSourceNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<DataSourceObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DataSourceOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DataSourcePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DataSourceReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DataSourceStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DataSourceStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DataSourceStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_platforms?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataSourceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataSourceConnection'] = ResolversParentTypes['DataSourceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['DataSourceEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DataSourceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataSourceEdge'] = ResolversParentTypes['DataSourceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['DataSource'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type DependencyVersionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DependencyVersion'] = ResolversParentTypes['DependencyVersion']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DictionaryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Dictionary'] = ResolversParentTypes['Dictionary']> = ResolversObject<{
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DirectoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Directory'] = ResolversParentTypes['Directory']> = ResolversObject<{
  atime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<DirectoryCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DirectoryConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  ctime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DirectoryExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<DirectoryGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<DirectoryIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DirectoryJobsArgs>>;
  mtime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DirectoryNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<DirectoryObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DirectoryOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path_enc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DirectoryReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DirectoryStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DirectoryStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DirectoryStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<DirectoryStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DisplayResolvers<ContextType = any, ParentType extends ResolversParentTypes['Display'] = ResolversParentTypes['Display']> = ResolversObject<{
  if?: Resolver<Maybe<Array<Maybe<ResolversTypes['DisplayStep']>>>, ParentType, ContextType>;
  then?: Resolver<Maybe<Array<Maybe<ResolversTypes['DisplayStep']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DisplayStepResolvers<ContextType = any, ParentType extends ResolversParentTypes['DisplayStep'] = ResolversParentTypes['DisplayStep']> = ResolversObject<{
  action?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier_color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  relation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source_color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  target_color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DistributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Distribution'] = ResolversParentTypes['Distribution']> = ResolversObject<{
  entity?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DocsMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocsMetrics'] = ResolversParentTypes['DocsMetrics']> = ResolversObject<{
  count?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type DomainNameResolvers<ContextType = any, ParentType extends ResolversParentTypes['DomainName'] = ResolversParentTypes['DomainName']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<DomainNameCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DomainNameConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNameExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DomainNameExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<DomainNameGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNameImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<DomainNameIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DomainNameJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DomainNameNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<DomainNameObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DomainNameOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNamePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DomainNameReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DomainNameStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DomainNameStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<DomainNameStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<DomainNameStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EditUserContextResolvers<ContextType = any, ParentType extends ResolversParentTypes['EditUserContext'] = ResolversParentTypes['EditUserContext']> = ResolversObject<{
  focusOn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ElasticSearchMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElasticSearchMetrics'] = ResolversParentTypes['ElasticSearchMetrics']> = ResolversObject<{
  docs?: Resolver<Maybe<ResolversTypes['DocsMetrics']>, ParentType, ContextType>;
  get?: Resolver<Maybe<ResolversTypes['GetMetrics']>, ParentType, ContextType>;
  indexing?: Resolver<Maybe<ResolversTypes['IndexingMetrics']>, ParentType, ContextType>;
  search?: Resolver<Maybe<ResolversTypes['SearchMetrics']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailAddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailAddr'] = ResolversParentTypes['EmailAddr']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<EmailAddrCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailAddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  display_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailAddrExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<EmailAddrGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailAddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailAddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailAddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<EmailAddrObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailAddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailAddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailAddrStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailAddrStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailAddrStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailAddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailMessage'] = ResolversParentTypes['EmailMessage']> = ResolversObject<{
  attribute_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<EmailMessageCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailMessageConnectorsArgs>>;
  content_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessageExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailMessageExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<EmailMessageGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessageImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailMessageIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_multipart?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailMessageJobsArgs>>;
  message_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailMessageNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<EmailMessageObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailMessageOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessagePendingFilesArgs>>;
  received_lines?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailMessageReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailMessageStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailMessageStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailMessageStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailMessageStixCyberObservableRelationshipsArgs>>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EmailMimePartTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailMimePartType'] = ResolversParentTypes['EmailMimePartType']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailMimePartTypeConnectorsArgs>>;
  content_disposition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailMimePartTypeJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailMimePartTypeStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EmailMimePartTypeStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntitySettingResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitySetting'] = ResolversParentTypes['EntitySetting']> = ResolversObject<{
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enforce_reference?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  platform_entity_files_ref?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  platform_hidden_type?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  target_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntitySettingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitySettingConnection'] = ResolversParentTypes['EntitySettingConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['EntitySettingEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntitySettingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitySettingEdge'] = ResolversParentTypes['EntitySettingEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EntitySetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventResolvers<ContextType = any, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<EventCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EventConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  event_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EventExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EventExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<EventGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EventImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EventJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EventNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<EventObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EventOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EventPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EventReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EventStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EventStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<EventStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stop_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventConnection'] = ResolversParentTypes['EventConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['EventEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EventEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventEdge'] = ResolversParentTypes['EventEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Event'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalReferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReference'] = ResolversParentTypes['ExternalReference']> = ResolversObject<{
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ExternalReferenceConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferenceExportFilesArgs>>;
  external_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferenceImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ExternalReferenceJobsArgs>>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferencePendingFilesArgs>>;
  references?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<ExternalReferenceReferencesArgs>>;
  source_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalReferenceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceConnection'] = ResolversParentTypes['ExternalReferenceConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ExternalReferenceEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalReferenceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceEdge'] = ResolversParentTypes['ExternalReferenceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ExternalReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ExternalReferenceEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceEditMutations'] = ResolversParentTypes['ExternalReferenceEditMutations']> = ResolversObject<{
  askEnrichment?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsAskEnrichmentArgs, 'connectorId'>>;
  contextClean?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, Partial<ExternalReferenceEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsImportPushArgs, 'file'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ExternalReferenceEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsRelationDeleteArgs, 'fromId' | 'relationship_type'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Feed'] = ResolversParentTypes['Feed']> = ResolversObject<{
  feed_attributes?: Resolver<Array<ResolversTypes['FeedAttribute']>, ParentType, ContextType>;
  feed_types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  include_header?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rolling_time?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  separator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeedAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedAttribute'] = ResolversParentTypes['FeedAttribute']> = ResolversObject<{
  attribute?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mappings?: Resolver<Array<ResolversTypes['FeedMapping']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeedConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedConnection'] = ResolversParentTypes['FeedConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['FeedEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeedEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedEdge'] = ResolversParentTypes['FeedEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Feed'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FeedMappingResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedMapping'] = ResolversParentTypes['FeedMapping']> = ResolversObject<{
  attribute?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FileResolvers<ContextType = any, ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastModifiedSinceMin?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  metaData?: Resolver<Maybe<ResolversTypes['FileMetadata']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  uploadStatus?: Resolver<ResolversTypes['State'], ParentType, ContextType>;
  works?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FileConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileConnection'] = ResolversParentTypes['FileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['FileEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FileEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileEdge'] = ResolversParentTypes['FileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['File'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FileMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileMetadata'] = ResolversParentTypes['FileMetadata']> = ResolversObject<{
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  creator_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType>;
  entity_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  external_reference_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  labels_text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  list_filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  mimetype?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GetMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['GetMetrics'] = ResolversParentTypes['GetMetrics']> = ResolversObject<{
  total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['Group'] = ResolversParentTypes['Group']> = ResolversObject<{
  allowed_marking?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarkingDefinition']>>>, ParentType, ContextType>;
  auto_new_marking?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  default_assignation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  members?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupConnection'] = ResolversParentTypes['GroupConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupEdge'] = ResolversParentTypes['GroupEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupEditMutations'] = ResolversParentTypes['GroupEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, Partial<GroupEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<GroupEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<GroupEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<GroupEditMutationsRelationDeleteArgs, 'relationship_type'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Grouping'] = ResolversParentTypes['Grouping']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<GroupingCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<GroupingConnectorsArgs>>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<GroupingExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<GroupingExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<GroupingGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<GroupingImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<GroupingJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<GroupingNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<GroupingObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<GroupingObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<GroupingOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<GroupingPendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<GroupingRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<GroupingReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<GroupingStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<GroupingStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<GroupingStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupingConnection'] = ResolversParentTypes['GroupingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupingEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupingEdge'] = ResolversParentTypes['GroupingEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Grouping'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HashResolvers<ContextType = any, ParentType extends ResolversParentTypes['Hash'] = ResolversParentTypes['Hash']> = ResolversObject<{
  algorithm?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HashedObservableResolvers<ContextType = any, ParentType extends ResolversParentTypes['HashedObservable'] = ResolversParentTypes['HashedObservable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Artifact' | 'StixFile' | 'X509Certificate', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<HashedObservableCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<HashedObservableConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservableExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<HashedObservableExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<HashedObservableGroupingsArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservableImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<HashedObservableIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<HashedObservableJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<HashedObservableNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<HashedObservableObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<HashedObservableOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservablePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<HashedObservableReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<HashedObservableStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<HashedObservableStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<HashedObservableStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<HashedObservableStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type HostnameResolvers<ContextType = any, ParentType extends ResolversParentTypes['Hostname'] = ResolversParentTypes['Hostname']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<HostnameCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<HostnameConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnameExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<HostnameExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<HostnameGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnameImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<HostnameIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<HostnameJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<HostnameNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<HostnameObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<HostnameOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnamePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<HostnameReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<HostnameStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<HostnameStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<HostnameStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<HostnameStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IPv4AddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['IPv4Addr'] = ResolversParentTypes['IPv4Addr']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IPv4AddrCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IPv4AddrConnectorsArgs>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IPv4AddrExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IPv4AddrGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<IPv4AddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IPv4AddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IPv4AddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IPv4AddrObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IPv4AddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IPv4AddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IPv4AddrStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IPv4AddrStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IPv4AddrStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<IPv4AddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IPv6AddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['IPv6Addr'] = ResolversParentTypes['IPv6Addr']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IPv6AddrCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IPv6AddrConnectorsArgs>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IPv6AddrExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IPv6AddrGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<IPv6AddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IPv6AddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IPv6AddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IPv6AddrObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IPv6AddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IPv6AddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IPv6AddrStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IPv6AddrStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IPv6AddrStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<IPv6AddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IdentityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Identity'] = ResolversParentTypes['Identity']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Individual' | 'Organization' | 'Sector' | 'System', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IdentityCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IdentityConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IdentityExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IdentityGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IdentityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IdentityNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IdentityObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IdentityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IdentityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IdentityStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IdentityStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IdentityStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type IdentityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityConnection'] = ResolversParentTypes['IdentityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IdentityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IdentityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityEdge'] = ResolversParentTypes['IdentityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Identity'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IdentityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityEditMutations'] = ResolversParentTypes['IdentityEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, Partial<IdentityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<IdentityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IdentityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<IdentityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IncidentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Incident'] = ResolversParentTypes['Incident']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IncidentCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IncidentConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IncidentExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IncidentGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentImportFilesArgs>>;
  incident_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IncidentJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IncidentNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objective?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IncidentObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IncidentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IncidentReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  severity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IncidentStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IncidentStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IncidentStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IncidentConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentConnection'] = ResolversParentTypes['IncidentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IncidentEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IncidentEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentEdge'] = ResolversParentTypes['IncidentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Incident'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IncidentEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentEditMutations'] = ResolversParentTypes['IncidentEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<IncidentEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, RequireFields<IncidentEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IncidentEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, RequireFields<IncidentEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndexingMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndexingMetrics'] = ResolversParentTypes['IndexingMetrics']> = ResolversObject<{
  delete_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndicatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Indicator'] = ResolversParentTypes['Indicator']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IndicatorCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IndicatorConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IndicatorExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IndicatorGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorImportFilesArgs>>;
  indicator_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IndicatorJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IndicatorNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observables?: Resolver<Maybe<ResolversTypes['StixCyberObservableConnection']>, ParentType, ContextType, Partial<IndicatorObservablesArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IndicatorObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IndicatorOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pattern?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern_version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IndicatorReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IndicatorStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IndicatorStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IndicatorStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  valid_from?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  valid_until?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_platforms?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  x_opencti_detection?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_main_observable_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndicatorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorConnection'] = ResolversParentTypes['IndicatorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndicatorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndicatorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorEdge'] = ResolversParentTypes['IndicatorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Indicator'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndicatorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorEditMutations'] = ResolversParentTypes['IndicatorEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, Partial<IndicatorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<IndicatorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IndicatorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<IndicatorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndividualResolvers<ContextType = any, ParentType extends ResolversParentTypes['Individual'] = ResolversParentTypes['Individual']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IndividualCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IndividualConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IndividualExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IndividualGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualImportFilesArgs>>;
  isUser?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IndividualJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IndividualNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IndividualObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IndividualOpinionsArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IndividualReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IndividualStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IndividualStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IndividualStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndividualConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualConnection'] = ResolversParentTypes['IndividualConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndividualEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndividualEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualEdge'] = ResolversParentTypes['IndividualEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Individual'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IndividualEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualEditMutations'] = ResolversParentTypes['IndividualEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, Partial<IndividualEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<IndividualEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IndividualEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<IndividualEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Inference'] = ResolversParentTypes['Inference']> = ResolversObject<{
  attributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['InferenceAttribute']>>>, ParentType, ContextType>;
  explanation?: Resolver<Array<Maybe<ResolversTypes['StixObjectOrStixRelationship']>>, ParentType, ContextType>;
  rule?: Resolver<ResolversTypes['Rule'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InferenceAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InferenceAttribute'] = ResolversParentTypes['InferenceAttribute']> = ResolversObject<{
  field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InfrastructureResolvers<ContextType = any, ParentType extends ResolversParentTypes['Infrastructure'] = ResolversParentTypes['Infrastructure']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<InfrastructureCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<InfrastructureConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructureExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<InfrastructureExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<InfrastructureGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructureImportFilesArgs>>;
  infrastructure_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<InfrastructureJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<InfrastructureNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<InfrastructureObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<InfrastructureOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructurePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<InfrastructureReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<InfrastructureStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<InfrastructureStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<InfrastructureStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InfrastructureConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureConnection'] = ResolversParentTypes['InfrastructureConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['InfrastructureEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InfrastructureEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureEdge'] = ResolversParentTypes['InfrastructureEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Infrastructure'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InfrastructureEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureEditMutations'] = ResolversParentTypes['InfrastructureEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, Partial<InfrastructureEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<InfrastructureEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<InfrastructureEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<InfrastructureEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type InternalObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['InternalObject'] = ResolversParentTypes['InternalObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Capability' | 'Connector' | 'EntitySetting' | 'Group' | 'MeUser' | 'Role' | 'Settings' | 'User', ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type InternalRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['InternalRelationship'] = ResolversParentTypes['InternalRelationship']> = ResolversObject<{
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['InternalObject']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['InternalObject']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntrusionSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSet'] = ResolversParentTypes['IntrusionSet']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<IntrusionSetCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IntrusionSetConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IntrusionSetExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  goals?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<IntrusionSetGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IntrusionSetJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IntrusionSetNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<IntrusionSetObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IntrusionSetOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetPendingFilesArgs>>;
  primary_motivation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IntrusionSetReportsArgs>>;
  resource_level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  secondary_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IntrusionSetStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IntrusionSetStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<IntrusionSetStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntrusionSetConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetConnection'] = ResolversParentTypes['IntrusionSetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IntrusionSetEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntrusionSetEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetEdge'] = ResolversParentTypes['IntrusionSetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['IntrusionSet'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type IntrusionSetEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetEditMutations'] = ResolversParentTypes['IntrusionSetEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<IntrusionSetEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, RequireFields<IntrusionSetEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IntrusionSetEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, RequireFields<IntrusionSetEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type KillChainPhaseResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhase'] = ResolversParentTypes['KillChainPhase']> = ResolversObject<{
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  kill_chain_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  phase_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type KillChainPhaseConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseConnection'] = ResolversParentTypes['KillChainPhaseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['KillChainPhaseEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type KillChainPhaseEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseEdge'] = ResolversParentTypes['KillChainPhaseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['KillChainPhase'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type KillChainPhaseEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseEditMutations'] = ResolversParentTypes['KillChainPhaseEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, Partial<KillChainPhaseEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<KillChainPhaseEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<KillChainPhaseEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<KillChainPhaseEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Label'] = ResolversParentTypes['Label']> = ResolversObject<{
  color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelConnection'] = ResolversParentTypes['LabelConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LabelEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelEdge'] = ResolversParentTypes['LabelEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Label'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LabelEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelEditMutations'] = ResolversParentTypes['LabelEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, Partial<LabelEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, RequireFields<LabelEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Language'] = ResolversParentTypes['Language']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<LanguageCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<LanguageConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LanguageExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<LanguageExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<LanguageGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LanguageImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<LanguageJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<LanguageNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<LanguageObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<LanguageOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LanguagePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<LanguageReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<LanguageStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<LanguageStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<LanguageStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageConnection'] = ResolversParentTypes['LanguageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LanguageEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LanguageEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageEdge'] = ResolversParentTypes['LanguageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Language'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ListTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['ListTask'] = ResolversParentTypes['ListTask']> = ResolversObject<{
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_ids?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LocationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Location'] = ResolversParentTypes['Location']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'City' | 'Country' | 'Position' | 'Region', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<LocationCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<LocationConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<LocationExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<LocationGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<LocationJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<LocationNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<LocationObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<LocationOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<LocationReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<LocationStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<LocationStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<LocationStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type LocationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationConnection'] = ResolversParentTypes['LocationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LocationEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LocationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationEdge'] = ResolversParentTypes['LocationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Location'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LocationEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationEditMutations'] = ResolversParentTypes['LocationEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, Partial<LocationEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<LocationEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<LocationEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<LocationEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LogResolvers<ContextType = any, ParentType extends ResolversParentTypes['Log'] = ResolversParentTypes['Log']> = ResolversObject<{
  context_data?: Resolver<Maybe<ResolversTypes['ContextData']>, ParentType, ContextType>;
  event_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  user_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LogConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogConnection'] = ResolversParentTypes['LogConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LogEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LogEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogEdge'] = ResolversParentTypes['LogEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Log'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type LogsWorkerConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogsWorkerConfig'] = ResolversParentTypes['LogsWorkerConfig']> = ResolversObject<{
  elasticsearch_api_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  elasticsearch_password?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_proxy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_ssl_reject_unauthorized?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  elasticsearch_url?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  elasticsearch_username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MacAddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['MacAddr'] = ResolversParentTypes['MacAddr']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<MacAddrCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MacAddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MacAddrExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<MacAddrGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<MacAddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MacAddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MacAddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<MacAddrObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MacAddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MacAddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MacAddrStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MacAddrStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MacAddrStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<MacAddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MalwareResolvers<ContextType = any, ParentType extends ResolversParentTypes['Malware'] = ResolversParentTypes['Malware']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  architecture_execution_envs?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  capabilities?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<MalwareCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MalwareConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwareExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MalwareExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<MalwareGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  implementation_languages?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwareImportFilesArgs>>;
  is_family?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MalwareJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  malware_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MalwareNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<MalwareObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MalwareOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwarePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MalwareReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MalwareStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MalwareStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MalwareStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MalwareConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareConnection'] = ResolversParentTypes['MalwareConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MalwareEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MalwareEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareEdge'] = ResolversParentTypes['MalwareEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Malware'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MalwareEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareEditMutations'] = ResolversParentTypes['MalwareEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<MalwareEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, RequireFields<MalwareEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<MalwareEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, RequireFields<MalwareEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkingDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinition'] = ResolversParentTypes['MarkingDefinition']> = ResolversObject<{
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  definition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  definition_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkingDefinitionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionConnection'] = ResolversParentTypes['MarkingDefinitionConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['MarkingDefinitionEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkingDefinitionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionEdge'] = ResolversParentTypes['MarkingDefinitionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MarkingDefinition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MarkingDefinitionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionEditMutations'] = ResolversParentTypes['MarkingDefinitionEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, Partial<MarkingDefinitionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, RequireFields<MarkingDefinitionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeOrganizationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeOrganization'] = ResolversParentTypes['MeOrganization']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeOrganizationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeOrganizationConnection'] = ResolversParentTypes['MeOrganizationConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['MeOrganizationEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeOrganizationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeOrganizationEdge'] = ResolversParentTypes['MeOrganizationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MeOrganization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MeUserResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeUser'] = ResolversParentTypes['MeUser']> = ResolversObject<{
  allowed_marking?: Resolver<Maybe<Array<ResolversTypes['MarkingDefinition']>>, ParentType, ContextType>;
  api_token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  capabilities?: Resolver<Array<ResolversTypes['Capability']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['MeOrganizationConnection']>, ParentType, ContextType>;
  otp_activated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  otp_mandatory?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  otp_qr?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userSubscriptions?: Resolver<Maybe<ResolversTypes['UserSubscriptionConnection']>, ParentType, ContextType, Partial<MeUserUserSubscriptionsArgs>>;
  user_email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediaContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['MediaContent'] = ResolversParentTypes['MediaContent']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<MediaContentCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MediaContentConnectorsArgs>>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MediaContentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MediaContentExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<MediaContentGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MediaContentImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<MediaContentIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MediaContentJobsArgs>>;
  media_category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MediaContentNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<MediaContentObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MediaContentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MediaContentPendingFilesArgs>>;
  publication_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MediaContentReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MediaContentStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MediaContentStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MediaContentStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<MediaContentStixCyberObservableRelationshipsArgs>>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MessagesStatsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagesStats'] = ResolversParentTypes['MessagesStats']> = ResolversObject<{
  ack?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ack_details?: Resolver<Maybe<ResolversTypes['AckDetails']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ModuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Module'] = ResolversParentTypes['Module']> = ResolversObject<{
  enable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  running?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MultiDistributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiDistribution'] = ResolversParentTypes['MultiDistribution']> = ResolversObject<{
  data?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MultiTimeSeriesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiTimeSeries'] = ResolversParentTypes['MultiTimeSeries']> = ResolversObject<{
  data?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  administrativeAreaAdd?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaAddArgs, 'input'>>;
  administrativeAreaContextClean?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaContextCleanArgs, 'id'>>;
  administrativeAreaContextPatch?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaContextPatchArgs, 'id' | 'input'>>;
  administrativeAreaDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaDeleteArgs, 'id'>>;
  administrativeAreaFieldPatch?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaFieldPatchArgs, 'id' | 'input'>>;
  administrativeAreaRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaRelationAddArgs, 'id' | 'input'>>;
  administrativeAreaRelationDelete?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<MutationAdministrativeAreaRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  artifactImport?: Resolver<Maybe<ResolversTypes['Artifact']>, ParentType, ContextType, RequireFields<MutationArtifactImportArgs, 'file'>>;
  askJobImport?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationAskJobImportArgs, 'fileName'>>;
  attackPatternAdd?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<MutationAttackPatternAddArgs>>;
  attackPatternEdit?: Resolver<Maybe<ResolversTypes['AttackPatternEditMutations']>, ParentType, ContextType, RequireFields<MutationAttackPatternEditArgs, 'id'>>;
  bookmarkAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<MutationBookmarkAddArgs, 'id' | 'type'>>;
  bookmarkDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationBookmarkDeleteArgs, 'id'>>;
  campaignAdd?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<MutationCampaignAddArgs>>;
  campaignEdit?: Resolver<Maybe<ResolversTypes['CampaignEditMutations']>, ParentType, ContextType, RequireFields<MutationCampaignEditArgs, 'id'>>;
  caseAdd?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<MutationCaseAddArgs, 'input'>>;
  caseContextClean?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<MutationCaseContextCleanArgs, 'id'>>;
  caseContextPatch?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<MutationCaseContextPatchArgs, 'id' | 'input'>>;
  caseDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationCaseDeleteArgs, 'id'>>;
  caseFieldPatch?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<MutationCaseFieldPatchArgs, 'id' | 'input'>>;
  caseRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationCaseRelationAddArgs, 'id' | 'input'>>;
  caseRelationDelete?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<MutationCaseRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  channelAdd?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationChannelAddArgs, 'input'>>;
  channelContextClean?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationChannelContextCleanArgs, 'id'>>;
  channelContextPatch?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationChannelContextPatchArgs, 'id' | 'input'>>;
  channelDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationChannelDeleteArgs, 'id'>>;
  channelFieldPatch?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationChannelFieldPatchArgs, 'id' | 'input'>>;
  channelRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationChannelRelationAddArgs, 'id' | 'input'>>;
  channelRelationDelete?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationChannelRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  cityAdd?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<MutationCityAddArgs>>;
  cityEdit?: Resolver<Maybe<ResolversTypes['CityEditMutations']>, ParentType, ContextType, RequireFields<MutationCityEditArgs, 'id'>>;
  containerEdit?: Resolver<Maybe<ResolversTypes['ContainerEditMutations']>, ParentType, ContextType, RequireFields<MutationContainerEditArgs, 'id'>>;
  countryAdd?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<MutationCountryAddArgs>>;
  countryEdit?: Resolver<Maybe<ResolversTypes['CountryEditMutations']>, ParentType, ContextType, RequireFields<MutationCountryEditArgs, 'id'>>;
  courseOfActionAdd?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<MutationCourseOfActionAddArgs>>;
  courseOfActionEdit?: Resolver<Maybe<ResolversTypes['CourseOfActionEditMutations']>, ParentType, ContextType, RequireFields<MutationCourseOfActionEditArgs, 'id'>>;
  dataComponentAdd?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<MutationDataComponentAddArgs, 'input'>>;
  dataComponentContextClean?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<MutationDataComponentContextCleanArgs, 'id'>>;
  dataComponentContextPatch?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<MutationDataComponentContextPatchArgs, 'id' | 'input'>>;
  dataComponentDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationDataComponentDeleteArgs, 'id'>>;
  dataComponentFieldPatch?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<MutationDataComponentFieldPatchArgs, 'id' | 'input'>>;
  dataComponentRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationDataComponentRelationAddArgs, 'id' | 'input'>>;
  dataComponentRelationDelete?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<MutationDataComponentRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  dataSourceAdd?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceAddArgs, 'input'>>;
  dataSourceContextClean?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceContextCleanArgs, 'id'>>;
  dataSourceContextPatch?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceContextPatchArgs, 'id' | 'input'>>;
  dataSourceDataComponentAdd?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceDataComponentAddArgs, 'dataComponentId' | 'id'>>;
  dataSourceDataComponentDelete?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceDataComponentDeleteArgs, 'dataComponentId' | 'id'>>;
  dataSourceDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationDataSourceDeleteArgs, 'id'>>;
  dataSourceFieldPatch?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceFieldPatchArgs, 'id' | 'input'>>;
  dataSourceRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationDataSourceRelationAddArgs, 'id' | 'input'>>;
  dataSourceRelationDelete?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<MutationDataSourceRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  deleteConnector?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationDeleteConnectorArgs, 'id'>>;
  deleteImport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, Partial<MutationDeleteImportArgs>>;
  deleteTask?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationDeleteTaskArgs, 'id'>>;
  entitySettingsFieldPatch?: Resolver<Maybe<Array<Maybe<ResolversTypes['EntitySetting']>>>, ParentType, ContextType, RequireFields<MutationEntitySettingsFieldPatchArgs, 'ids' | 'input'>>;
  eventAdd?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<MutationEventAddArgs, 'input'>>;
  eventContextClean?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<MutationEventContextCleanArgs, 'id'>>;
  eventContextPatch?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<MutationEventContextPatchArgs, 'id' | 'input'>>;
  eventDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationEventDeleteArgs, 'id'>>;
  eventFieldPatch?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<MutationEventFieldPatchArgs, 'id' | 'input'>>;
  eventRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationEventRelationAddArgs, 'id' | 'input'>>;
  eventRelationDelete?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<MutationEventRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  externalReferenceAdd?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, Partial<MutationExternalReferenceAddArgs>>;
  externalReferenceEdit?: Resolver<Maybe<ResolversTypes['ExternalReferenceEditMutations']>, ParentType, ContextType, RequireFields<MutationExternalReferenceEditArgs, 'id'>>;
  feedAdd?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType, RequireFields<MutationFeedAddArgs, 'input'>>;
  feedDelete?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationFeedDeleteArgs, 'id'>>;
  feedEdit?: Resolver<ResolversTypes['Feed'], ParentType, ContextType, RequireFields<MutationFeedEditArgs, 'id' | 'input'>>;
  groupAdd?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, Partial<MutationGroupAddArgs>>;
  groupEdit?: Resolver<Maybe<ResolversTypes['GroupEditMutations']>, ParentType, ContextType, RequireFields<MutationGroupEditArgs, 'id'>>;
  groupingAdd?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<MutationGroupingAddArgs, 'input'>>;
  groupingContextClean?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<MutationGroupingContextCleanArgs, 'id'>>;
  groupingContextPatch?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<MutationGroupingContextPatchArgs, 'id'>>;
  groupingDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationGroupingDeleteArgs, 'id'>>;
  groupingFieldPatch?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<MutationGroupingFieldPatchArgs, 'id' | 'input'>>;
  groupingRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationGroupingRelationAddArgs, 'id'>>;
  groupingRelationDelete?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<MutationGroupingRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  identityAdd?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, Partial<MutationIdentityAddArgs>>;
  identityEdit?: Resolver<Maybe<ResolversTypes['IdentityEditMutations']>, ParentType, ContextType, RequireFields<MutationIdentityEditArgs, 'id'>>;
  incidentAdd?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<MutationIncidentAddArgs>>;
  incidentEdit?: Resolver<Maybe<ResolversTypes['IncidentEditMutations']>, ParentType, ContextType, RequireFields<MutationIncidentEditArgs, 'id'>>;
  indicatorAdd?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, Partial<MutationIndicatorAddArgs>>;
  indicatorEdit?: Resolver<Maybe<ResolversTypes['IndicatorEditMutations']>, ParentType, ContextType, RequireFields<MutationIndicatorEditArgs, 'id'>>;
  individualAdd?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, Partial<MutationIndividualAddArgs>>;
  individualEdit?: Resolver<Maybe<ResolversTypes['IndividualEditMutations']>, ParentType, ContextType, RequireFields<MutationIndividualEditArgs, 'id'>>;
  infrastructureAdd?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, Partial<MutationInfrastructureAddArgs>>;
  infrastructureEdit?: Resolver<Maybe<ResolversTypes['InfrastructureEditMutations']>, ParentType, ContextType, RequireFields<MutationInfrastructureEditArgs, 'id'>>;
  intrusionSetAdd?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<MutationIntrusionSetAddArgs>>;
  intrusionSetEdit?: Resolver<Maybe<ResolversTypes['IntrusionSetEditMutations']>, ParentType, ContextType, RequireFields<MutationIntrusionSetEditArgs, 'id'>>;
  killChainPhaseAdd?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, Partial<MutationKillChainPhaseAddArgs>>;
  killChainPhaseEdit?: Resolver<Maybe<ResolversTypes['KillChainPhaseEditMutations']>, ParentType, ContextType, RequireFields<MutationKillChainPhaseEditArgs, 'id'>>;
  labelAdd?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, Partial<MutationLabelAddArgs>>;
  labelEdit?: Resolver<Maybe<ResolversTypes['LabelEditMutations']>, ParentType, ContextType, RequireFields<MutationLabelEditArgs, 'id'>>;
  languageAdd?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<MutationLanguageAddArgs, 'input'>>;
  languageContextClean?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<MutationLanguageContextCleanArgs, 'id'>>;
  languageContextPatch?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<MutationLanguageContextPatchArgs, 'id' | 'input'>>;
  languageDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationLanguageDeleteArgs, 'id'>>;
  languageFieldPatch?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<MutationLanguageFieldPatchArgs, 'id' | 'input'>>;
  languageRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationLanguageRelationAddArgs, 'id' | 'input'>>;
  languageRelationDelete?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<MutationLanguageRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  listTaskAdd?: Resolver<ResolversTypes['Task'], ParentType, ContextType, Partial<MutationListTaskAddArgs>>;
  locationAdd?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, Partial<MutationLocationAddArgs>>;
  locationEdit?: Resolver<Maybe<ResolversTypes['LocationEditMutations']>, ParentType, ContextType, RequireFields<MutationLocationEditArgs, 'id'>>;
  logout?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  malwareAdd?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<MutationMalwareAddArgs>>;
  malwareEdit?: Resolver<Maybe<ResolversTypes['MalwareEditMutations']>, ParentType, ContextType, RequireFields<MutationMalwareEditArgs, 'id'>>;
  markingDefinitionAdd?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, Partial<MutationMarkingDefinitionAddArgs>>;
  markingDefinitionEdit?: Resolver<Maybe<ResolversTypes['MarkingDefinitionEditMutations']>, ParentType, ContextType, RequireFields<MutationMarkingDefinitionEditArgs, 'id'>>;
  meEdit?: Resolver<Maybe<ResolversTypes['MeUser']>, ParentType, ContextType, RequireFields<MutationMeEditArgs, 'input'>>;
  meTokenRenew?: Resolver<Maybe<ResolversTypes['MeUser']>, ParentType, ContextType>;
  narrativeAdd?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<MutationNarrativeAddArgs, 'input'>>;
  narrativeContextClean?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<MutationNarrativeContextCleanArgs, 'id'>>;
  narrativeContextPatch?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<MutationNarrativeContextPatchArgs, 'id' | 'input'>>;
  narrativeDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationNarrativeDeleteArgs, 'id'>>;
  narrativeFieldPatch?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<MutationNarrativeFieldPatchArgs, 'id' | 'input'>>;
  narrativeRelationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, RequireFields<MutationNarrativeRelationAddArgs, 'id' | 'input'>>;
  narrativeRelationDelete?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<MutationNarrativeRelationDeleteArgs, 'id' | 'relationship_type' | 'toId'>>;
  noteAdd?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<MutationNoteAddArgs>>;
  noteEdit?: Resolver<Maybe<ResolversTypes['NoteEditMutations']>, ParentType, ContextType, RequireFields<MutationNoteEditArgs, 'id'>>;
  observedDataAdd?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<MutationObservedDataAddArgs>>;
  observedDataEdit?: Resolver<Maybe<ResolversTypes['ObservedDataEditMutations']>, ParentType, ContextType, RequireFields<MutationObservedDataEditArgs, 'id'>>;
  opinionAdd?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<MutationOpinionAddArgs>>;
  opinionEdit?: Resolver<Maybe<ResolversTypes['OpinionEditMutations']>, ParentType, ContextType, RequireFields<MutationOpinionEditArgs, 'id'>>;
  organizationAdd?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<MutationOrganizationAddArgs>>;
  organizationEdit?: Resolver<Maybe<ResolversTypes['OrganizationEditMutations']>, ParentType, ContextType, RequireFields<MutationOrganizationEditArgs, 'id'>>;
  otpActivation?: Resolver<Maybe<ResolversTypes['MeUser']>, ParentType, ContextType, Partial<MutationOtpActivationArgs>>;
  otpDeactivation?: Resolver<Maybe<ResolversTypes['MeUser']>, ParentType, ContextType>;
  otpLogin?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, Partial<MutationOtpLoginArgs>>;
  otpSetActivation?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<MutationOtpSetActivationArgs>>;
  otpUserDeactivation?: Resolver<Maybe<ResolversTypes['MeUser']>, ParentType, ContextType, RequireFields<MutationOtpUserDeactivationArgs, 'id'>>;
  pingConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<MutationPingConnectorArgs, 'id'>>;
  positionAdd?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, Partial<MutationPositionAddArgs>>;
  positionEdit?: Resolver<Maybe<ResolversTypes['PositionEditMutations']>, ParentType, ContextType, RequireFields<MutationPositionEditArgs, 'id'>>;
  queryTaskAdd?: Resolver<ResolversTypes['Task'], ParentType, ContextType, Partial<MutationQueryTaskAddArgs>>;
  regionAdd?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, Partial<MutationRegionAddArgs>>;
  regionEdit?: Resolver<Maybe<ResolversTypes['RegionEditMutations']>, ParentType, ContextType, RequireFields<MutationRegionEditArgs, 'id'>>;
  registerConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, Partial<MutationRegisterConnectorArgs>>;
  reportAdd?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<MutationReportAddArgs>>;
  reportEdit?: Resolver<Maybe<ResolversTypes['ReportEditMutations']>, ParentType, ContextType, RequireFields<MutationReportEditArgs, 'id'>>;
  resetStateConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<MutationResetStateConnectorArgs, 'id'>>;
  retentionRuleAdd?: Resolver<ResolversTypes['RetentionRule'], ParentType, ContextType, Partial<MutationRetentionRuleAddArgs>>;
  retentionRuleCheck?: Resolver<ResolversTypes['Int'], ParentType, ContextType, Partial<MutationRetentionRuleCheckArgs>>;
  retentionRuleEdit?: Resolver<Maybe<ResolversTypes['RetentionRuleEditMutations']>, ParentType, ContextType, RequireFields<MutationRetentionRuleEditArgs, 'id'>>;
  roleAdd?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, Partial<MutationRoleAddArgs>>;
  roleEdit?: Resolver<Maybe<ResolversTypes['RoleEditMutations']>, ParentType, ContextType, RequireFields<MutationRoleEditArgs, 'id'>>;
  ruleManagerClean?: Resolver<ResolversTypes['RuleManager'], ParentType, ContextType, Partial<MutationRuleManagerCleanArgs>>;
  ruleSetActivation?: Resolver<ResolversTypes['Rule'], ParentType, ContextType, RequireFields<MutationRuleSetActivationArgs, 'enable' | 'id'>>;
  runtimeAttributeEdit?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationRuntimeAttributeEditArgs, 'current' | 'id' | 'previous'>>;
  sectorAdd?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<MutationSectorAddArgs>>;
  sectorEdit?: Resolver<Maybe<ResolversTypes['SectorEditMutations']>, ParentType, ContextType, RequireFields<MutationSectorEditArgs, 'id'>>;
  sessionKill?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationSessionKillArgs, 'id'>>;
  settingsEdit?: Resolver<Maybe<ResolversTypes['SettingsEditMutations']>, ParentType, ContextType, RequireFields<MutationSettingsEditArgs, 'id'>>;
  statusTemplateAdd?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType, RequireFields<MutationStatusTemplateAddArgs, 'input'>>;
  statusTemplateContextClean?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType, RequireFields<MutationStatusTemplateContextCleanArgs, 'id'>>;
  statusTemplateContextPatch?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType, RequireFields<MutationStatusTemplateContextPatchArgs, 'id' | 'input'>>;
  statusTemplateDelete?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationStatusTemplateDeleteArgs, 'id'>>;
  statusTemplateFieldPatch?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType, RequireFields<MutationStatusTemplateFieldPatchArgs, 'id' | 'input'>>;
  stixCoreObjectEdit?: Resolver<Maybe<ResolversTypes['StixCoreObjectEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCoreObjectEditArgs, 'id'>>;
  stixCoreObjectsExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixCoreObjectsExportAskArgs, 'exportType' | 'format' | 'type'>>;
  stixCoreObjectsExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixCoreObjectsExportPushArgs, 'file' | 'type'>>;
  stixCoreRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<MutationStixCoreRelationshipAddArgs>>;
  stixCoreRelationshipDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<MutationStixCoreRelationshipDeleteArgs, 'fromId' | 'relationship_type' | 'toId'>>;
  stixCoreRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCoreRelationshipEditArgs, 'id'>>;
  stixCoreRelationshipsExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixCoreRelationshipsExportAskArgs, 'exportType' | 'format' | 'type'>>;
  stixCoreRelationshipsExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixCoreRelationshipsExportPushArgs, 'file' | 'type'>>;
  stixCyberObservableAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableAddArgs, 'type'>>;
  stixCyberObservableEdit?: Resolver<Maybe<ResolversTypes['StixCyberObservableEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableEditArgs, 'id'>>;
  stixCyberObservableRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<MutationStixCyberObservableRelationshipAddArgs>>;
  stixCyberObservableRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableRelationshipEditArgs, 'id'>>;
  stixCyberObservablesExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixCyberObservablesExportAskArgs, 'exportType' | 'format'>>;
  stixCyberObservablesExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixCyberObservablesExportPushArgs, 'file'>>;
  stixDomainObjectAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<MutationStixDomainObjectAddArgs>>;
  stixDomainObjectEdit?: Resolver<Maybe<ResolversTypes['StixDomainObjectEditMutations']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectEditArgs, 'id'>>;
  stixDomainObjectsDelete?: Resolver<Array<Maybe<ResolversTypes['ID']>>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsDeleteArgs, 'id'>>;
  stixDomainObjectsExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsExportAskArgs, 'exportType' | 'format' | 'type'>>;
  stixDomainObjectsExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsExportPushArgs, 'file' | 'type'>>;
  stixEdit?: Resolver<Maybe<ResolversTypes['StixEditMutations']>, ParentType, ContextType, RequireFields<MutationStixEditArgs, 'id'>>;
  stixRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixRelationshipEditArgs, 'id'>>;
  stixSightingRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<MutationStixSightingRelationshipAddArgs>>;
  stixSightingRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixSightingRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixSightingRelationshipEditArgs, 'id'>>;
  streamCollectionAdd?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, Partial<MutationStreamCollectionAddArgs>>;
  streamCollectionEdit?: Resolver<Maybe<ResolversTypes['StreamCollectionEditMutations']>, ParentType, ContextType, RequireFields<MutationStreamCollectionEditArgs, 'id'>>;
  subTypeEdit?: Resolver<Maybe<ResolversTypes['SubTypeEditMutations']>, ParentType, ContextType, RequireFields<MutationSubTypeEditArgs, 'id'>>;
  synchronizerAdd?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, Partial<MutationSynchronizerAddArgs>>;
  synchronizerEdit?: Resolver<Maybe<ResolversTypes['SynchronizerEditMutations']>, ParentType, ContextType, RequireFields<MutationSynchronizerEditArgs, 'id'>>;
  synchronizerStart?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<MutationSynchronizerStartArgs, 'id'>>;
  synchronizerStop?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<MutationSynchronizerStopArgs, 'id'>>;
  synchronizerTest?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MutationSynchronizerTestArgs>>;
  systemAdd?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<MutationSystemAddArgs>>;
  systemEdit?: Resolver<Maybe<ResolversTypes['SystemEditMutations']>, ParentType, ContextType, RequireFields<MutationSystemEditArgs, 'id'>>;
  taxiiCollectionAdd?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, Partial<MutationTaxiiCollectionAddArgs>>;
  taxiiCollectionEdit?: Resolver<Maybe<ResolversTypes['TaxiiCollectionEditMutations']>, ParentType, ContextType, RequireFields<MutationTaxiiCollectionEditArgs, 'id'>>;
  threatActorAdd?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<MutationThreatActorAddArgs>>;
  threatActorEdit?: Resolver<Maybe<ResolversTypes['ThreatActorEditMutations']>, ParentType, ContextType, RequireFields<MutationThreatActorEditArgs, 'id'>>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MutationTokenArgs>>;
  toolAdd?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<MutationToolAddArgs>>;
  toolEdit?: Resolver<Maybe<ResolversTypes['ToolEditMutations']>, ParentType, ContextType, RequireFields<MutationToolEditArgs, 'id'>>;
  uploadImport?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationUploadImportArgs, 'file'>>;
  uploadPending?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationUploadPendingArgs, 'file'>>;
  userAdd?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<MutationUserAddArgs>>;
  userEdit?: Resolver<Maybe<ResolversTypes['UserEditMutations']>, ParentType, ContextType, RequireFields<MutationUserEditArgs, 'id'>>;
  userNoteAdd?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, RequireFields<MutationUserNoteAddArgs, 'input'>>;
  userSessionsKill?: Resolver<Maybe<Array<Maybe<ResolversTypes['ID']>>>, ParentType, ContextType, RequireFields<MutationUserSessionsKillArgs, 'id'>>;
  userSubscriptionAdd?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, Partial<MutationUserSubscriptionAddArgs>>;
  userSubscriptionEdit?: Resolver<Maybe<ResolversTypes['UserSubscriptionEditMutations']>, ParentType, ContextType, RequireFields<MutationUserSubscriptionEditArgs, 'id'>>;
  vocabularyAdd?: Resolver<Maybe<ResolversTypes['Vocabulary']>, ParentType, ContextType, RequireFields<MutationVocabularyAddArgs, 'input'>>;
  vocabularyDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationVocabularyDeleteArgs, 'id'>>;
  vocabularyFieldPatch?: Resolver<Maybe<ResolversTypes['Vocabulary']>, ParentType, ContextType, RequireFields<MutationVocabularyFieldPatchArgs, 'id' | 'input'>>;
  vulnerabilityAdd?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<MutationVulnerabilityAddArgs>>;
  vulnerabilityEdit?: Resolver<Maybe<ResolversTypes['VulnerabilityEditMutations']>, ParentType, ContextType, RequireFields<MutationVulnerabilityEditArgs, 'id'>>;
  workAdd?: Resolver<ResolversTypes['Work'], ParentType, ContextType, RequireFields<MutationWorkAddArgs, 'connectorId'>>;
  workDelete?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationWorkDeleteArgs, 'connectorId'>>;
  workEdit?: Resolver<Maybe<ResolversTypes['WorkEditMutations']>, ParentType, ContextType, RequireFields<MutationWorkEditArgs, 'id'>>;
  workspaceAdd?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<MutationWorkspaceAddArgs>>;
  workspaceEdit?: Resolver<Maybe<ResolversTypes['WorkspaceEditMutations']>, ParentType, ContextType, RequireFields<MutationWorkspaceEditArgs, 'id'>>;
}>;

export type MutexResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutex'] = ResolversParentTypes['Mutex']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<MutexCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MutexConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MutexExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<MutexGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<MutexIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MutexJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MutexNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<MutexObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MutexOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MutexReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MutexStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MutexStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<MutexStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<MutexStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NarrativeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Narrative'] = ResolversParentTypes['Narrative']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<NarrativeCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<NarrativeConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NarrativeExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<NarrativeExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<NarrativeGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NarrativeImportFilesArgs>>;
  isSubNarrative?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<NarrativeJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  narrative_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<NarrativeNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<NarrativeObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<NarrativeOpinionsArgs>>;
  parentNarratives?: Resolver<Maybe<ResolversTypes['NarrativeConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NarrativePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<NarrativeReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NarrativeStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<NarrativeStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NarrativeStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  subNarratives?: Resolver<Maybe<ResolversTypes['NarrativeConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NarrativeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NarrativeConnection'] = ResolversParentTypes['NarrativeConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['NarrativeEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NarrativeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NarrativeEdge'] = ResolversParentTypes['NarrativeEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Narrative'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NetworkTrafficResolvers<ContextType = any, ParentType extends ResolversParentTypes['NetworkTraffic'] = ResolversParentTypes['NetworkTraffic']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<NetworkTrafficCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<NetworkTrafficConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  dst_byte_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dst_packets?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dst_port?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  end?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<NetworkTrafficExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<NetworkTrafficGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<NetworkTrafficIndicatorsArgs>>;
  is_active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<NetworkTrafficJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<NetworkTrafficNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<NetworkTrafficObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<NetworkTrafficOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficPendingFilesArgs>>;
  protocols?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<NetworkTrafficReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  src_byte_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  src_packets?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  src_port?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NetworkTrafficStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<NetworkTrafficStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NetworkTrafficStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<NetworkTrafficStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Note'] = ResolversParentTypes['Note']> = ResolversObject<{
  attribute_abstract?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authors?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<NoteCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<NoteConnectorsArgs>>;
  content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NoteExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<NoteExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<NoteGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NoteImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<NoteJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  likelihood?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  note_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<NoteNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<NoteObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<NoteObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<NoteOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NotePendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<NoteRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<NoteReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NoteStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<NoteStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<NoteStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NoteConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteConnection'] = ResolversParentTypes['NoteConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['NoteEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NoteEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteEdge'] = ResolversParentTypes['NoteEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Note'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NoteEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteEditMutations'] = ResolversParentTypes['NoteEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<NoteEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, RequireFields<NoteEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<NoteEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, RequireFields<NoteEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NumberResolvers<ContextType = any, ParentType extends ResolversParentTypes['Number'] = ResolversParentTypes['Number']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ObjectTotalsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObjectTotals'] = ResolversParentTypes['ObjectTotals']> = ResolversObject<{
  channels?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  queues?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ObservedDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedData'] = ResolversParentTypes['ObservedData']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ObservedDataCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ObservedDataConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ObservedDataExternalReferencesArgs>>;
  first_observed?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ObservedDataGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ObservedDataJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_observed?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ObservedDataNotesArgs>>;
  number_observed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<ObservedDataObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ObservedDataObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ObservedDataOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataPendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ObservedDataRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ObservedDataReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ObservedDataStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ObservedDataStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ObservedDataStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ObservedDataConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataConnection'] = ResolversParentTypes['ObservedDataConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ObservedDataEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ObservedDataEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataEdge'] = ResolversParentTypes['ObservedDataEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ObservedData'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ObservedDataEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataEditMutations'] = ResolversParentTypes['ObservedDataEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<ObservedDataEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, RequireFields<ObservedDataEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ObservedDataEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, RequireFields<ObservedDataEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpinionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Opinion'] = ResolversParentTypes['Opinion']> = ResolversObject<{
  authors?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<OpinionCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<OpinionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  explanation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<OpinionExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<OpinionGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<OpinionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<OpinionNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<OpinionObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<OpinionObservedDataArgs>>;
  opinion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<OpinionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionPendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<OpinionRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<OpinionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<OpinionStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<OpinionStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<OpinionStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpinionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionConnection'] = ResolversParentTypes['OpinionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OpinionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpinionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionEdge'] = ResolversParentTypes['OpinionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Opinion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OpinionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionEditMutations'] = ResolversParentTypes['OpinionEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<OpinionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<OpinionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<OpinionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<OpinionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Organization'] = ResolversParentTypes['Organization']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<OrganizationCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<OrganizationConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<OrganizationExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<OrganizationGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<OrganizationJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<OrganizationNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<OrganizationObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<OrganizationOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<OrganizationReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  sectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<OrganizationStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<OrganizationStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<OrganizationStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_organization_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_reliability?: Resolver<Maybe<ResolversTypes['OrganizationReliability']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationConnection'] = ResolversParentTypes['OrganizationConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['OrganizationEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationEdge'] = ResolversParentTypes['OrganizationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationEditMutations'] = ResolversParentTypes['OrganizationEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<OrganizationEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<OrganizationEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<OrganizationEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<OrganizationEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OrganizationOrIndividualResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationOrIndividual'] = ResolversParentTypes['OrganizationOrIndividual']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Individual' | 'Organization', ParentType, ContextType>;
}>;

export type OtpElementResolvers<ContextType = any, ParentType extends ResolversParentTypes['OtpElement'] = ResolversParentTypes['OtpElement']> = ResolversObject<{
  secret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type OverviewMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OverviewMetrics'] = ResolversParentTypes['OverviewMetrics']> = ResolversObject<{
  message_stats?: Resolver<Maybe<ResolversTypes['MessagesStats']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  object_totals?: Resolver<Maybe<ResolversTypes['ObjectTotals']>, ParentType, ContextType>;
  queue_totals?: Resolver<Maybe<ResolversTypes['QueueTotals']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{
  endCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  globalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PaymentCardResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCard'] = ResolversParentTypes['PaymentCard']> = ResolversObject<{
  card_number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<PaymentCardCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<PaymentCardConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  cvv?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiration_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PaymentCardExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<PaymentCardExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<PaymentCardGroupingsArgs>>;
  holder_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PaymentCardImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<PaymentCardIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<PaymentCardJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<PaymentCardNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<PaymentCardObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<PaymentCardOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PaymentCardPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<PaymentCardReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PaymentCardStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<PaymentCardStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PaymentCardStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<PaymentCardStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PhoneNumberResolvers<ContextType = any, ParentType extends ResolversParentTypes['PhoneNumber'] = ResolversParentTypes['PhoneNumber']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<PhoneNumberCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<PhoneNumberConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PhoneNumberExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<PhoneNumberExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<PhoneNumberGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PhoneNumberImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<PhoneNumberIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<PhoneNumberJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<PhoneNumberNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<PhoneNumberObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<PhoneNumberOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PhoneNumberPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<PhoneNumberReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PhoneNumberStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<PhoneNumberStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PhoneNumberStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<PhoneNumberStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PositionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Position'] = ResolversParentTypes['Position']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<PositionCasesArgs>>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<PositionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<PositionExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<PositionGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<PositionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<PositionNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<PositionObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<PositionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionPendingFilesArgs>>;
  postal_code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<PositionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PositionStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<PositionStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<PositionStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  street_address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PositionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionConnection'] = ResolversParentTypes['PositionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PositionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PositionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionEdge'] = ResolversParentTypes['PositionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Position'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PositionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionEditMutations'] = ResolversParentTypes['PositionEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, Partial<PositionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<PositionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<PositionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<PositionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProcessResolvers<ContextType = any, ParentType extends ResolversParentTypes['Process'] = ResolversParentTypes['Process']> = ResolversObject<{
  aslr_enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ProcessCasesArgs>>;
  command_line?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ProcessConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  created_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  cwd?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dep_enabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  descriptions?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  display_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  environment_variables?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ProcessExternalReferencesArgs>>;
  group_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ProcessGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<ProcessIndicatorsArgs>>;
  integrity_level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  is_hidden?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ProcessJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ProcessNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ProcessObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ProcessOpinionsArgs>>;
  owner_sid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessPendingFilesArgs>>;
  pid?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ProcessReportsArgs>>;
  serviceDlls?: Resolver<Maybe<ResolversTypes['StixFileConnection']>, ParentType, ContextType>;
  service_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  service_status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  service_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startup_info?: Resolver<Maybe<Array<Maybe<ResolversTypes['Dictionary']>>>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ProcessStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ProcessStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ProcessStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<ProcessStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  window_title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProviderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Provider'] = ResolversParentTypes['Provider']> = ResolversObject<{
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  strategy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  about?: Resolver<Maybe<ResolversTypes['AppInfo']>, ParentType, ContextType>;
  administrativeArea?: Resolver<Maybe<ResolversTypes['AdministrativeArea']>, ParentType, ContextType, RequireFields<QueryAdministrativeAreaArgs, 'id'>>;
  administrativeAreas?: Resolver<Maybe<ResolversTypes['AdministrativeAreaConnection']>, ParentType, ContextType, Partial<QueryAdministrativeAreasArgs>>;
  assignees?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType, Partial<QueryAssigneesArgs>>;
  attackPattern?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<QueryAttackPatternArgs>>;
  attackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType, Partial<QueryAttackPatternsArgs>>;
  bookmarks?: Resolver<Maybe<ResolversTypes['StixDomainObjectConnection']>, ParentType, ContextType, Partial<QueryBookmarksArgs>>;
  campaign?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<QueryCampaignArgs>>;
  campaigns?: Resolver<Maybe<ResolversTypes['CampaignConnection']>, ParentType, ContextType, Partial<QueryCampaignsArgs>>;
  campaignsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryCampaignsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  capabilities?: Resolver<Maybe<ResolversTypes['CapabilityConnection']>, ParentType, ContextType, Partial<QueryCapabilitiesArgs>>;
  case?: Resolver<Maybe<ResolversTypes['Case']>, ParentType, ContextType, RequireFields<QueryCaseArgs, 'id'>>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<QueryCasesArgs>>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<QueryChannelArgs, 'id'>>;
  channels?: Resolver<Maybe<ResolversTypes['ChannelConnection']>, ParentType, ContextType, Partial<QueryChannelsArgs>>;
  cities?: Resolver<Maybe<ResolversTypes['CityConnection']>, ParentType, ContextType, Partial<QueryCitiesArgs>>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<QueryCityArgs>>;
  connector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<QueryConnectorArgs, 'id'>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  connectorsForExport?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  connectorsForImport?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  connectorsForWorker?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  container?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, Partial<QueryContainerArgs>>;
  containers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<QueryContainersArgs>>;
  containersObjectsOfObject?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, RequireFields<QueryContainersObjectsOfObjectArgs, 'id'>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType, Partial<QueryCountriesArgs>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<QueryCountryArgs>>;
  courseOfAction?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<QueryCourseOfActionArgs>>;
  coursesOfAction?: Resolver<Maybe<ResolversTypes['CourseOfActionConnection']>, ParentType, ContextType, Partial<QueryCoursesOfActionArgs>>;
  creators?: Resolver<Maybe<ResolversTypes['CreatorConnection']>, ParentType, ContextType, Partial<QueryCreatorsArgs>>;
  dataComponent?: Resolver<Maybe<ResolversTypes['DataComponent']>, ParentType, ContextType, RequireFields<QueryDataComponentArgs, 'id'>>;
  dataComponents?: Resolver<Maybe<ResolversTypes['DataComponentConnection']>, ParentType, ContextType, Partial<QueryDataComponentsArgs>>;
  dataSource?: Resolver<Maybe<ResolversTypes['DataSource']>, ParentType, ContextType, RequireFields<QueryDataSourceArgs, 'id'>>;
  dataSources?: Resolver<Maybe<ResolversTypes['DataSourceConnection']>, ParentType, ContextType, Partial<QueryDataSourcesArgs>>;
  elasticSearchMetrics?: Resolver<Maybe<ResolversTypes['ElasticSearchMetrics']>, ParentType, ContextType>;
  enrichmentConnectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, RequireFields<QueryEnrichmentConnectorsArgs, 'type'>>;
  entitySetting?: Resolver<Maybe<ResolversTypes['EntitySetting']>, ParentType, ContextType, RequireFields<QueryEntitySettingArgs, 'id'>>;
  entitySettingByType?: Resolver<Maybe<ResolversTypes['EntitySetting']>, ParentType, ContextType, RequireFields<QueryEntitySettingByTypeArgs, 'targetType'>>;
  entitySettings?: Resolver<Maybe<ResolversTypes['EntitySettingConnection']>, ParentType, ContextType, Partial<QueryEntitySettingsArgs>>;
  event?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<QueryEventArgs, 'id'>>;
  events?: Resolver<Maybe<ResolversTypes['EventConnection']>, ParentType, ContextType, Partial<QueryEventsArgs>>;
  externalReference?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<QueryExternalReferenceArgs, 'id'>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<QueryExternalReferencesArgs>>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType, RequireFields<QueryFeedArgs, 'id'>>;
  feeds?: Resolver<Maybe<ResolversTypes['FeedConnection']>, ParentType, ContextType, Partial<QueryFeedsArgs>>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileArgs, 'id'>>;
  group?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<QueryGroupArgs, 'id'>>;
  grouping?: Resolver<Maybe<ResolversTypes['Grouping']>, ParentType, ContextType, RequireFields<QueryGroupingArgs, 'id'>>;
  groupingContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryGroupingContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<QueryGroupingsArgs>>;
  groupingsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryGroupingsDistributionArgs, 'field' | 'operation'>>;
  groupingsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryGroupingsNumberArgs>>;
  groupingsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryGroupingsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  groups?: Resolver<Maybe<ResolversTypes['GroupConnection']>, ParentType, ContextType, Partial<QueryGroupsArgs>>;
  identities?: Resolver<Maybe<ResolversTypes['IdentityConnection']>, ParentType, ContextType, Partial<QueryIdentitiesArgs>>;
  identity?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<QueryIdentityArgs, 'id'>>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryImportFilesArgs>>;
  incident?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<QueryIncidentArgs>>;
  incidents?: Resolver<Maybe<ResolversTypes['IncidentConnection']>, ParentType, ContextType, Partial<QueryIncidentsArgs>>;
  incidentsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryIncidentsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  indicator?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<QueryIndicatorArgs, 'id'>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<QueryIndicatorsArgs>>;
  indicatorsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryIndicatorsDistributionArgs, 'field' | 'operation'>>;
  indicatorsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryIndicatorsNumberArgs>>;
  indicatorsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryIndicatorsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  individual?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<QueryIndividualArgs, 'id'>>;
  individuals?: Resolver<Maybe<ResolversTypes['IndividualConnection']>, ParentType, ContextType, Partial<QueryIndividualsArgs>>;
  infrastructure?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<QueryInfrastructureArgs, 'id'>>;
  infrastructures?: Resolver<Maybe<ResolversTypes['InfrastructureConnection']>, ParentType, ContextType, Partial<QueryInfrastructuresArgs>>;
  intrusionSet?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<QueryIntrusionSetArgs>>;
  intrusionSets?: Resolver<Maybe<ResolversTypes['IntrusionSetConnection']>, ParentType, ContextType, Partial<QueryIntrusionSetsArgs>>;
  killChainPhase?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<QueryKillChainPhaseArgs, 'id'>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType, Partial<QueryKillChainPhasesArgs>>;
  label?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, RequireFields<QueryLabelArgs, 'id'>>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, Partial<QueryLabelsArgs>>;
  language?: Resolver<Maybe<ResolversTypes['Language']>, ParentType, ContextType, RequireFields<QueryLanguageArgs, 'id'>>;
  languages?: Resolver<Maybe<ResolversTypes['LanguageConnection']>, ParentType, ContextType, Partial<QueryLanguagesArgs>>;
  location?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<QueryLocationArgs, 'id'>>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType, Partial<QueryLocationsArgs>>;
  logs?: Resolver<Maybe<ResolversTypes['LogConnection']>, ParentType, ContextType, Partial<QueryLogsArgs>>;
  logsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryLogsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  logsWorkerConfig?: Resolver<Maybe<ResolversTypes['LogsWorkerConfig']>, ParentType, ContextType>;
  malware?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<QueryMalwareArgs>>;
  malwares?: Resolver<Maybe<ResolversTypes['MalwareConnection']>, ParentType, ContextType, Partial<QueryMalwaresArgs>>;
  markingDefinition?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, RequireFields<QueryMarkingDefinitionArgs, 'id'>>;
  markingDefinitions?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType, Partial<QueryMarkingDefinitionsArgs>>;
  me?: Resolver<ResolversTypes['MeUser'], ParentType, ContextType>;
  myOpinion?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<QueryMyOpinionArgs, 'id'>>;
  narrative?: Resolver<Maybe<ResolversTypes['Narrative']>, ParentType, ContextType, RequireFields<QueryNarrativeArgs, 'id'>>;
  narratives?: Resolver<Maybe<ResolversTypes['NarrativeConnection']>, ParentType, ContextType, Partial<QueryNarrativesArgs>>;
  note?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<QueryNoteArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<QueryNotesArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<QueryObservedDataArgs>>;
  observedDataContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryObservedDataContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  observedDatas?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<QueryObservedDatasArgs>>;
  observedDatasDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryObservedDatasDistributionArgs, 'field' | 'operation'>>;
  observedDatasNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryObservedDatasNumberArgs>>;
  observedDatasTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryObservedDatasTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  opinion?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<QueryOpinionArgs>>;
  opinionContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryOpinionContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<QueryOpinionsArgs>>;
  opinionsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryOpinionsDistributionArgs, 'field' | 'operation'>>;
  opinionsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryOpinionsNumberArgs>>;
  opinionsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryOpinionsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<QueryOrganizationArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType, Partial<QueryOrganizationsArgs>>;
  otpGeneration?: Resolver<Maybe<ResolversTypes['OtpElement']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryPendingFilesArgs>>;
  platform_theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<QueryPositionArgs, 'id'>>;
  positions?: Resolver<Maybe<ResolversTypes['PositionConnection']>, ParentType, ContextType, Partial<QueryPositionsArgs>>;
  rabbitMQMetrics?: Resolver<Maybe<ResolversTypes['RabbitMQMetrics']>, ParentType, ContextType, Partial<QueryRabbitMqMetricsArgs>>;
  region?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<QueryRegionArgs, 'id'>>;
  regions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType, Partial<QueryRegionsArgs>>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<QueryReportArgs>>;
  reportContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryReportContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<QueryReportsArgs>>;
  reportsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryReportsDistributionArgs, 'field' | 'operation'>>;
  reportsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryReportsNumberArgs>>;
  reportsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryReportsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  retentionRule?: Resolver<Maybe<ResolversTypes['RetentionRule']>, ParentType, ContextType, RequireFields<QueryRetentionRuleArgs, 'id'>>;
  retentionRules?: Resolver<Maybe<ResolversTypes['RetentionRuleConnection']>, ParentType, ContextType, Partial<QueryRetentionRulesArgs>>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<QueryRoleArgs, 'id'>>;
  roles?: Resolver<Maybe<ResolversTypes['RoleConnection']>, ParentType, ContextType, Partial<QueryRolesArgs>>;
  rule?: Resolver<Maybe<ResolversTypes['Rule']>, ParentType, ContextType, RequireFields<QueryRuleArgs, 'id'>>;
  ruleManagerInfo?: Resolver<Maybe<ResolversTypes['RuleManager']>, ParentType, ContextType>;
  rules?: Resolver<Maybe<Array<Maybe<ResolversTypes['Rule']>>>, ParentType, ContextType>;
  runtimeAttributes?: Resolver<Maybe<ResolversTypes['AttributeConnection']>, ParentType, ContextType, RequireFields<QueryRuntimeAttributesArgs, 'attributeName'>>;
  schemaAttributes?: Resolver<Maybe<ResolversTypes['AttributeConnection']>, ParentType, ContextType, RequireFields<QuerySchemaAttributesArgs, 'elementType'>>;
  sector?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<QuerySectorArgs>>;
  sectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType, Partial<QuerySectorsArgs>>;
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserSession']>>>, ParentType, ContextType>;
  settings?: Resolver<ResolversTypes['Settings'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType, RequireFields<QueryStatusArgs, 'id'>>;
  statusTemplate?: Resolver<Maybe<ResolversTypes['StatusTemplate']>, ParentType, ContextType, RequireFields<QueryStatusTemplateArgs, 'id'>>;
  statusTemplates?: Resolver<Maybe<ResolversTypes['StatusTemplateConnection']>, ParentType, ContextType, Partial<QueryStatusTemplatesArgs>>;
  statuses?: Resolver<Maybe<ResolversTypes['StatusConnection']>, ParentType, ContextType, Partial<QueryStatusesArgs>>;
  stix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QueryStixArgs, 'id'>>;
  stixCoreObject?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectArgs, 'id'>>;
  stixCoreObjectOrStixCoreRelationship?: Resolver<Maybe<ResolversTypes['StixCoreObjectOrStixCoreRelationship']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectOrStixCoreRelationshipArgs, 'id'>>;
  stixCoreObjectRaw?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectRawArgs, 'id'>>;
  stixCoreObjects?: Resolver<Maybe<ResolversTypes['StixCoreObjectConnection']>, ParentType, ContextType, Partial<QueryStixCoreObjectsArgs>>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreObjectsExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectsExportFilesArgs, 'type'>>;
  stixCoreObjectsMultiDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['MultiDistribution']>>>, ParentType, ContextType, RequireFields<QueryStixCoreObjectsMultiDistributionArgs, 'field' | 'operation'>>;
  stixCoreObjectsMultiNumber?: Resolver<Maybe<Array<Maybe<ResolversTypes['Number']>>>, ParentType, ContextType, Partial<QueryStixCoreObjectsMultiNumberArgs>>;
  stixCoreObjectsMultiTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['MultiTimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCoreObjectsMultiTimeSeriesArgs, 'interval' | 'operation' | 'startDate'>>;
  stixCoreObjectsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCoreObjectsNumberArgs>>;
  stixCoreObjectsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCoreObjectsTimeSeriesArgs, 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixCoreRelationship?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipArgs>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationshipsExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsExportFilesArgs, 'type'>>;
  stixCoreRelationshipsMultiTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['MultiTimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsMultiTimeSeriesArgs, 'interval' | 'operation' | 'startDate'>>;
  stixCoreRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipsNumberArgs>>;
  stixCoreRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsTimeSeriesArgs, 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixCyberObservable?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<QueryStixCyberObservableArgs, 'id'>>;
  stixCyberObservableRelationship?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipsArgs>>;
  stixCyberObservableRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservableRelationshipsDistributionArgs, 'field' | 'fromId' | 'operation'>>;
  stixCyberObservableRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipsNumberArgs>>;
  stixCyberObservableRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservableRelationshipsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixCyberObservables?: Resolver<Maybe<ResolversTypes['StixCyberObservableConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservablesArgs>>;
  stixCyberObservablesDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservablesDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservablesExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservablesExportFilesArgs>>;
  stixCyberObservablesNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCyberObservablesNumberArgs>>;
  stixCyberObservablesTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, Partial<QueryStixCyberObservablesTimeSeriesArgs>>;
  stixDomainObject?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<QueryStixDomainObjectArgs, 'id'>>;
  stixDomainObjects?: Resolver<Maybe<ResolversTypes['StixDomainObjectConnection']>, ParentType, ContextType, Partial<QueryStixDomainObjectsArgs>>;
  stixDomainObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsDistributionArgs, 'field' | 'operation'>>;
  stixDomainObjectsExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsExportFilesArgs, 'type'>>;
  stixDomainObjectsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixDomainObjectsNumberArgs>>;
  stixDomainObjectsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsTimeSeriesArgs, 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixMetaRelationship?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipArgs>>;
  stixMetaRelationships?: Resolver<Maybe<ResolversTypes['StixMetaRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipsArgs>>;
  stixMetaRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixMetaRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixMetaRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipsNumberArgs>>;
  stixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType, RequireFields<QueryStixObjectOrStixRelationshipArgs, 'id'>>;
  stixRelationship?: Resolver<Maybe<ResolversTypes['StixRelationship']>, ParentType, ContextType, Partial<QueryStixRelationshipArgs>>;
  stixRelationships?: Resolver<Maybe<ResolversTypes['StixRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixRelationshipsArgs>>;
  stixSightingRelationship?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipArgs>>;
  stixSightingRelationships?: Resolver<Maybe<ResolversTypes['StixSightingRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipsArgs>>;
  stixSightingRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixSightingRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixSightingRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipsNumberArgs>>;
  stixSightingRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixSightingRelationshipsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  streamCollection?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<QueryStreamCollectionArgs, 'id'>>;
  streamCollections?: Resolver<Maybe<ResolversTypes['StreamCollectionConnection']>, ParentType, ContextType, Partial<QueryStreamCollectionsArgs>>;
  subType?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<QuerySubTypeArgs, 'id'>>;
  subTypes?: Resolver<ResolversTypes['SubTypeConnection'], ParentType, ContextType, Partial<QuerySubTypesArgs>>;
  synchronizer?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<QuerySynchronizerArgs, 'id'>>;
  synchronizers?: Resolver<Maybe<ResolversTypes['SynchronizerConnection']>, ParentType, ContextType, Partial<QuerySynchronizersArgs>>;
  system?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<QuerySystemArgs>>;
  systems?: Resolver<Maybe<ResolversTypes['SystemConnection']>, ParentType, ContextType, Partial<QuerySystemsArgs>>;
  task?: Resolver<Maybe<ResolversTypes['Task']>, ParentType, ContextType, RequireFields<QueryTaskArgs, 'id'>>;
  tasks?: Resolver<Maybe<ResolversTypes['TaskConnection']>, ParentType, ContextType, Partial<QueryTasksArgs>>;
  taxiiCollection?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, RequireFields<QueryTaxiiCollectionArgs, 'id'>>;
  taxiiCollections?: Resolver<Maybe<ResolversTypes['TaxiiCollectionConnection']>, ParentType, ContextType, Partial<QueryTaxiiCollectionsArgs>>;
  threatActor?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<QueryThreatActorArgs>>;
  threatActors?: Resolver<Maybe<ResolversTypes['ThreatActorConnection']>, ParentType, ContextType, Partial<QueryThreatActorsArgs>>;
  tool?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<QueryToolArgs>>;
  tools?: Resolver<Maybe<ResolversTypes['ToolConnection']>, ParentType, ContextType, Partial<QueryToolsArgs>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'id'>>;
  userSubscription?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, RequireFields<QueryUserSubscriptionArgs, 'id'>>;
  userSubscriptions?: Resolver<Maybe<ResolversTypes['UserSubscriptionConnection']>, ParentType, ContextType, Partial<QueryUserSubscriptionsArgs>>;
  users?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType, Partial<QueryUsersArgs>>;
  vocabularies?: Resolver<Maybe<ResolversTypes['VocabularyConnection']>, ParentType, ContextType, Partial<QueryVocabulariesArgs>>;
  vocabulary?: Resolver<Maybe<ResolversTypes['Vocabulary']>, ParentType, ContextType, RequireFields<QueryVocabularyArgs, 'id'>>;
  vocabularyCategories?: Resolver<Array<ResolversTypes['VocabularyDefinition']>, ParentType, ContextType>;
  vulnerabilities?: Resolver<Maybe<ResolversTypes['VulnerabilityConnection']>, ParentType, ContextType, Partial<QueryVulnerabilitiesArgs>>;
  vulnerability?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<QueryVulnerabilityArgs>>;
  work?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<QueryWorkArgs, 'id'>>;
  works?: Resolver<Maybe<ResolversTypes['WorkConnection']>, ParentType, ContextType, Partial<QueryWorksArgs>>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<QueryWorkspaceArgs>>;
  workspaces?: Resolver<Maybe<ResolversTypes['WorkspaceConnection']>, ParentType, ContextType, Partial<QueryWorkspacesArgs>>;
}>;

export type QueryTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueryTask'] = ResolversParentTypes['QueryTask']> = ResolversObject<{
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_filters?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_search?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueueArgumentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueArguments'] = ResolversParentTypes['QueueArguments']> = ResolversObject<{
  config?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueueMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueMetrics'] = ResolversParentTypes['QueueMetrics']> = ResolversObject<{
  arguments?: Resolver<Maybe<ResolversTypes['QueueArguments']>, ParentType, ContextType>;
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  idle_since?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  message_stats?: Resolver<Maybe<ResolversTypes['MessagesStats']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_ready?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_unacknowledged?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueueTotalsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueTotals'] = ResolversParentTypes['QueueTotals']> = ResolversObject<{
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_ready?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_unacknowledged?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RabbitMqConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RabbitMQConnection'] = ResolversParentTypes['RabbitMQConnection']> = ResolversObject<{
  ca?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  host?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pass?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  port?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  use_ssl?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vhost?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RabbitMqMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RabbitMQMetrics'] = ResolversParentTypes['RabbitMQMetrics']> = ResolversObject<{
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  overview?: Resolver<Maybe<ResolversTypes['OverviewMetrics']>, ParentType, ContextType>;
  queues?: Resolver<Maybe<Array<Maybe<ResolversTypes['QueueMetrics']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RegionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Region'] = ResolversParentTypes['Region']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<RegionCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<RegionConnectorsArgs>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<RegionExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<RegionGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionImportFilesArgs>>;
  isSubRegion?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<RegionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<RegionNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<RegionObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<RegionOpinionsArgs>>;
  parentRegions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<RegionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<RegionStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<RegionStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<RegionStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  subRegions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RegionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionConnection'] = ResolversParentTypes['RegionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RegionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RegionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionEdge'] = ResolversParentTypes['RegionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Region'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RegionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionEditMutations'] = ResolversParentTypes['RegionEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, Partial<RegionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<RegionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<RegionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<RegionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportResolvers<ContextType = any, ParentType extends ResolversParentTypes['Report'] = ResolversParentTypes['Report']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ReportCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ReportConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  deleteWithElementsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ReportExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ReportGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ReportJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ReportNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<ReportObjectsArgs>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ReportObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ReportOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportPendingFilesArgs>>;
  published?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ReportRelatedContainersArgs>>;
  report_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ReportReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ReportStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ReportStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ReportStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportConnection'] = ResolversParentTypes['ReportConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReportEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportEdge'] = ResolversParentTypes['ReportEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Report'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReportEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportEditMutations'] = ResolversParentTypes['ReportEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<ReportEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, Partial<ReportEditMutationsDeleteArgs>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<ReportEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ReportEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<ReportEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RetentionRuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRule'] = ResolversParentTypes['RetentionRule']> = ResolversObject<{
  filters?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  last_deleted_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  max_retention?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  remaining_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RetentionRuleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleConnection'] = ResolversParentTypes['RetentionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RetentionRuleEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RetentionRuleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleEdge'] = ResolversParentTypes['RetentionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['RetentionRule'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RetentionRuleEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleEditMutations'] = ResolversParentTypes['RetentionRuleEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['RetentionRule']>, ParentType, ContextType, RequireFields<RetentionRuleEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = ResolversObject<{
  capabilities?: Resolver<Maybe<Array<Maybe<ResolversTypes['Capability']>>>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  default_assignation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleConnection'] = ResolversParentTypes['RoleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RoleEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEdge'] = ResolversParentTypes['RoleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RoleEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEditMutations'] = ResolversParentTypes['RoleEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, Partial<RoleEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<RoleEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<RoleEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<RoleEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Rule'] = ResolversParentTypes['Rule']> = ResolversObject<{
  activated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  display?: Resolver<Maybe<ResolversTypes['Display']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RuleExecutionErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleExecutionError'] = ResolversParentTypes['RuleExecutionError']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RuleManagerResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleManager'] = ResolversParentTypes['RuleManager']> = ResolversObject<{
  activated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['RuleExecutionError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastEventId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RuleTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleTask'] = ResolversParentTypes['RuleTask']> = ResolversObject<{
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  enable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  rule?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SearchMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchMetrics'] = ResolversParentTypes['SearchMetrics']> = ResolversObject<{
  fetch_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SectorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sector'] = ResolversParentTypes['Sector']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<SectorCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SectorConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SectorExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<SectorGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorImportFilesArgs>>;
  isSubSector?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SectorJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SectorNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<SectorObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SectorOpinionsArgs>>;
  parentSectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SectorReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SectorStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SectorStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SectorStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  subSectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  targetedOrganizations?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SectorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorConnection'] = ResolversParentTypes['SectorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SectorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SectorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorEdge'] = ResolversParentTypes['SectorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Sector'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SectorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorEditMutations'] = ResolversParentTypes['SectorEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<SectorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, RequireFields<SectorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<SectorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, RequireFields<SectorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SessionDetailResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionDetail'] = ResolversParentTypes['SessionDetail']> = ResolversObject<{
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ttl?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Settings'] = ResolversParentTypes['Settings']> = ResolversObject<{
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  otp_mandatory?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  platform_cluster?: Resolver<ResolversTypes['Cluster'], ParentType, ContextType>;
  platform_email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_favicon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_feature_flags?: Resolver<Maybe<Array<ResolversTypes['Module']>>, ParentType, ContextType>;
  platform_language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_login_message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_map_tile_server_dark?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_map_tile_server_light?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_modules?: Resolver<Maybe<Array<ResolversTypes['Module']>>, ParentType, ContextType>;
  platform_organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  platform_providers?: Resolver<Array<ResolversTypes['Provider']>, ParentType, ContextType>;
  platform_reference_attachment?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  platform_theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_accent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_background?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_logo_collapsed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_logo_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_nav?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_paper?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_primary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_secondary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_accent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_background?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_logo_collapsed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_logo_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_nav?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_paper?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_primary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_secondary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SettingsEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettingsEditMutations'] = ResolversParentTypes['SettingsEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType, Partial<SettingsEditMutationsContextPatchArgs>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType, RequireFields<SettingsEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SoftwareResolvers<ContextType = any, ParentType extends ResolversParentTypes['Software'] = ResolversParentTypes['Software']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<SoftwareCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SoftwareConnectorsArgs>>;
  cpe?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwareExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SoftwareExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<SoftwareGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwareImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<SoftwareIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SoftwareJobsArgs>>;
  languages?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SoftwareNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<SoftwareObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SoftwareOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwarePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SoftwareReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SoftwareStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SoftwareStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SoftwareStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<SoftwareStixCyberObservableRelationshipsArgs>>;
  swid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vendor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vulnerabilities?: Resolver<Maybe<ResolversTypes['VulnerabilityConnection']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusResolvers<ContextType = any, ParentType extends ResolversParentTypes['Status'] = ResolversParentTypes['Status']> = ResolversObject<{
  disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['StatusTemplate']>, ParentType, ContextType>;
  template_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusConnection'] = ResolversParentTypes['StatusConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['StatusEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusEdge'] = ResolversParentTypes['StatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Status'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusTemplateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplate'] = ResolversParentTypes['StatusTemplate']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  usages?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusTemplateConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplateConnection'] = ResolversParentTypes['StatusTemplateConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StatusTemplateEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatusTemplateEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplateEdge'] = ResolversParentTypes['StatusTemplateEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObject'] = ResolversParentTypes['StixCoreObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'BankAccount' | 'Campaign' | 'Case' | 'Channel' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'DataComponent' | 'DataSource' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Event' | 'Grouping' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'Language' | 'MacAddr' | 'Malware' | 'MediaContent' | 'Mutex' | 'Narrative' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'PaymentCard' | 'PhoneNumber' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixCoreObjectCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixCoreObjectConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCoreObjectExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixCoreObjectGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixCoreObjectJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCoreObjectNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<StixCoreObjectObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCoreObjectOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCoreObjectReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixCoreObjectStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCoreObjectStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixCoreObjectStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixCoreObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectConnection'] = ResolversParentTypes['StixCoreObjectConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCoreObjectEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectEdge'] = ResolversParentTypes['StixCoreObjectEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCoreObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreObjectEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectEditMutations'] = ResolversParentTypes['StixCoreObjectEditMutations']> = ResolversObject<{
  askEnrichment?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsAskEnrichmentArgs, 'connectorId'>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsExportPushArgs, 'file'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsImportPushArgs, 'file'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCoreObjectEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, Partial<StixCoreObjectEditMutationsRelationsAddArgs>>;
  restrictionOrganizationAdd?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsRestrictionOrganizationAddArgs, 'organizationId'>>;
  restrictionOrganizationDelete?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsRestrictionOrganizationDeleteArgs, 'organizationId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreObjectOrStixCoreRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectOrStixCoreRelationship'] = ResolversParentTypes['StixCoreObjectOrStixCoreRelationship']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'BankAccount' | 'Campaign' | 'Case' | 'Channel' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'DataComponent' | 'DataSource' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'EntitySetting' | 'Event' | 'Grouping' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'Language' | 'MacAddr' | 'Malware' | 'MediaContent' | 'Mutex' | 'Narrative' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'PaymentCard' | 'PhoneNumber' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixCoreRelationship' | 'StixFile' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
}>;

export type StixCoreRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationship'] = ResolversParentTypes['StixCoreRelationship']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipExternalReferencesArgs>>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipStixCoreRelationshipsArgs>>;
  stop_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipConnection'] = ResolversParentTypes['StixCoreRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCoreRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipEdge'] = ResolversParentTypes['StixCoreRelationshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCoreRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCoreRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipEditMutations'] = ResolversParentTypes['StixCoreRelationshipEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<StixCoreRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCoreRelationshipEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  restrictionOrganizationAdd?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsRestrictionOrganizationAddArgs, 'organizationId'>>;
  restrictionOrganizationDelete?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsRestrictionOrganizationDeleteArgs, 'organizationId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservable'] = ResolversParentTypes['StixCyberObservable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Artifact' | 'AutonomousSystem' | 'BankAccount' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'MacAddr' | 'MediaContent' | 'Mutex' | 'NetworkTraffic' | 'PaymentCard' | 'PhoneNumber' | 'Process' | 'Software' | 'StixFile' | 'Text' | 'Url' | 'UserAccount' | 'UserAgent' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixCyberObservableCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixCyberObservableConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservableExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCyberObservableExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixCyberObservableGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservableImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<StixCyberObservableIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixCyberObservableJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCyberObservableNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<StixCyberObservableObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCyberObservableOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservablePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCyberObservableReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixCyberObservableStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCyberObservableStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixCyberObservableStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<StixCyberObservableStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixCyberObservableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableConnection'] = ResolversParentTypes['StixCyberObservableConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['StixCyberObservableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableEdge'] = ResolversParentTypes['StixCyberObservableEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCyberObservable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableEditMutations'] = ResolversParentTypes['StixCyberObservableEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsExportPushArgs, 'file'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsImportPushArgs, 'file'>>;
  promote?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsRelationsAddArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationship'] = ResolversParentTypes['StixCyberObservableRelationship']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipNotesArgs>>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  stop_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipConnection'] = ResolversParentTypes['StixCyberObservableRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCyberObservableRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipEdge'] = ResolversParentTypes['StixCyberObservableRelationshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCyberObservableRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixCyberObservableRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipEditMutations'] = ResolversParentTypes['StixCyberObservableRelationshipEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, RequireFields<StixCyberObservableRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixDomainObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObject'] = ResolversParentTypes['StixDomainObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'AttackPattern' | 'Campaign' | 'Case' | 'Channel' | 'City' | 'Country' | 'CourseOfAction' | 'DataComponent' | 'DataSource' | 'Event' | 'Grouping' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'Language' | 'Malware' | 'Narrative' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Region' | 'Report' | 'Sector' | 'System' | 'ThreatActor' | 'Tool' | 'Vulnerability', ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixDomainObjectCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixDomainObjectConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixDomainObjectExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixDomainObjectGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixDomainObjectJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixDomainObjectNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<StixDomainObjectObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixDomainObjectOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixDomainObjectReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixDomainObjectStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixDomainObjectStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixDomainObjectStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixDomainObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectConnection'] = ResolversParentTypes['StixDomainObjectConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixDomainObjectEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixDomainObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectEdge'] = ResolversParentTypes['StixDomainObjectEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixDomainObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixDomainObjectEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectEditMutations'] = ResolversParentTypes['StixDomainObjectEditMutations']> = ResolversObject<{
  changeType?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsChangeTypeArgs, 'newType'>>;
  contextClean?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsExportPushArgs, 'file'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsImportPushArgs, 'file'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsRelationDeleteArgs, 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsRelationsAddArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixEditMutations'] = ResolversParentTypes['StixEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  merge?: Resolver<Maybe<ResolversTypes['StixObject']>, ParentType, ContextType, RequireFields<StixEditMutationsMergeArgs, 'stixObjectsIds'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixFileResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixFile'] = ResolversParentTypes['StixFile']> = ResolversObject<{
  atime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixFileCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixFileConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  ctime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFileExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixFileExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixFileGroupingsArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFileImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<StixFileIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixFileJobsArgs>>;
  magic_number_hex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mime_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mtime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name_enc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixFileNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  obsContent?: Resolver<Maybe<ResolversTypes['Artifact']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<StixFileObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixFileOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFilePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixFileReportsArgs>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixFileStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixFileStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<StixFileStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<StixFileStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_additional_names?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixFileConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixFileConnection'] = ResolversParentTypes['StixFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixFileEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixFileEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixFileEdge'] = ResolversParentTypes['StixFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixFile'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface StixIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['StixId'], any> {
  name: 'StixId';
}

export type StixMetaObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaObject'] = ResolversParentTypes['StixMetaObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ExternalReference' | 'KillChainPhase' | 'Label' | 'MarkingDefinition' | 'Vocabulary', ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixMetaRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationship'] = ResolversParentTypes['StixMetaRelationship']> = ResolversObject<{
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixMetaRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationshipConnection'] = ResolversParentTypes['StixMetaRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixMetaRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixMetaRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationshipEdge'] = ResolversParentTypes['StixMetaRelationshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixMetaRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObject'] = ResolversParentTypes['StixObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'BankAccount' | 'Campaign' | 'Case' | 'Channel' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'DataComponent' | 'DataSource' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Event' | 'ExternalReference' | 'Grouping' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'Language' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'MediaContent' | 'Mutex' | 'Narrative' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'PaymentCard' | 'PhoneNumber' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vocabulary' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixObjectOrStixRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationship'] = ResolversParentTypes['StixObjectOrStixRelationship']> = ResolversObject<{
  __resolveType: TypeResolveFn<'AdministrativeArea' | 'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'BankAccount' | 'Campaign' | 'Case' | 'Channel' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'DataComponent' | 'DataSource' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'EntitySetting' | 'Event' | 'ExternalReference' | 'Grouping' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'Language' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'MediaContent' | 'Mutex' | 'Narrative' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'PaymentCard' | 'PhoneNumber' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixFile' | 'StixMetaRelationship' | 'StixSightingRelationship' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate', ParentType, ContextType>;
}>;

export type StixObjectOrStixRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipConnection'] = ResolversParentTypes['StixObjectOrStixRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixObjectOrStixRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixObjectOrStixRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipEdge'] = ResolversParentTypes['StixObjectOrStixRelationshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixObjectOrStixRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixObjectOrStixRelationshipRefConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipRefConnection'] = ResolversParentTypes['StixObjectOrStixRelationshipRefConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixObjectOrStixRelationshipRefEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipRefEdge'] = ResolversParentTypes['StixObjectOrStixRelationshipRefEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixObjectOrStixRelationship'], ParentType, ContextType>;
  types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface StixRefScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['StixRef'], any> {
  name: 'StixRef';
}

export type StixRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationship'] = ResolversParentTypes['StixRelationship']> = ResolversObject<{
  __resolveType: TypeResolveFn<'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixMetaRelationship' | 'StixSightingRelationship', ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
}>;

export type StixRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipConnection'] = ResolversParentTypes['StixRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipEdge'] = ResolversParentTypes['StixRelationshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipEditMutations'] = ResolversParentTypes['StixRelationshipEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixSightingRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationship'] = ResolversParentTypes['StixSightingRelationship']> = ResolversObject<{
  attribute_count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_negative?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixSightingRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipConnection'] = ResolversParentTypes['StixSightingRelationshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixSightingRelationshipsEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixSightingRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipEditMutations'] = ResolversParentTypes['StixSightingRelationshipEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<StixSightingRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixSightingRelationshipEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  restrictionOrganizationAdd?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsRestrictionOrganizationAddArgs, 'organizationId'>>;
  restrictionOrganizationDelete?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsRestrictionOrganizationDeleteArgs, 'organizationId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StixSightingRelationshipsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipsEdge'] = ResolversParentTypes['StixSightingRelationshipsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixSightingRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamCollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollection'] = ResolversParentTypes['StreamCollection']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<Maybe<ResolversTypes['Group']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamCollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionConnection'] = ResolversParentTypes['StreamCollectionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StreamCollectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamCollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionEdge'] = ResolversParentTypes['StreamCollectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StreamCollection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StreamCollectionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionEditMutations'] = ResolversParentTypes['StreamCollectionEditMutations']> = ResolversObject<{
  addGroup?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsAddGroupArgs, 'id'>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  deleteGroup?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsDeleteGroupArgs, 'id'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubType'] = ResolversParentTypes['SubType']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  settings?: Resolver<Maybe<ResolversTypes['EntitySetting']>, ParentType, ContextType>;
  statuses?: Resolver<Maybe<ResolversTypes['StatusConnection']>, ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubTypeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeConnection'] = ResolversParentTypes['SubTypeConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['SubTypeEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubTypeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeEdge'] = ResolversParentTypes['SubTypeEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SubType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubTypeEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeEditMutations'] = ResolversParentTypes['SubTypeEditMutations']> = ResolversObject<{
  statusAdd?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, Partial<SubTypeEditMutationsStatusAddArgs>>;
  statusDelete?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<SubTypeEditMutationsStatusDeleteArgs, 'statusId'>>;
  statusFieldPatch?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<SubTypeEditMutationsStatusFieldPatchArgs, 'input' | 'statusId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
  externalReference?: SubscriptionResolver<Maybe<ResolversTypes['ExternalReference']>, "externalReference", ParentType, ContextType, RequireFields<SubscriptionExternalReferenceArgs, 'id'>>;
  group?: SubscriptionResolver<Maybe<ResolversTypes['Group']>, "group", ParentType, ContextType, RequireFields<SubscriptionGroupArgs, 'id'>>;
  killChainPhase?: SubscriptionResolver<Maybe<ResolversTypes['KillChainPhase']>, "killChainPhase", ParentType, ContextType, RequireFields<SubscriptionKillChainPhaseArgs, 'id'>>;
  label?: SubscriptionResolver<Maybe<ResolversTypes['Label']>, "label", ParentType, ContextType, RequireFields<SubscriptionLabelArgs, 'id'>>;
  markingDefinition?: SubscriptionResolver<Maybe<ResolversTypes['MarkingDefinition']>, "markingDefinition", ParentType, ContextType, RequireFields<SubscriptionMarkingDefinitionArgs, 'id'>>;
  settings?: SubscriptionResolver<Maybe<ResolversTypes['Settings']>, "settings", ParentType, ContextType, RequireFields<SubscriptionSettingsArgs, 'id'>>;
  statusTemplate?: SubscriptionResolver<Maybe<ResolversTypes['StatusTemplate']>, "statusTemplate", ParentType, ContextType, RequireFields<SubscriptionStatusTemplateArgs, 'id'>>;
  stixCoreObject?: SubscriptionResolver<Maybe<ResolversTypes['StixCoreObject']>, "stixCoreObject", ParentType, ContextType, RequireFields<SubscriptionStixCoreObjectArgs, 'id'>>;
  stixCoreRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixCoreRelationship']>, "stixCoreRelationship", ParentType, ContextType, RequireFields<SubscriptionStixCoreRelationshipArgs, 'id'>>;
  stixCyberObservable?: SubscriptionResolver<Maybe<ResolversTypes['StixCyberObservable']>, "stixCyberObservable", ParentType, ContextType, RequireFields<SubscriptionStixCyberObservableArgs, 'id'>>;
  stixCyberObservableRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, "stixCyberObservableRelationship", ParentType, ContextType, RequireFields<SubscriptionStixCyberObservableRelationshipArgs, 'id'>>;
  stixDomainObject?: SubscriptionResolver<Maybe<ResolversTypes['StixDomainObject']>, "stixDomainObject", ParentType, ContextType, RequireFields<SubscriptionStixDomainObjectArgs, 'id'>>;
  stixSightingRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixSightingRelationship']>, "stixSightingRelationship", ParentType, ContextType, RequireFields<SubscriptionStixSightingRelationshipArgs, 'id'>>;
  user?: SubscriptionResolver<Maybe<ResolversTypes['User']>, "user", ParentType, ContextType, RequireFields<SubscriptionUserArgs, 'id'>>;
  workspace?: SubscriptionResolver<Maybe<ResolversTypes['Workspace']>, "workspace", ParentType, ContextType, RequireFields<SubscriptionWorkspaceArgs, 'id'>>;
}>;

export type SynchronizerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Synchronizer'] = ResolversParentTypes['Synchronizer']> = ResolversObject<{
  current_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  listen_deletion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  no_dependencies?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  running?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  ssl_verify?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  stream_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SynchronizerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerConnection'] = ResolversParentTypes['SynchronizerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SynchronizerEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SynchronizerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerEdge'] = ResolversParentTypes['SynchronizerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Synchronizer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SynchronizerEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerEditMutations'] = ResolversParentTypes['SynchronizerEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<SynchronizerEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SystemResolvers<ContextType = any, ParentType extends ResolversParentTypes['System'] = ResolversParentTypes['System']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<SystemCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SystemConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SystemExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<SystemGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SystemJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SystemNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<SystemObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SystemOpinionsArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SystemReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SystemStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SystemStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<SystemStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SystemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemConnection'] = ResolversParentTypes['SystemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SystemEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SystemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemEdge'] = ResolversParentTypes['SystemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['System'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SystemEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemEditMutations'] = ResolversParentTypes['SystemEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<SystemEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, RequireFields<SystemEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<SystemEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, RequireFields<SystemEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['Task'] = ResolversParentTypes['Task']> = ResolversObject<{
  __resolveType: TypeResolveFn<'ListTask' | 'QueryTask' | 'RuleTask', ParentType, ContextType>;
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
}>;

export type TaskActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskAction'] = ResolversParentTypes['TaskAction']> = ResolversObject<{
  context?: Resolver<Maybe<ResolversTypes['TaskContext']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskActionType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaskConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskConnection'] = ResolversParentTypes['TaskConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskConnectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaskConnectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskConnectionEdge'] = ResolversParentTypes['TaskConnectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Task'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaskContextResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskContext'] = ResolversParentTypes['TaskContext']> = ResolversObject<{
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskContextType']>, ParentType, ContextType>;
  values?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaskErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskError'] = ResolversParentTypes['TaskError']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxiiCollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollection'] = ResolversParentTypes['TaxiiCollection']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxiiCollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionConnection'] = ResolversParentTypes['TaxiiCollectionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaxiiCollectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxiiCollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionEdge'] = ResolversParentTypes['TaxiiCollectionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['TaxiiCollection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TaxiiCollectionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionEditMutations'] = ResolversParentTypes['TaxiiCollectionEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, RequireFields<TaxiiCollectionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TextResolvers<ContextType = any, ParentType extends ResolversParentTypes['Text'] = ResolversParentTypes['Text']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<TextCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<TextConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<TextExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<TextGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<TextIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<TextJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<TextNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<TextObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<TextOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<TextReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<TextStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<TextStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<TextStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<TextStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThreatActorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActor'] = ResolversParentTypes['ThreatActor']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ThreatActorCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ThreatActorConnectorsArgs>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ThreatActorExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  goals?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ThreatActorGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ThreatActorJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ThreatActorNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ThreatActorObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ThreatActorOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorPendingFilesArgs>>;
  personal_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  primary_motivation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ThreatActorReportsArgs>>;
  resource_level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  secondary_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  sophistication?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ThreatActorStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ThreatActorStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ThreatActorStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  threat_actor_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThreatActorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorConnection'] = ResolversParentTypes['ThreatActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ThreatActorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThreatActorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorEdge'] = ResolversParentTypes['ThreatActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ThreatActor'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ThreatActorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorEditMutations'] = ResolversParentTypes['ThreatActorEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<ThreatActorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, RequireFields<ThreatActorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ThreatActorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, RequireFields<ThreatActorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TimeSeriesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeSeries'] = ResolversParentTypes['TimeSeries']> = ResolversObject<{
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ToolResolvers<ContextType = any, ParentType extends ResolversParentTypes['Tool'] = ResolversParentTypes['Tool']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<ToolCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ToolConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ToolExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<ToolGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ToolJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ToolNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<ToolObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ToolOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ToolReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ToolStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ToolStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<ToolStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tool_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  tool_version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ToolConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolConnection'] = ResolversParentTypes['ToolConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ToolEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ToolEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolEdge'] = ResolversParentTypes['ToolEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Tool'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ToolEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolEditMutations'] = ResolversParentTypes['ToolEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<ToolEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, RequireFields<ToolEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ToolEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, RequireFields<ToolEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface UploadScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type UrlResolvers<ContextType = any, ParentType extends ResolversParentTypes['Url'] = ResolversParentTypes['Url']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<UrlCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UrlConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UrlExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<UrlGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UrlIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UrlJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UrlNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<UrlObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UrlOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UrlReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UrlStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UrlStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UrlStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UrlStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  allowed_marking?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarkingDefinition']>>>, ParentType, ContextType>;
  api_token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  capabilities?: Resolver<Array<Maybe<ResolversTypes['Capability']>>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dashboard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<ResolversTypes['GroupConnection']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  otp_activated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  otp_mandatory?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  otp_qr?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  roles?: Resolver<Array<Maybe<ResolversTypes['Role']>>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['SessionDetail']>>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userSubscriptions?: Resolver<Maybe<ResolversTypes['UserSubscriptionConnection']>, ParentType, ContextType, Partial<UserUserSubscriptionsArgs>>;
  user_email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAccount'] = ResolversParentTypes['UserAccount']> = ResolversObject<{
  account_created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_first_login?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_last_login?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  can_escalate_privs?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<UserAccountCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UserAccountConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  credential?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  credential_last_changed?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  display_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UserAccountExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<UserAccountGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UserAccountIndicatorsArgs>>;
  is_disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_privileged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_service_account?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UserAccountJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UserAccountNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<UserAccountObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UserAccountOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UserAccountReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UserAccountStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UserAccountStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UserAccountStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UserAccountStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserAgentResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAgent'] = ResolversParentTypes['UserAgent']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<UserAgentCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UserAgentConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UserAgentExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<UserAgentGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UserAgentIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UserAgentJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UserAgentNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<UserAgentObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UserAgentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UserAgentReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UserAgentStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UserAgentStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<UserAgentStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UserAgentStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEditMutations'] = ResolversParentTypes['UserEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<UserEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsFieldPatchArgs, 'input'>>;
  organizationAdd?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsOrganizationAddArgs, 'organizationId'>>;
  organizationDelete?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsOrganizationDeleteArgs, 'organizationId'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<UserEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  tokenRenew?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSession'] = ResolversParentTypes['UserSession']> = ResolversObject<{
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['SessionDetail']>>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscription'] = ResolversParentTypes['UserSubscription']> = ResolversObject<{
  cron?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entities?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixDomainObject']>>>, ParentType, ContextType>;
  entities_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  last_run?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  options?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  user_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSubscriptionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionConnection'] = ResolversParentTypes['UserSubscriptionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserSubscriptionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSubscriptionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionEdge'] = ResolversParentTypes['UserSubscriptionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserSubscription'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserSubscriptionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionEditMutations'] = ResolversParentTypes['UserSubscriptionEditMutations']> = ResolversObject<{
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, RequireFields<UserSubscriptionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VocabularyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Vocabulary'] = ResolversParentTypes['Vocabulary']> = ResolversObject<{
  aliases?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  builtIn?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  category?: Resolver<ResolversTypes['VocabularyDefinition'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  usages?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VocabularyConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VocabularyConnection'] = ResolversParentTypes['VocabularyConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['VocabularyEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VocabularyDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VocabularyDefinition'] = ResolversParentTypes['VocabularyDefinition']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  fields?: Resolver<Array<ResolversTypes['VocabularyFieldDefinition']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['VocabularyCategory'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VocabularyEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VocabularyEdge'] = ResolversParentTypes['VocabularyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Vocabulary'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VocabularyFieldDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VocabularyFieldDefinition'] = ResolversParentTypes['VocabularyFieldDefinition']> = ResolversObject<{
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  multiple?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VulnerabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Vulnerability'] = ResolversParentTypes['Vulnerability']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<VulnerabilityCasesArgs>>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<VulnerabilityConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<VulnerabilityExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<VulnerabilityGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<VulnerabilityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<VulnerabilityNotesArgs>>;
  objectAssignee?: Resolver<Maybe<ResolversTypes['AssigneeConnection']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<VulnerabilityObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<VulnerabilityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<VulnerabilityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  softwares?: Resolver<Maybe<ResolversTypes['StixCyberObservableConnection']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<VulnerabilityStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<VulnerabilityStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<VulnerabilityStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_attack_vector?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_availability_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_base_score?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  x_opencti_base_severity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_confidentiality_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_integrity_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VulnerabilityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityConnection'] = ResolversParentTypes['VulnerabilityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['VulnerabilityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VulnerabilityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityEdge'] = ResolversParentTypes['VulnerabilityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Vulnerability'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type VulnerabilityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityEditMutations'] = ResolversParentTypes['VulnerabilityEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<VulnerabilityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, RequireFields<VulnerabilityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<VulnerabilityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, RequireFields<VulnerabilityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WindowsRegistryKeyResolvers<ContextType = any, ParentType extends ResolversParentTypes['WindowsRegistryKey'] = ResolversParentTypes['WindowsRegistryKey']> = ResolversObject<{
  attribute_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<WindowsRegistryKeyConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<WindowsRegistryKeyJobsArgs>>;
  modified_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyNotesArgs>>;
  number_of_subkeys?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<WindowsRegistryKeyStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<WindowsRegistryKeyStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WindowsRegistryValueTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WindowsRegistryValueType'] = ResolversParentTypes['WindowsRegistryValueType']> = ResolversObject<{
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeCasesArgs>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<WindowsRegistryValueTypeConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  data_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeGroupingsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<WindowsRegistryValueTypeJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<WindowsRegistryValueTypeStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<WindowsRegistryValueTypeStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkResolvers<ContextType = any, ParentType extends ResolversParentTypes['Work'] = ResolversParentTypes['Work']> = ResolversObject<{
  completed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  completed_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  connector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  event_source_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  messages?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  processed_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  received_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['State'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  tracking?: Resolver<Maybe<ResolversTypes['WorkTracking']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkConnection'] = ResolversParentTypes['WorkConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkEdge'] = ResolversParentTypes['WorkEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Work'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkEditMutations'] = ResolversParentTypes['WorkEditMutations']> = ResolversObject<{
  addExpectations?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsAddExpectationsArgs>>;
  delete?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ping?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reportExpectation?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsReportExpectationArgs>>;
  toProcessed?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsToProcessedArgs>>;
  toReceived?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsToReceivedArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkMessage'] = ResolversParentTypes['WorkMessage']> = ResolversObject<{
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkTrackingResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkTracking'] = ResolversParentTypes['WorkTracking']> = ResolversObject<{
  import_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  import_last_processed?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  import_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Workspace'] = ResolversParentTypes['Workspace']> = ResolversObject<{
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  manifest?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipRefConnection']>, ParentType, ContextType, Partial<WorkspaceObjectsArgs>>;
  owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspaceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceConnection'] = ResolversParentTypes['WorkspaceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkspaceEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspaceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceEdge'] = ResolversParentTypes['WorkspaceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Workspace'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WorkspaceEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceEditMutations'] = ResolversParentTypes['WorkspaceEditMutations']> = ResolversObject<{
  contextClean?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<WorkspaceEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<WorkspaceEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<WorkspaceEditMutationsRelationsAddArgs>>;
  relationsDelete?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsRelationsDeleteArgs, 'relationship_type' | 'toIds'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type X509CertificateResolvers<ContextType = any, ParentType extends ResolversParentTypes['X509Certificate'] = ResolversParentTypes['X509Certificate']> = ResolversObject<{
  authority_key_identifier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basic_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cases?: Resolver<Maybe<ResolversTypes['CaseConnection']>, ParentType, ContextType, Partial<X509CertificateCasesArgs>>;
  certificate_policies?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<X509CertificateConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Creator']>, ParentType, ContextType>;
  crl_distribution_points?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<ResolversTypes['EditUserContext']>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificateExportFilesArgs>>;
  extended_key_usage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<X509CertificateExternalReferencesArgs>>;
  groupings?: Resolver<Maybe<ResolversTypes['GroupingConnection']>, ParentType, ContextType, Partial<X509CertificateGroupingsArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificateImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<X509CertificateIndicatorsArgs>>;
  inhibit_any_policy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_self_signed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issuer_alternative_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<X509CertificateJobsArgs>>;
  key_usage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<X509CertificateNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objectOrganization?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<X509CertificateObservedDataArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<X509CertificateOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificatePendingFilesArgs>>;
  policy_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  policy_mappings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  private_key_usage_period_not_after?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  private_key_usage_period_not_before?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<X509CertificateReportsArgs>>;
  serial_number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signature_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<X509CertificateStixCoreObjectsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<X509CertificateStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<X509CertificateStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<X509CertificateStixCyberObservableRelationshipsArgs>>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_alternative_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_directory_attributes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_key_identifier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_public_key_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_public_key_exponent?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subject_public_key_modulus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validity_not_after?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validity_not_before?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixId']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  AckDetails?: AckDetailsResolvers<ContextType>;
  AdministrativeArea?: AdministrativeAreaResolvers<ContextType>;
  AdministrativeAreaConnection?: AdministrativeAreaConnectionResolvers<ContextType>;
  AdministrativeAreaEdge?: AdministrativeAreaEdgeResolvers<ContextType>;
  AppDebugDistribution?: AppDebugDistributionResolvers<ContextType>;
  AppDebugStatistics?: AppDebugStatisticsResolvers<ContextType>;
  AppInfo?: AppInfoResolvers<ContextType>;
  AppMemory?: AppMemoryResolvers<ContextType>;
  Artifact?: ArtifactResolvers<ContextType>;
  Assignee?: AssigneeResolvers<ContextType>;
  AssigneeConnection?: AssigneeConnectionResolvers<ContextType>;
  AssigneeEdge?: AssigneeEdgeResolvers<ContextType>;
  AttackPattern?: AttackPatternResolvers<ContextType>;
  AttackPatternConnection?: AttackPatternConnectionResolvers<ContextType>;
  AttackPatternEdge?: AttackPatternEdgeResolvers<ContextType>;
  AttackPatternEditMutations?: AttackPatternEditMutationsResolvers<ContextType>;
  Attribute?: AttributeResolvers<ContextType>;
  AttributeConnection?: AttributeConnectionResolvers<ContextType>;
  AttributeEdge?: AttributeEdgeResolvers<ContextType>;
  AttributeEditMutations?: AttributeEditMutationsResolvers<ContextType>;
  AutonomousSystem?: AutonomousSystemResolvers<ContextType>;
  BankAccount?: BankAccountResolvers<ContextType>;
  BasicObject?: BasicObjectResolvers<ContextType>;
  BasicRelationship?: BasicRelationshipResolvers<ContextType>;
  Campaign?: CampaignResolvers<ContextType>;
  CampaignConnection?: CampaignConnectionResolvers<ContextType>;
  CampaignEdge?: CampaignEdgeResolvers<ContextType>;
  CampaignEditMutations?: CampaignEditMutationsResolvers<ContextType>;
  Capability?: CapabilityResolvers<ContextType>;
  CapabilityConnection?: CapabilityConnectionResolvers<ContextType>;
  CapabilityEdge?: CapabilityEdgeResolvers<ContextType>;
  Case?: CaseResolvers<ContextType>;
  CaseConnection?: CaseConnectionResolvers<ContextType>;
  CaseEdge?: CaseEdgeResolvers<ContextType>;
  Channel?: ChannelResolvers<ContextType>;
  ChannelConnection?: ChannelConnectionResolvers<ContextType>;
  ChannelEdge?: ChannelEdgeResolvers<ContextType>;
  City?: CityResolvers<ContextType>;
  CityConnection?: CityConnectionResolvers<ContextType>;
  CityEdge?: CityEdgeResolvers<ContextType>;
  CityEditMutations?: CityEditMutationsResolvers<ContextType>;
  Cluster?: ClusterResolvers<ContextType>;
  Connector?: ConnectorResolvers<ContextType>;
  ConnectorConfig?: ConnectorConfigResolvers<ContextType>;
  ConstraintNumber?: GraphQLScalarType;
  ConstraintString?: GraphQLScalarType;
  Container?: ContainerResolvers<ContextType>;
  ContainerConnection?: ContainerConnectionResolvers<ContextType>;
  ContainerEdge?: ContainerEdgeResolvers<ContextType>;
  ContainerEditMutations?: ContainerEditMutationsResolvers<ContextType>;
  ContextData?: ContextDataResolvers<ContextType>;
  Country?: CountryResolvers<ContextType>;
  CountryConnection?: CountryConnectionResolvers<ContextType>;
  CountryEdge?: CountryEdgeResolvers<ContextType>;
  CountryEditMutations?: CountryEditMutationsResolvers<ContextType>;
  CourseOfAction?: CourseOfActionResolvers<ContextType>;
  CourseOfActionConnection?: CourseOfActionConnectionResolvers<ContextType>;
  CourseOfActionEdge?: CourseOfActionEdgeResolvers<ContextType>;
  CourseOfActionEditMutations?: CourseOfActionEditMutationsResolvers<ContextType>;
  Creator?: CreatorResolvers<ContextType>;
  CreatorConnection?: CreatorConnectionResolvers<ContextType>;
  CreatorEdge?: CreatorEdgeResolvers<ContextType>;
  CryptocurrencyWallet?: CryptocurrencyWalletResolvers<ContextType>;
  CryptographicKey?: CryptographicKeyResolvers<ContextType>;
  DataComponent?: DataComponentResolvers<ContextType>;
  DataComponentConnection?: DataComponentConnectionResolvers<ContextType>;
  DataComponentEdge?: DataComponentEdgeResolvers<ContextType>;
  DataSource?: DataSourceResolvers<ContextType>;
  DataSourceConnection?: DataSourceConnectionResolvers<ContextType>;
  DataSourceEdge?: DataSourceEdgeResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  DependencyVersion?: DependencyVersionResolvers<ContextType>;
  Dictionary?: DictionaryResolvers<ContextType>;
  Directory?: DirectoryResolvers<ContextType>;
  Display?: DisplayResolvers<ContextType>;
  DisplayStep?: DisplayStepResolvers<ContextType>;
  Distribution?: DistributionResolvers<ContextType>;
  DocsMetrics?: DocsMetricsResolvers<ContextType>;
  DomainName?: DomainNameResolvers<ContextType>;
  EditUserContext?: EditUserContextResolvers<ContextType>;
  ElasticSearchMetrics?: ElasticSearchMetricsResolvers<ContextType>;
  EmailAddr?: EmailAddrResolvers<ContextType>;
  EmailMessage?: EmailMessageResolvers<ContextType>;
  EmailMimePartType?: EmailMimePartTypeResolvers<ContextType>;
  EntitySetting?: EntitySettingResolvers<ContextType>;
  EntitySettingConnection?: EntitySettingConnectionResolvers<ContextType>;
  EntitySettingEdge?: EntitySettingEdgeResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  EventConnection?: EventConnectionResolvers<ContextType>;
  EventEdge?: EventEdgeResolvers<ContextType>;
  ExternalReference?: ExternalReferenceResolvers<ContextType>;
  ExternalReferenceConnection?: ExternalReferenceConnectionResolvers<ContextType>;
  ExternalReferenceEdge?: ExternalReferenceEdgeResolvers<ContextType>;
  ExternalReferenceEditMutations?: ExternalReferenceEditMutationsResolvers<ContextType>;
  Feed?: FeedResolvers<ContextType>;
  FeedAttribute?: FeedAttributeResolvers<ContextType>;
  FeedConnection?: FeedConnectionResolvers<ContextType>;
  FeedEdge?: FeedEdgeResolvers<ContextType>;
  FeedMapping?: FeedMappingResolvers<ContextType>;
  File?: FileResolvers<ContextType>;
  FileConnection?: FileConnectionResolvers<ContextType>;
  FileEdge?: FileEdgeResolvers<ContextType>;
  FileMetadata?: FileMetadataResolvers<ContextType>;
  GetMetrics?: GetMetricsResolvers<ContextType>;
  Group?: GroupResolvers<ContextType>;
  GroupConnection?: GroupConnectionResolvers<ContextType>;
  GroupEdge?: GroupEdgeResolvers<ContextType>;
  GroupEditMutations?: GroupEditMutationsResolvers<ContextType>;
  Grouping?: GroupingResolvers<ContextType>;
  GroupingConnection?: GroupingConnectionResolvers<ContextType>;
  GroupingEdge?: GroupingEdgeResolvers<ContextType>;
  Hash?: HashResolvers<ContextType>;
  HashedObservable?: HashedObservableResolvers<ContextType>;
  Hostname?: HostnameResolvers<ContextType>;
  IPv4Addr?: IPv4AddrResolvers<ContextType>;
  IPv6Addr?: IPv6AddrResolvers<ContextType>;
  Identity?: IdentityResolvers<ContextType>;
  IdentityConnection?: IdentityConnectionResolvers<ContextType>;
  IdentityEdge?: IdentityEdgeResolvers<ContextType>;
  IdentityEditMutations?: IdentityEditMutationsResolvers<ContextType>;
  Incident?: IncidentResolvers<ContextType>;
  IncidentConnection?: IncidentConnectionResolvers<ContextType>;
  IncidentEdge?: IncidentEdgeResolvers<ContextType>;
  IncidentEditMutations?: IncidentEditMutationsResolvers<ContextType>;
  IndexingMetrics?: IndexingMetricsResolvers<ContextType>;
  Indicator?: IndicatorResolvers<ContextType>;
  IndicatorConnection?: IndicatorConnectionResolvers<ContextType>;
  IndicatorEdge?: IndicatorEdgeResolvers<ContextType>;
  IndicatorEditMutations?: IndicatorEditMutationsResolvers<ContextType>;
  Individual?: IndividualResolvers<ContextType>;
  IndividualConnection?: IndividualConnectionResolvers<ContextType>;
  IndividualEdge?: IndividualEdgeResolvers<ContextType>;
  IndividualEditMutations?: IndividualEditMutationsResolvers<ContextType>;
  Inference?: InferenceResolvers<ContextType>;
  InferenceAttribute?: InferenceAttributeResolvers<ContextType>;
  Infrastructure?: InfrastructureResolvers<ContextType>;
  InfrastructureConnection?: InfrastructureConnectionResolvers<ContextType>;
  InfrastructureEdge?: InfrastructureEdgeResolvers<ContextType>;
  InfrastructureEditMutations?: InfrastructureEditMutationsResolvers<ContextType>;
  InternalObject?: InternalObjectResolvers<ContextType>;
  InternalRelationship?: InternalRelationshipResolvers<ContextType>;
  IntrusionSet?: IntrusionSetResolvers<ContextType>;
  IntrusionSetConnection?: IntrusionSetConnectionResolvers<ContextType>;
  IntrusionSetEdge?: IntrusionSetEdgeResolvers<ContextType>;
  IntrusionSetEditMutations?: IntrusionSetEditMutationsResolvers<ContextType>;
  KillChainPhase?: KillChainPhaseResolvers<ContextType>;
  KillChainPhaseConnection?: KillChainPhaseConnectionResolvers<ContextType>;
  KillChainPhaseEdge?: KillChainPhaseEdgeResolvers<ContextType>;
  KillChainPhaseEditMutations?: KillChainPhaseEditMutationsResolvers<ContextType>;
  Label?: LabelResolvers<ContextType>;
  LabelConnection?: LabelConnectionResolvers<ContextType>;
  LabelEdge?: LabelEdgeResolvers<ContextType>;
  LabelEditMutations?: LabelEditMutationsResolvers<ContextType>;
  Language?: LanguageResolvers<ContextType>;
  LanguageConnection?: LanguageConnectionResolvers<ContextType>;
  LanguageEdge?: LanguageEdgeResolvers<ContextType>;
  ListTask?: ListTaskResolvers<ContextType>;
  Location?: LocationResolvers<ContextType>;
  LocationConnection?: LocationConnectionResolvers<ContextType>;
  LocationEdge?: LocationEdgeResolvers<ContextType>;
  LocationEditMutations?: LocationEditMutationsResolvers<ContextType>;
  Log?: LogResolvers<ContextType>;
  LogConnection?: LogConnectionResolvers<ContextType>;
  LogEdge?: LogEdgeResolvers<ContextType>;
  LogsWorkerConfig?: LogsWorkerConfigResolvers<ContextType>;
  MacAddr?: MacAddrResolvers<ContextType>;
  Malware?: MalwareResolvers<ContextType>;
  MalwareConnection?: MalwareConnectionResolvers<ContextType>;
  MalwareEdge?: MalwareEdgeResolvers<ContextType>;
  MalwareEditMutations?: MalwareEditMutationsResolvers<ContextType>;
  MarkingDefinition?: MarkingDefinitionResolvers<ContextType>;
  MarkingDefinitionConnection?: MarkingDefinitionConnectionResolvers<ContextType>;
  MarkingDefinitionEdge?: MarkingDefinitionEdgeResolvers<ContextType>;
  MarkingDefinitionEditMutations?: MarkingDefinitionEditMutationsResolvers<ContextType>;
  MeOrganization?: MeOrganizationResolvers<ContextType>;
  MeOrganizationConnection?: MeOrganizationConnectionResolvers<ContextType>;
  MeOrganizationEdge?: MeOrganizationEdgeResolvers<ContextType>;
  MeUser?: MeUserResolvers<ContextType>;
  MediaContent?: MediaContentResolvers<ContextType>;
  MessagesStats?: MessagesStatsResolvers<ContextType>;
  Module?: ModuleResolvers<ContextType>;
  MultiDistribution?: MultiDistributionResolvers<ContextType>;
  MultiTimeSeries?: MultiTimeSeriesResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Mutex?: MutexResolvers<ContextType>;
  Narrative?: NarrativeResolvers<ContextType>;
  NarrativeConnection?: NarrativeConnectionResolvers<ContextType>;
  NarrativeEdge?: NarrativeEdgeResolvers<ContextType>;
  NetworkTraffic?: NetworkTrafficResolvers<ContextType>;
  Note?: NoteResolvers<ContextType>;
  NoteConnection?: NoteConnectionResolvers<ContextType>;
  NoteEdge?: NoteEdgeResolvers<ContextType>;
  NoteEditMutations?: NoteEditMutationsResolvers<ContextType>;
  Number?: NumberResolvers<ContextType>;
  ObjectTotals?: ObjectTotalsResolvers<ContextType>;
  ObservedData?: ObservedDataResolvers<ContextType>;
  ObservedDataConnection?: ObservedDataConnectionResolvers<ContextType>;
  ObservedDataEdge?: ObservedDataEdgeResolvers<ContextType>;
  ObservedDataEditMutations?: ObservedDataEditMutationsResolvers<ContextType>;
  Opinion?: OpinionResolvers<ContextType>;
  OpinionConnection?: OpinionConnectionResolvers<ContextType>;
  OpinionEdge?: OpinionEdgeResolvers<ContextType>;
  OpinionEditMutations?: OpinionEditMutationsResolvers<ContextType>;
  Organization?: OrganizationResolvers<ContextType>;
  OrganizationConnection?: OrganizationConnectionResolvers<ContextType>;
  OrganizationEdge?: OrganizationEdgeResolvers<ContextType>;
  OrganizationEditMutations?: OrganizationEditMutationsResolvers<ContextType>;
  OrganizationOrIndividual?: OrganizationOrIndividualResolvers<ContextType>;
  OtpElement?: OtpElementResolvers<ContextType>;
  OverviewMetrics?: OverviewMetricsResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PaymentCard?: PaymentCardResolvers<ContextType>;
  PhoneNumber?: PhoneNumberResolvers<ContextType>;
  Position?: PositionResolvers<ContextType>;
  PositionConnection?: PositionConnectionResolvers<ContextType>;
  PositionEdge?: PositionEdgeResolvers<ContextType>;
  PositionEditMutations?: PositionEditMutationsResolvers<ContextType>;
  Process?: ProcessResolvers<ContextType>;
  Provider?: ProviderResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  QueryTask?: QueryTaskResolvers<ContextType>;
  QueueArguments?: QueueArgumentsResolvers<ContextType>;
  QueueMetrics?: QueueMetricsResolvers<ContextType>;
  QueueTotals?: QueueTotalsResolvers<ContextType>;
  RabbitMQConnection?: RabbitMqConnectionResolvers<ContextType>;
  RabbitMQMetrics?: RabbitMqMetricsResolvers<ContextType>;
  Region?: RegionResolvers<ContextType>;
  RegionConnection?: RegionConnectionResolvers<ContextType>;
  RegionEdge?: RegionEdgeResolvers<ContextType>;
  RegionEditMutations?: RegionEditMutationsResolvers<ContextType>;
  Report?: ReportResolvers<ContextType>;
  ReportConnection?: ReportConnectionResolvers<ContextType>;
  ReportEdge?: ReportEdgeResolvers<ContextType>;
  ReportEditMutations?: ReportEditMutationsResolvers<ContextType>;
  RetentionRule?: RetentionRuleResolvers<ContextType>;
  RetentionRuleConnection?: RetentionRuleConnectionResolvers<ContextType>;
  RetentionRuleEdge?: RetentionRuleEdgeResolvers<ContextType>;
  RetentionRuleEditMutations?: RetentionRuleEditMutationsResolvers<ContextType>;
  Role?: RoleResolvers<ContextType>;
  RoleConnection?: RoleConnectionResolvers<ContextType>;
  RoleEdge?: RoleEdgeResolvers<ContextType>;
  RoleEditMutations?: RoleEditMutationsResolvers<ContextType>;
  Rule?: RuleResolvers<ContextType>;
  RuleExecutionError?: RuleExecutionErrorResolvers<ContextType>;
  RuleManager?: RuleManagerResolvers<ContextType>;
  RuleTask?: RuleTaskResolvers<ContextType>;
  SearchMetrics?: SearchMetricsResolvers<ContextType>;
  Sector?: SectorResolvers<ContextType>;
  SectorConnection?: SectorConnectionResolvers<ContextType>;
  SectorEdge?: SectorEdgeResolvers<ContextType>;
  SectorEditMutations?: SectorEditMutationsResolvers<ContextType>;
  SessionDetail?: SessionDetailResolvers<ContextType>;
  Settings?: SettingsResolvers<ContextType>;
  SettingsEditMutations?: SettingsEditMutationsResolvers<ContextType>;
  Software?: SoftwareResolvers<ContextType>;
  Status?: StatusResolvers<ContextType>;
  StatusConnection?: StatusConnectionResolvers<ContextType>;
  StatusEdge?: StatusEdgeResolvers<ContextType>;
  StatusTemplate?: StatusTemplateResolvers<ContextType>;
  StatusTemplateConnection?: StatusTemplateConnectionResolvers<ContextType>;
  StatusTemplateEdge?: StatusTemplateEdgeResolvers<ContextType>;
  StixCoreObject?: StixCoreObjectResolvers<ContextType>;
  StixCoreObjectConnection?: StixCoreObjectConnectionResolvers<ContextType>;
  StixCoreObjectEdge?: StixCoreObjectEdgeResolvers<ContextType>;
  StixCoreObjectEditMutations?: StixCoreObjectEditMutationsResolvers<ContextType>;
  StixCoreObjectOrStixCoreRelationship?: StixCoreObjectOrStixCoreRelationshipResolvers<ContextType>;
  StixCoreRelationship?: StixCoreRelationshipResolvers<ContextType>;
  StixCoreRelationshipConnection?: StixCoreRelationshipConnectionResolvers<ContextType>;
  StixCoreRelationshipEdge?: StixCoreRelationshipEdgeResolvers<ContextType>;
  StixCoreRelationshipEditMutations?: StixCoreRelationshipEditMutationsResolvers<ContextType>;
  StixCyberObservable?: StixCyberObservableResolvers<ContextType>;
  StixCyberObservableConnection?: StixCyberObservableConnectionResolvers<ContextType>;
  StixCyberObservableEdge?: StixCyberObservableEdgeResolvers<ContextType>;
  StixCyberObservableEditMutations?: StixCyberObservableEditMutationsResolvers<ContextType>;
  StixCyberObservableRelationship?: StixCyberObservableRelationshipResolvers<ContextType>;
  StixCyberObservableRelationshipConnection?: StixCyberObservableRelationshipConnectionResolvers<ContextType>;
  StixCyberObservableRelationshipEdge?: StixCyberObservableRelationshipEdgeResolvers<ContextType>;
  StixCyberObservableRelationshipEditMutations?: StixCyberObservableRelationshipEditMutationsResolvers<ContextType>;
  StixDomainObject?: StixDomainObjectResolvers<ContextType>;
  StixDomainObjectConnection?: StixDomainObjectConnectionResolvers<ContextType>;
  StixDomainObjectEdge?: StixDomainObjectEdgeResolvers<ContextType>;
  StixDomainObjectEditMutations?: StixDomainObjectEditMutationsResolvers<ContextType>;
  StixEditMutations?: StixEditMutationsResolvers<ContextType>;
  StixFile?: StixFileResolvers<ContextType>;
  StixFileConnection?: StixFileConnectionResolvers<ContextType>;
  StixFileEdge?: StixFileEdgeResolvers<ContextType>;
  StixId?: GraphQLScalarType;
  StixMetaObject?: StixMetaObjectResolvers<ContextType>;
  StixMetaRelationship?: StixMetaRelationshipResolvers<ContextType>;
  StixMetaRelationshipConnection?: StixMetaRelationshipConnectionResolvers<ContextType>;
  StixMetaRelationshipEdge?: StixMetaRelationshipEdgeResolvers<ContextType>;
  StixObject?: StixObjectResolvers<ContextType>;
  StixObjectOrStixRelationship?: StixObjectOrStixRelationshipResolvers<ContextType>;
  StixObjectOrStixRelationshipConnection?: StixObjectOrStixRelationshipConnectionResolvers<ContextType>;
  StixObjectOrStixRelationshipEdge?: StixObjectOrStixRelationshipEdgeResolvers<ContextType>;
  StixObjectOrStixRelationshipRefConnection?: StixObjectOrStixRelationshipRefConnectionResolvers<ContextType>;
  StixObjectOrStixRelationshipRefEdge?: StixObjectOrStixRelationshipRefEdgeResolvers<ContextType>;
  StixRef?: GraphQLScalarType;
  StixRelationship?: StixRelationshipResolvers<ContextType>;
  StixRelationshipConnection?: StixRelationshipConnectionResolvers<ContextType>;
  StixRelationshipEdge?: StixRelationshipEdgeResolvers<ContextType>;
  StixRelationshipEditMutations?: StixRelationshipEditMutationsResolvers<ContextType>;
  StixSightingRelationship?: StixSightingRelationshipResolvers<ContextType>;
  StixSightingRelationshipConnection?: StixSightingRelationshipConnectionResolvers<ContextType>;
  StixSightingRelationshipEditMutations?: StixSightingRelationshipEditMutationsResolvers<ContextType>;
  StixSightingRelationshipsEdge?: StixSightingRelationshipsEdgeResolvers<ContextType>;
  StreamCollection?: StreamCollectionResolvers<ContextType>;
  StreamCollectionConnection?: StreamCollectionConnectionResolvers<ContextType>;
  StreamCollectionEdge?: StreamCollectionEdgeResolvers<ContextType>;
  StreamCollectionEditMutations?: StreamCollectionEditMutationsResolvers<ContextType>;
  SubType?: SubTypeResolvers<ContextType>;
  SubTypeConnection?: SubTypeConnectionResolvers<ContextType>;
  SubTypeEdge?: SubTypeEdgeResolvers<ContextType>;
  SubTypeEditMutations?: SubTypeEditMutationsResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  Synchronizer?: SynchronizerResolvers<ContextType>;
  SynchronizerConnection?: SynchronizerConnectionResolvers<ContextType>;
  SynchronizerEdge?: SynchronizerEdgeResolvers<ContextType>;
  SynchronizerEditMutations?: SynchronizerEditMutationsResolvers<ContextType>;
  System?: SystemResolvers<ContextType>;
  SystemConnection?: SystemConnectionResolvers<ContextType>;
  SystemEdge?: SystemEdgeResolvers<ContextType>;
  SystemEditMutations?: SystemEditMutationsResolvers<ContextType>;
  Task?: TaskResolvers<ContextType>;
  TaskAction?: TaskActionResolvers<ContextType>;
  TaskConnection?: TaskConnectionResolvers<ContextType>;
  TaskConnectionEdge?: TaskConnectionEdgeResolvers<ContextType>;
  TaskContext?: TaskContextResolvers<ContextType>;
  TaskError?: TaskErrorResolvers<ContextType>;
  TaxiiCollection?: TaxiiCollectionResolvers<ContextType>;
  TaxiiCollectionConnection?: TaxiiCollectionConnectionResolvers<ContextType>;
  TaxiiCollectionEdge?: TaxiiCollectionEdgeResolvers<ContextType>;
  TaxiiCollectionEditMutations?: TaxiiCollectionEditMutationsResolvers<ContextType>;
  Text?: TextResolvers<ContextType>;
  ThreatActor?: ThreatActorResolvers<ContextType>;
  ThreatActorConnection?: ThreatActorConnectionResolvers<ContextType>;
  ThreatActorEdge?: ThreatActorEdgeResolvers<ContextType>;
  ThreatActorEditMutations?: ThreatActorEditMutationsResolvers<ContextType>;
  TimeSeries?: TimeSeriesResolvers<ContextType>;
  Tool?: ToolResolvers<ContextType>;
  ToolConnection?: ToolConnectionResolvers<ContextType>;
  ToolEdge?: ToolEdgeResolvers<ContextType>;
  ToolEditMutations?: ToolEditMutationsResolvers<ContextType>;
  Upload?: GraphQLScalarType;
  Url?: UrlResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserAccount?: UserAccountResolvers<ContextType>;
  UserAgent?: UserAgentResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserEditMutations?: UserEditMutationsResolvers<ContextType>;
  UserSession?: UserSessionResolvers<ContextType>;
  UserSubscription?: UserSubscriptionResolvers<ContextType>;
  UserSubscriptionConnection?: UserSubscriptionConnectionResolvers<ContextType>;
  UserSubscriptionEdge?: UserSubscriptionEdgeResolvers<ContextType>;
  UserSubscriptionEditMutations?: UserSubscriptionEditMutationsResolvers<ContextType>;
  Vocabulary?: VocabularyResolvers<ContextType>;
  VocabularyConnection?: VocabularyConnectionResolvers<ContextType>;
  VocabularyDefinition?: VocabularyDefinitionResolvers<ContextType>;
  VocabularyEdge?: VocabularyEdgeResolvers<ContextType>;
  VocabularyFieldDefinition?: VocabularyFieldDefinitionResolvers<ContextType>;
  Vulnerability?: VulnerabilityResolvers<ContextType>;
  VulnerabilityConnection?: VulnerabilityConnectionResolvers<ContextType>;
  VulnerabilityEdge?: VulnerabilityEdgeResolvers<ContextType>;
  VulnerabilityEditMutations?: VulnerabilityEditMutationsResolvers<ContextType>;
  WindowsRegistryKey?: WindowsRegistryKeyResolvers<ContextType>;
  WindowsRegistryValueType?: WindowsRegistryValueTypeResolvers<ContextType>;
  Work?: WorkResolvers<ContextType>;
  WorkConnection?: WorkConnectionResolvers<ContextType>;
  WorkEdge?: WorkEdgeResolvers<ContextType>;
  WorkEditMutations?: WorkEditMutationsResolvers<ContextType>;
  WorkMessage?: WorkMessageResolvers<ContextType>;
  WorkTracking?: WorkTrackingResolvers<ContextType>;
  Workspace?: WorkspaceResolvers<ContextType>;
  WorkspaceConnection?: WorkspaceConnectionResolvers<ContextType>;
  WorkspaceEdge?: WorkspaceEdgeResolvers<ContextType>;
  WorkspaceEditMutations?: WorkspaceEditMutationsResolvers<ContextType>;
  X509Certificate?: X509CertificateResolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = any> = ResolversObject<{
  auth?: AuthDirectiveResolver<any, any, ContextType>;
  constraint?: ConstraintDirectiveResolver<any, any, ContextType>;
}>;
