import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  ConstraintNumber: any;
  ConstraintString: any;
  DateTime: any;
  Upload: any;
};

export type AckDetails = {
  __typename?: 'AckDetails';
  rate?: Maybe<Scalars['Float']>;
};

export type AppDebugDistribution = {
  __typename?: 'AppDebugDistribution';
  label: Scalars['String'];
  value?: Maybe<Scalars['Int']>;
};

export type AppDebugStatistics = {
  __typename?: 'AppDebugStatistics';
  objects?: Maybe<Array<Maybe<AppDebugDistribution>>>;
  relationships?: Maybe<Array<Maybe<AppDebugDistribution>>>;
};

/** Retrieve the application information version add dependencies */
export type AppInfo = {
  __typename?: 'AppInfo';
  /** The objects statistics */
  debugStats?: Maybe<AppDebugStatistics>;
  /** The list of OpenCTI software dependencies */
  dependencies: Array<DependencyVersion>;
  /** The OpenCTI api current memory usage */
  memory?: Maybe<AppMemory>;
  /** The OpenCTI application version */
  version: Scalars['String'];
};

/**
 * NodeJs memory.
 * https://nodejs.org/api/process.html#process_process_memoryusage
 * https://nodejs.org/docs/latest-v11.x/api/v8.html#v8_v8_getheapstatistics
 */
export type AppMemory = {
  __typename?: 'AppMemory';
  arrayBuffers?: Maybe<Scalars['Float']>;
  does_zap_garbage?: Maybe<Scalars['Float']>;
  external?: Maybe<Scalars['Float']>;
  heapTotal?: Maybe<Scalars['Float']>;
  heapUsed?: Maybe<Scalars['Float']>;
  heap_size_limit?: Maybe<Scalars['Float']>;
  malloced_memory?: Maybe<Scalars['Float']>;
  peak_malloced_memory?: Maybe<Scalars['Float']>;
  rss?: Maybe<Scalars['Float']>;
  total_available_size?: Maybe<Scalars['Float']>;
  total_heap_size?: Maybe<Scalars['Float']>;
  total_heap_size_executable?: Maybe<Scalars['Float']>;
  total_physical_size?: Maybe<Scalars['Float']>;
  used_heap_size?: Maybe<Scalars['Float']>;
};

export type Artifact = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Artifact';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  decryption_key?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  encryption_algorithm?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  mime_type?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  payload_bin?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  url?: Maybe<Scalars['String']>;
  x_opencti_additional_names?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ArtifactConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ArtifactExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ArtifactStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ArtifactStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ArtifactAddInput = {
  decryption_key?: InputMaybe<Scalars['String']>;
  encryption_algorithm?: InputMaybe<Scalars['String']>;
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  mime_type?: InputMaybe<Scalars['String']>;
  payload_bin?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  x_opencti_additional_names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AttackPattern = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'AttackPattern';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  coursesOfAction?: Maybe<CourseOfActionConnection>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  isSubAttackPattern?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentAttackPatterns?: Maybe<AttackPatternConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  subAttackPatterns?: Maybe<AttackPatternConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_detection?: Maybe<Scalars['String']>;
  x_mitre_id?: Maybe<Scalars['String']>;
  x_mitre_permissions_required?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_mitre_platforms?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type AttackPatternConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type AttackPatternExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AttackPatternStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AttackPatternAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_mitre_detection?: InputMaybe<Scalars['String']>;
  x_mitre_id?: InputMaybe<Scalars['String']>;
  x_mitre_permissions_required?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_mitre_platforms?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AttackPatternConnection = {
  __typename?: 'AttackPatternConnection';
  edges?: Maybe<Array<Maybe<AttackPatternEdge>>>;
  pageInfo: PageInfo;
};

export type AttackPatternEdge = {
  __typename?: 'AttackPatternEdge';
  cursor: Scalars['String'];
  node: AttackPattern;
};

export type AttackPatternEditMutations = {
  __typename?: 'AttackPatternEditMutations';
  contextClean?: Maybe<AttackPattern>;
  contextPatch?: Maybe<AttackPattern>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<AttackPattern>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<AttackPattern>;
};


export type AttackPatternEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type AttackPatternEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AttackPatternEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type AttackPatternEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum AttackPatternsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  MitigatedBy = 'mitigatedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id'
}

export type AttackPatternsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: AttackPatternsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum AttackPatternsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id'
}

export type Attribute = {
  __typename?: 'Attribute';
  id: Scalars['ID'];
  key: Scalars['String'];
  value: Scalars['String'];
};

export type AttributeConnection = {
  __typename?: 'AttributeConnection';
  edges?: Maybe<Array<Maybe<AttributeEdge>>>;
  pageInfo: PageInfo;
};

export type AttributeEdge = {
  __typename?: 'AttributeEdge';
  cursor: Scalars['String'];
  node: Attribute;
};

export type AttributeEditMutations = {
  __typename?: 'AttributeEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Attribute>;
};


export type AttributeEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum AttributesOrdering {
  Value = 'value'
}

export type AutonomousSystem = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'AutonomousSystem';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  number: Scalars['Int'];
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  rir?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type AutonomousSystemConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type AutonomousSystemExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type AutonomousSystemStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type AutonomousSystemStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AutonomousSystemAddInput = {
  name?: InputMaybe<Scalars['String']>;
  number: Scalars['Int'];
  rir?: InputMaybe<Scalars['String']>;
};

export type BasicObject = {
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
};

export type BasicRelationship = {
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
};

export type Campaign = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Campaign';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objective?: Maybe<Scalars['String']>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type CampaignConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CampaignExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CampaignStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CampaignAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objective?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CampaignConnection = {
  __typename?: 'CampaignConnection';
  edges?: Maybe<Array<Maybe<CampaignEdge>>>;
  pageInfo: PageInfo;
};

export type CampaignEdge = {
  __typename?: 'CampaignEdge';
  cursor: Scalars['String'];
  node: Campaign;
};

export type CampaignEditMutations = {
  __typename?: 'CampaignEditMutations';
  contextClean?: Maybe<Campaign>;
  contextPatch?: Maybe<Campaign>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Campaign>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Campaign>;
};


export type CampaignEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CampaignEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CampaignEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CampaignEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum CampaignsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type CampaignsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: CampaignsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CampaignsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  RolePlayed = 'role_played',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export enum Capabilities {
  Connectorapi = 'CONNECTORAPI',
  Explore = 'EXPLORE',
  ExploreExupdate = 'EXPLORE_EXUPDATE',
  ExploreExupdateExdelete = 'EXPLORE_EXUPDATE_EXDELETE',
  Knowledge = 'KNOWLEDGE',
  KnowledgeKnaskimport = 'KNOWLEDGE_KNASKIMPORT',
  KnowledgeKnenrichment = 'KNOWLEDGE_KNENRICHMENT',
  KnowledgeKngetexport = 'KNOWLEDGE_KNGETEXPORT',
  KnowledgeKngetexportKnaskexport = 'KNOWLEDGE_KNGETEXPORT_KNASKEXPORT',
  KnowledgeKnupdate = 'KNOWLEDGE_KNUPDATE',
  KnowledgeKnupdateKndelete = 'KNOWLEDGE_KNUPDATE_KNDELETE',
  KnowledgeKnupload = 'KNOWLEDGE_KNUPLOAD',
  Modules = 'MODULES',
  ModulesModmanage = 'MODULES_MODMANAGE',
  Settings = 'SETTINGS',
  SettingsSetaccesses = 'SETTINGS_SETACCESSES',
  SettingsSetlabels = 'SETTINGS_SETLABELS',
  SettingsSetmarkings = 'SETTINGS_SETMARKINGS',
  TaxiiapiSetcollections = 'TAXIIAPI_SETCOLLECTIONS'
}

export type Capability = BasicObject & InternalObject & {
  __typename?: 'Capability';
  attribute_order?: Maybe<Scalars['Int']>;
  created_at: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type CapabilityConnection = {
  __typename?: 'CapabilityConnection';
  edges?: Maybe<Array<Maybe<CapabilityEdge>>>;
  pageInfo: PageInfo;
};

export type CapabilityEdge = {
  __typename?: 'CapabilityEdge';
  cursor: Scalars['String'];
  node: Capability;
};

export enum CitiesFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type CitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: CitiesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CitiesOrdering {
  Aliases = 'aliases',
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type City = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'City';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  country?: Maybe<Country>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type CityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CityConnection = {
  __typename?: 'CityConnection';
  edges?: Maybe<Array<Maybe<CityEdge>>>;
  pageInfo: PageInfo;
};

export type CityEdge = {
  __typename?: 'CityEdge';
  cursor: Scalars['String'];
  node: City;
};

export type CityEditMutations = {
  __typename?: 'CityEditMutations';
  contextClean?: Maybe<City>;
  contextPatch?: Maybe<City>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<City>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<City>;
};


export type CityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type Connector = BasicObject & InternalObject & {
  __typename?: 'Connector';
  active?: Maybe<Scalars['Boolean']>;
  auto?: Maybe<Scalars['Boolean']>;
  config?: Maybe<ConnectorConfig>;
  connector_scope?: Maybe<Array<Scalars['String']>>;
  connector_state?: Maybe<Scalars['String']>;
  connector_state_reset?: Maybe<Scalars['Boolean']>;
  connector_type?: Maybe<Scalars['String']>;
  connector_user?: Maybe<User>;
  created_at?: Maybe<Scalars['DateTime']>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  only_contextual?: Maybe<Scalars['Boolean']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at?: Maybe<Scalars['DateTime']>;
  works?: Maybe<Array<Maybe<Work>>>;
};


export type ConnectorWorksArgs = {
  status?: InputMaybe<Scalars['String']>;
};

export type ConnectorConfig = {
  __typename?: 'ConnectorConfig';
  connection: RabbitMqConnection;
  listen: Scalars['String'];
  listen_exchange: Scalars['String'];
  push: Scalars['String'];
  push_exchange: Scalars['String'];
};

export enum ConnectorType {
  ExternalImport = 'EXTERNAL_IMPORT',
  InternalEnrichment = 'INTERNAL_ENRICHMENT',
  InternalExportFile = 'INTERNAL_EXPORT_FILE',
  InternalImportFile = 'INTERNAL_IMPORT_FILE',
  Stream = 'STREAM'
}

export type Container = {
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ContainerExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ContainerStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ContainerConnection = {
  __typename?: 'ContainerConnection';
  edges?: Maybe<Array<Maybe<ContainerEdge>>>;
  pageInfo: PageInfo;
};

export type ContainerEdge = {
  __typename?: 'ContainerEdge';
  cursor: Scalars['String'];
  node: Container;
};

export type ContainerEditMutations = {
  __typename?: 'ContainerEditMutations';
  contextClean?: Maybe<Container>;
  contextPatch?: Maybe<Container>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Container>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Container>;
};


export type ContainerEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ContainerEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ContainerEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ContainerEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum ContainersFilter {
  AttributeAbstract = 'attribute_abstract',
  Authors = 'authors',
  Content = 'content',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ObjectContains = 'objectContains',
  ReportTypes = 'report_types',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type ContainersFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ContainersFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ContainersOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type ContextData = {
  __typename?: 'ContextData';
  commit?: Maybe<Scalars['String']>;
  entity_type: Scalars['String'];
  from_id?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  message: Scalars['String'];
  references?: Maybe<Array<Maybe<ExternalReference>>>;
  to_id?: Maybe<Scalars['String']>;
};

export enum CountriesFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  StatusId = 'status_id'
}

export type CountriesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: CountriesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CountriesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Country = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Country';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  region?: Maybe<Region>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type CountryConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CountryExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CountryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CountryAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CountryConnection = {
  __typename?: 'CountryConnection';
  edges?: Maybe<Array<Maybe<CountryEdge>>>;
  pageInfo: PageInfo;
};

export type CountryEdge = {
  __typename?: 'CountryEdge';
  cursor: Scalars['String'];
  node: Country;
};

export type CountryEditMutations = {
  __typename?: 'CountryEditMutations';
  contextClean?: Maybe<Country>;
  contextPatch?: Maybe<Country>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Country>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Country>;
};


export type CountryEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CountryEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CountryEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CountryEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type CourseOfAction = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'CourseOfAction';
  attackPatterns?: Maybe<AttackPatternConnection>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_id?: Maybe<Scalars['String']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_log_sources?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_threat_hunting?: Maybe<Scalars['String']>;
};


export type CourseOfActionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CourseOfActionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CourseOfActionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CourseOfActionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_mitre_id?: InputMaybe<Scalars['String']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CourseOfActionConnection = {
  __typename?: 'CourseOfActionConnection';
  edges?: Maybe<Array<Maybe<CourseOfActionEdge>>>;
  pageInfo: PageInfo;
};

export type CourseOfActionEdge = {
  __typename?: 'CourseOfActionEdge';
  cursor: Scalars['String'];
  node: CourseOfAction;
};

export type CourseOfActionEditMutations = {
  __typename?: 'CourseOfActionEditMutations';
  contextClean?: Maybe<CourseOfAction>;
  contextPatch?: Maybe<CourseOfAction>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<CourseOfAction>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<CourseOfAction>;
};


export type CourseOfActionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type CourseOfActionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CourseOfActionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type CourseOfActionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum CoursesOfActionFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  MitigatedBy = 'mitigatedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  XMitreId = 'x_mitre_id'
}

export type CoursesOfActionFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: CoursesOfActionFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum CoursesOfActionOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XMitreId = 'x_mitre_id'
}

export type CryptocurrencyWallet = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'CryptocurrencyWallet';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type CryptocurrencyWalletConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CryptocurrencyWalletExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptocurrencyWalletStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptocurrencyWalletStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CryptocurrencyWalletAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type CryptographicKey = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'CryptographicKey';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type CryptographicKeyConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type CryptographicKeyExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type CryptographicKeyStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type CryptographicKeyStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type CryptographicKeyAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

/** Dependency information containing the name and the deployed version. */
export type DependencyVersion = {
  __typename?: 'DependencyVersion';
  name: Scalars['String'];
  version: Scalars['String'];
};

export type Directory = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Directory';
  atime?: Maybe<Scalars['DateTime']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  ctime?: Maybe<Scalars['DateTime']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  mtime?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  path: Scalars['String'];
  path_enc?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type DirectoryConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DirectoryExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DirectoryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DirectoryStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DirectoryAddInput = {
  atime?: InputMaybe<Scalars['DateTime']>;
  ctime?: InputMaybe<Scalars['DateTime']>;
  mtime?: InputMaybe<Scalars['DateTime']>;
  path: Scalars['String'];
  path_enc?: InputMaybe<Scalars['String']>;
};

export type Distribution = {
  __typename?: 'Distribution';
  entity?: Maybe<StixObjectOrStixRelationship>;
  label: Scalars['String'];
  value?: Maybe<Scalars['Int']>;
};

export type DocsMetrics = {
  __typename?: 'DocsMetrics';
  count?: Maybe<Scalars['String']>;
};

export type DomainName = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'DomainName';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type DomainNameConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type DomainNameExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNamePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type DomainNameStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type DomainNameStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type DomainNameAddInput = {
  value: Scalars['String'];
};

export type EditContext = {
  focusOn?: InputMaybe<Scalars['String']>;
};

export type EditInput = {
  key: Scalars['String'];
  operation?: InputMaybe<EditOperation>;
  value: Array<InputMaybe<Scalars['String']>>;
};

export enum EditOperation {
  Add = 'add',
  Remove = 'remove',
  Replace = 'replace'
}

export type EditUserContext = {
  __typename?: 'EditUserContext';
  focusOn?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

export type ElasticSearchMetrics = {
  __typename?: 'ElasticSearchMetrics';
  docs?: Maybe<DocsMetrics>;
  get?: Maybe<GetMetrics>;
  indexing?: Maybe<IndexingMetrics>;
  search?: Maybe<SearchMetrics>;
};

export type EmailAddr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailAddr';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  display_name?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type EmailAddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailAddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailAddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailAddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailAddrAddInput = {
  display_name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type EmailMessage = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailMessage';
  attribute_date?: Maybe<Scalars['DateTime']>;
  body?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content_type?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  is_multipart?: Maybe<Scalars['Boolean']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  message_id?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  received_lines?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  subject?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type EmailMessageConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailMessageExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessagePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMessageStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMessageStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailMessageAddInput = {
  attribute_date?: InputMaybe<Scalars['DateTime']>;
  body?: InputMaybe<Scalars['String']>;
  content_type?: InputMaybe<Scalars['String']>;
  is_multipart?: InputMaybe<Scalars['Boolean']>;
  message_id?: InputMaybe<Scalars['String']>;
  received_lines?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  subject?: InputMaybe<Scalars['String']>;
};

export type EmailMimePartType = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'EmailMimePartType';
  body?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content_disposition?: Maybe<Scalars['String']>;
  content_type?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type EmailMimePartTypeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type EmailMimePartTypeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type EmailMimePartTypeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type EmailMimePartTypeStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EmailMimePartTypeAddInput = {
  body?: InputMaybe<Scalars['String']>;
  content_disposition?: InputMaybe<Scalars['String']>;
  content_type?: InputMaybe<Scalars['String']>;
};

export type ExternalReference = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'ExternalReference';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  external_id?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  references?: Maybe<StixObjectOrStixRelationshipConnection>;
  source_name: Scalars['String'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  url?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ExternalReferenceConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ExternalReferenceExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferencePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ExternalReferenceReferencesArgs = {
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ExternalReferenceAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  description?: InputMaybe<Scalars['String']>;
  external_id?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['Upload']>;
  hash?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  source_name: Scalars['String'];
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  url?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ExternalReferenceConnection = {
  __typename?: 'ExternalReferenceConnection';
  edges?: Maybe<Array<Maybe<ExternalReferenceEdge>>>;
  pageInfo: PageInfo;
};

export type ExternalReferenceEdge = {
  __typename?: 'ExternalReferenceEdge';
  cursor: Scalars['String'];
  node: ExternalReference;
};

export type ExternalReferenceEditMutations = {
  __typename?: 'ExternalReferenceEditMutations';
  askEnrichment?: Maybe<Work>;
  contextClean?: Maybe<ExternalReference>;
  contextPatch?: Maybe<ExternalReference>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ExternalReference>;
  importPush?: Maybe<File>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ExternalReference>;
};


export type ExternalReferenceEditMutationsAskEnrichmentArgs = {
  connectorId: Scalars['ID'];
};


export type ExternalReferenceEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ExternalReferenceEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type ExternalReferenceEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
};


export type ExternalReferenceEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ExternalReferenceEditMutationsRelationDeleteArgs = {
  fromId: Scalars['String'];
  relationship_type: Scalars['String'];
};

export enum ExternalReferencesFilter {
  ExternalId = 'external_id',
  SourceName = 'source_name',
  Url = 'url',
  UsedBy = 'usedBy'
}

export type ExternalReferencesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ExternalReferencesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ExternalReferencesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  ExternalId = 'external_id',
  Hash = 'hash',
  Modified = 'modified',
  SourceName = 'source_name',
  UpdatedAt = 'updated_at',
  Url = 'url'
}

export type File = {
  __typename?: 'File';
  id: Scalars['ID'];
  lastModified?: Maybe<Scalars['DateTime']>;
  lastModifiedSinceMin?: Maybe<Scalars['Int']>;
  metaData?: Maybe<FileMetadata>;
  name: Scalars['String'];
  size?: Maybe<Scalars['Int']>;
  uploadStatus: State;
  works?: Maybe<Array<Maybe<Work>>>;
};

export type FileConnection = {
  __typename?: 'FileConnection';
  edges?: Maybe<Array<Maybe<FileEdge>>>;
  pageInfo: PageInfo;
};

export type FileEdge = {
  __typename?: 'FileEdge';
  cursor: Scalars['String'];
  node: File;
};

export type FileMetadata = {
  __typename?: 'FileMetadata';
  encoding?: Maybe<Scalars['String']>;
  entity?: Maybe<StixCoreObject>;
  entity_id?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<WorkMessage>>>;
  list_filters?: Maybe<Scalars['String']>;
  messages?: Maybe<Array<Maybe<WorkMessage>>>;
  mimetype?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

export enum FilterMode {
  And = 'and',
  Or = 'or'
}

export type GetMetrics = {
  __typename?: 'GetMetrics';
  total?: Maybe<Scalars['String']>;
};

export type Group = BasicObject & InternalObject & {
  __typename?: 'Group';
  allowed_marking?: Maybe<Array<Maybe<MarkingDefinition>>>;
  auto_new_marking?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  default_assignation?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  members?: Maybe<UserConnection>;
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at?: Maybe<Scalars['DateTime']>;
};

export type GroupAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type GroupConnection = {
  __typename?: 'GroupConnection';
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  pageInfo: PageInfo;
};

export type GroupEdge = {
  __typename?: 'GroupEdge';
  cursor: Scalars['String'];
  node: Group;
};

export type GroupEditMutations = {
  __typename?: 'GroupEditMutations';
  contextClean?: Maybe<Group>;
  contextPatch?: Maybe<Group>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Group>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<Group>;
};


export type GroupEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type GroupEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type GroupEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type GroupEditMutationsRelationDeleteArgs = {
  fromId?: InputMaybe<Scalars['String']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['String']>;
};

export enum GroupsOrdering {
  AutoNewMarking = 'auto_new_marking',
  CreatedAt = 'created_at',
  DefaultAssignation = 'default_assignation',
  Name = 'name',
  UpdatedAt = 'updated_at'
}

export type Hash = {
  __typename?: 'Hash';
  algorithm: Scalars['String'];
  hash?: Maybe<Scalars['String']>;
};

export type HashInput = {
  algorithm: Scalars['String'];
  hash: Scalars['String'];
};

export type HashedObservable = {
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type HashedObservableConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type HashedObservableExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservablePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HashedObservableStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HashedObservableStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type Hostname = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Hostname';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type HostnameConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type HostnameExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnamePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type HostnameStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type HostnameStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type HostnameAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type IPv4Addr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'IPv4Addr';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IPv4AddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IPv4AddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv4AddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv4AddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IPv4AddrAddInput = {
  belongsTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  resolvesTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  value?: InputMaybe<Scalars['String']>;
};

export type IPv6Addr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'IPv6Addr';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IPv6AddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IPv6AddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IPv6AddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IPv6AddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IPv6AddrAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export enum IdentitiesFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  IdentityClass = 'identity_class',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XOpenctiAliases = 'x_opencti_aliases'
}

export type IdentitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: IdentitiesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IdentitiesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Identity = {
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IdentityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IdentityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IdentityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IdentityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  type: IdentityType;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IdentityConnection = {
  __typename?: 'IdentityConnection';
  edges?: Maybe<Array<Maybe<IdentityEdge>>>;
  pageInfo: PageInfo;
};

export type IdentityEdge = {
  __typename?: 'IdentityEdge';
  cursor: Scalars['String'];
  node: Identity;
};

export type IdentityEditMutations = {
  __typename?: 'IdentityEditMutations';
  contextClean?: Maybe<Identity>;
  contextPatch?: Maybe<Identity>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Identity>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Identity>;
};


export type IdentityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IdentityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IdentityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IdentityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum IdentityType {
  Individual = 'Individual',
  Organization = 'Organization',
  Sector = 'Sector',
  System = 'System'
}

export type Incident = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Incident';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objective?: Maybe<Scalars['String']>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IncidentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IncidentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IncidentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IncidentAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objective?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IncidentConnection = {
  __typename?: 'IncidentConnection';
  edges?: Maybe<Array<Maybe<IncidentEdge>>>;
  pageInfo: PageInfo;
};

export type IncidentEdge = {
  __typename?: 'IncidentEdge';
  cursor: Scalars['String'];
  node: Incident;
};

export type IncidentEditMutations = {
  __typename?: 'IncidentEditMutations';
  contextClean?: Maybe<Incident>;
  contextPatch?: Maybe<Incident>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Incident>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Incident>;
};


export type IncidentEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IncidentEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IncidentEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IncidentEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum IncidentsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id'
}

export type IncidentsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: IncidentsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IncidentsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type IndexingMetrics = {
  __typename?: 'IndexingMetrics';
  delete_total?: Maybe<Scalars['String']>;
  index_total?: Maybe<Scalars['String']>;
};

export type Indicator = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Indicator';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicator_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observables?: Maybe<StixCyberObservableConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pattern?: Maybe<Scalars['String']>;
  pattern_type?: Maybe<Scalars['String']>;
  pattern_version?: Maybe<Scalars['String']>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  valid_from?: Maybe<Scalars['DateTime']>;
  valid_until?: Maybe<Scalars['DateTime']>;
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_mitre_platforms?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_detection?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_main_observable_type?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IndicatorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IndicatorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorObservablesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndicatorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndicatorAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  createObservables?: InputMaybe<Scalars['Boolean']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  indicator_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  pattern: Scalars['String'];
  pattern_type: Scalars['String'];
  pattern_version?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  valid_from?: InputMaybe<Scalars['DateTime']>;
  valid_until?: InputMaybe<Scalars['DateTime']>;
  x_mitre_platforms?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_detection?: InputMaybe<Scalars['Boolean']>;
  x_opencti_main_observable_type?: InputMaybe<Scalars['String']>;
  x_opencti_score?: InputMaybe<Scalars['Int']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndicatorConnection = {
  __typename?: 'IndicatorConnection';
  edges?: Maybe<Array<Maybe<IndicatorEdge>>>;
  pageInfo: PageInfo;
};

export type IndicatorEdge = {
  __typename?: 'IndicatorEdge';
  cursor: Scalars['String'];
  node: Indicator;
};

export type IndicatorEditMutations = {
  __typename?: 'IndicatorEditMutations';
  contextClean?: Maybe<Indicator>;
  contextPatch?: Maybe<Indicator>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Indicator>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Indicator>;
};


export type IndicatorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IndicatorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndicatorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IndicatorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum IndicatorsFilter {
  BasedOn = 'basedOn',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Indicates = 'indicates',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Pattern = 'pattern',
  PatternType = 'pattern_type',
  PatternVersion = 'pattern_version',
  Revoked = 'revoked',
  SightedBy = 'sightedBy',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiDetection = 'x_opencti_detection',
  XOpenctiMainObservableType = 'x_opencti_main_observable_type',
  XOpenctiScore = 'x_opencti_score'
}

export type IndicatorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: IndicatorsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IndicatorsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  IndicatorTypes = 'indicator_types',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Pattern = 'pattern',
  PatternType = 'pattern_type',
  PatternVersion = 'pattern_version',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiDetection = 'x_opencti_detection',
  XOpenctiScore = 'x_opencti_score'
}

export type Individual = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Individual';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  organizations?: Maybe<OrganizationConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_firstname?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_lastname?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IndividualConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IndividualExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IndividualStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndividualAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_firstname?: InputMaybe<Scalars['String']>;
  x_opencti_lastname?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IndividualConnection = {
  __typename?: 'IndividualConnection';
  edges?: Maybe<Array<Maybe<IndividualEdge>>>;
  pageInfo: PageInfo;
};

export type IndividualEdge = {
  __typename?: 'IndividualEdge';
  cursor: Scalars['String'];
  node: Individual;
};

export type IndividualEditMutations = {
  __typename?: 'IndividualEditMutations';
  contextClean?: Maybe<Individual>;
  contextPatch?: Maybe<Individual>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Individual>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Individual>;
};


export type IndividualEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IndividualEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IndividualEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IndividualEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum IndividualsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type IndividualsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: IndividualsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IndividualsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Firstname = 'firstname',
  Lastname = 'lastname',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id'
}

export type Inference = {
  __typename?: 'Inference';
  attributes?: Maybe<Array<Maybe<InferenceAttribute>>>;
  explanation: Array<Maybe<StixObjectOrStixRelationship>>;
  rule: Rule;
};

export type InferenceAttribute = {
  __typename?: 'InferenceAttribute';
  field: Scalars['String'];
  value: Scalars['String'];
};

export type Infrastructure = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Infrastructure';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  infrastructure_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type InfrastructureConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type InfrastructureExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructurePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type InfrastructureStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type InfrastructureAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  infrastructure_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type InfrastructureConnection = {
  __typename?: 'InfrastructureConnection';
  edges?: Maybe<Array<Maybe<InfrastructureEdge>>>;
  pageInfo: PageInfo;
};

export type InfrastructureEdge = {
  __typename?: 'InfrastructureEdge';
  cursor: Scalars['String'];
  node: Infrastructure;
};

export type InfrastructureEditMutations = {
  __typename?: 'InfrastructureEditMutations';
  contextClean?: Maybe<Infrastructure>;
  contextPatch?: Maybe<Infrastructure>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Infrastructure>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Infrastructure>;
};


export type InfrastructureEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type InfrastructureEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type InfrastructureEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type InfrastructureEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum InfrastructuresFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  InfrastructureTypes = 'infrastructure_types',
  LabelledBy = 'labelledBy',
  LastSeen = 'last_seen',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type InfrastructuresFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: InfrastructuresFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum InfrastructuresOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  InfrastructureTypes = 'infrastructure_types',
  LastSeen = 'last_seen',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type InternalObject = {
  entity_type: Scalars['String'];
  id: Scalars['ID'];
};

export type InternalRelationship = BasicRelationship & {
  __typename?: 'InternalRelationship';
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  from?: Maybe<InternalObject>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  to?: Maybe<InternalObject>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
};

export type InternalRelationshipAddInput = {
  fromId?: InputMaybe<Scalars['ID']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['ID']>;
};

export type IntrusionSet = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'IntrusionSet';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  goals?: Maybe<Array<Maybe<Scalars['String']>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  locations?: Maybe<LocationConnection>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  primary_motivation?: Maybe<Scalars['String']>;
  reports?: Maybe<ReportConnection>;
  resource_level?: Maybe<Scalars['String']>;
  revoked: Scalars['Boolean'];
  secondary_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type IntrusionSetConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type IntrusionSetExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type IntrusionSetStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IntrusionSetAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  goals?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  primary_motivation?: InputMaybe<Scalars['String']>;
  resource_level?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  secondary_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type IntrusionSetConnection = {
  __typename?: 'IntrusionSetConnection';
  edges?: Maybe<Array<Maybe<IntrusionSetEdge>>>;
  pageInfo: PageInfo;
};

export type IntrusionSetEdge = {
  __typename?: 'IntrusionSetEdge';
  cursor: Scalars['String'];
  node: IntrusionSet;
};

export type IntrusionSetEditMutations = {
  __typename?: 'IntrusionSetEditMutations';
  contextClean?: Maybe<IntrusionSet>;
  contextPatch?: Maybe<IntrusionSet>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<IntrusionSet>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<IntrusionSet>;
};


export type IntrusionSetEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type IntrusionSetEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type IntrusionSetEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type IntrusionSetEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum IntrusionSetsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type IntrusionSetsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: IntrusionSetsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum IntrusionSetsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type KillChainPhase = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'KillChainPhase';
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  kill_chain_name: Scalars['String'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  phase_name: Scalars['String'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_order?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type KillChainPhaseAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  kill_chain_name: Scalars['String'];
  modified?: InputMaybe<Scalars['DateTime']>;
  phase_name: Scalars['String'];
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type KillChainPhaseConnection = {
  __typename?: 'KillChainPhaseConnection';
  edges?: Maybe<Array<Maybe<KillChainPhaseEdge>>>;
  pageInfo: PageInfo;
};

export type KillChainPhaseEdge = {
  __typename?: 'KillChainPhaseEdge';
  cursor: Scalars['String'];
  node: KillChainPhase;
};

export type KillChainPhaseEditMutations = {
  __typename?: 'KillChainPhaseEditMutations';
  contextClean?: Maybe<KillChainPhase>;
  contextPatch?: Maybe<KillChainPhase>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<KillChainPhase>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<KillChainPhase>;
};


export type KillChainPhaseEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type KillChainPhaseEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type KillChainPhaseEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type KillChainPhaseEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum KillChainPhasesFilter {
  KillChainName = 'kill_chain_name',
  PhaseName = 'phase_name'
}

export type KillChainPhasesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: KillChainPhasesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum KillChainPhasesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  KillChainName = 'kill_chain_name',
  Modified = 'modified',
  PhaseName = 'phase_name',
  UpdatedAt = 'updated_at',
  XOpenctiOrder = 'x_opencti_order'
}

export type Label = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'Label';
  color?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type LabelAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  value: Scalars['String'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LabelConnection = {
  __typename?: 'LabelConnection';
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  pageInfo: PageInfo;
};

export type LabelEdge = {
  __typename?: 'LabelEdge';
  cursor: Scalars['String'];
  node: Label;
};

export type LabelEditMutations = {
  __typename?: 'LabelEditMutations';
  contextClean?: Maybe<Label>;
  contextPatch?: Maybe<Label>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Label>;
};


export type LabelEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type LabelEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum LabelsFilter {
  MarkedBy = 'markedBy',
  Value = 'value'
}

export type LabelsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: LabelsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LabelsOrdering {
  Color = 'color',
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  UpdatedAt = 'updated_at',
  Value = 'value'
}

export type ListTask = Task & {
  __typename?: 'ListTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<User>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_ids?: Maybe<Array<Scalars['ID']>>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type ListTaskAddInput = {
  actions: Array<InputMaybe<TaskActionInput>>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type Location = {
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type LocationConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type LocationExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type LocationStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LocationAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  type: LocationType;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type LocationConnection = {
  __typename?: 'LocationConnection';
  edges?: Maybe<Array<Maybe<LocationEdge>>>;
  pageInfo: PageInfo;
};

export type LocationEdge = {
  __typename?: 'LocationEdge';
  cursor: Scalars['String'];
  node: Location;
};

export type LocationEditMutations = {
  __typename?: 'LocationEditMutations';
  contextClean?: Maybe<Location>;
  contextPatch?: Maybe<Location>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Location>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Location>;
};


export type LocationEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type LocationEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type LocationEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type LocationEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum LocationType {
  City = 'City',
  Country = 'Country',
  Position = 'Position',
  Region = 'Region'
}

export enum LocationsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XOpenctiAliases = 'x_opencti_aliases'
}

export type LocationsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: LocationsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LocationsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Latitude = 'latitude',
  Longitude = 'longitude',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Log = {
  __typename?: 'Log';
  context_data?: Maybe<ContextData>;
  event_type: Scalars['String'];
  id: Scalars['ID'];
  timestamp: Scalars['DateTime'];
  user?: Maybe<User>;
  user_id: Scalars['String'];
};

export type LogConnection = {
  __typename?: 'LogConnection';
  edges?: Maybe<Array<Maybe<LogEdge>>>;
  pageInfo: PageInfo;
};

export type LogEdge = {
  __typename?: 'LogEdge';
  cursor: Scalars['String'];
  node: Log;
};

export enum LogsFilter {
  ApplicantId = 'applicant_id',
  ConnectionId = 'connection_id',
  EntityId = 'entity_id',
  EventType = 'event_type',
  UserId = 'user_id'
}

export type LogsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: LogsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum LogsOrdering {
  Event = 'event',
  Timestamp = 'timestamp'
}

export type LogsWorkerConfig = {
  __typename?: 'LogsWorkerConfig';
  elasticsearch_api_key?: Maybe<Scalars['String']>;
  elasticsearch_index: Scalars['String'];
  elasticsearch_password?: Maybe<Scalars['String']>;
  elasticsearch_proxy?: Maybe<Scalars['String']>;
  elasticsearch_ssl_reject_unauthorized?: Maybe<Scalars['Boolean']>;
  elasticsearch_url: Array<Maybe<Scalars['String']>>;
  elasticsearch_username?: Maybe<Scalars['String']>;
};

export type MacAddr = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'MacAddr';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type MacAddrConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MacAddrExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MacAddrStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MacAddrStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MacAddrAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type Malware = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Malware';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  architecture_execution_envs?: Maybe<Array<Maybe<Scalars['String']>>>;
  capabilities?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  implementation_languages?: Maybe<Array<Maybe<Scalars['String']>>>;
  importFiles?: Maybe<FileConnection>;
  is_family?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  malware_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type MalwareConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MalwareExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwarePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MalwareStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MalwareAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  architecture_execution_envs?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  capabilities?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  implementation_languages?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  is_family?: InputMaybe<Scalars['Boolean']>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  malware_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MalwareConnection = {
  __typename?: 'MalwareConnection';
  edges?: Maybe<Array<Maybe<MalwareEdge>>>;
  pageInfo: PageInfo;
};

export type MalwareEdge = {
  __typename?: 'MalwareEdge';
  cursor: Scalars['String'];
  node: Malware;
};

export type MalwareEditMutations = {
  __typename?: 'MalwareEditMutations';
  contextClean?: Maybe<Malware>;
  contextPatch?: Maybe<Malware>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Malware>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Malware>;
};


export type MalwareEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type MalwareEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MalwareEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type MalwareEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum MalwaresFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  IsFamily = 'is_family',
  LabelledBy = 'labelledBy',
  LastSeen = 'last_seen',
  MalwareTypes = 'malware_types',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type MalwaresFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: MalwaresFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum MalwaresOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  MalwareTypes = 'malware_types',
  Modified = 'modified',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type MarkingDefinition = BasicObject & StixMetaObject & StixObject & {
  __typename?: 'MarkingDefinition';
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  definition?: Maybe<Scalars['String']>;
  definition_type?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_color?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type MarkingDefinitionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  definition: Scalars['String'];
  definition_type: Scalars['String'];
  modified?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_color?: InputMaybe<Scalars['String']>;
  x_opencti_order: Scalars['Int'];
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MarkingDefinitionConnection = {
  __typename?: 'MarkingDefinitionConnection';
  edges?: Maybe<Array<Maybe<MarkingDefinitionEdge>>>;
  pageInfo: PageInfo;
};

export type MarkingDefinitionEdge = {
  __typename?: 'MarkingDefinitionEdge';
  cursor: Scalars['String'];
  node: MarkingDefinition;
};

export type MarkingDefinitionEditMutations = {
  __typename?: 'MarkingDefinitionEditMutations';
  contextClean?: Maybe<MarkingDefinition>;
  contextPatch?: Maybe<MarkingDefinition>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<MarkingDefinition>;
};


export type MarkingDefinitionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type MarkingDefinitionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum MarkingDefinitionsFilter {
  Definition = 'definition',
  DefinitionType = 'definition_type',
  MarkedBy = 'markedBy'
}

export type MarkingDefinitionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: MarkingDefinitionsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum MarkingDefinitionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Definition = 'definition',
  DefinitionType = 'definition_type',
  Modified = 'modified',
  UpdatedAt = 'updated_at',
  XOpenctiColor = 'x_opencti_color',
  XOpenctiOrder = 'x_opencti_order'
}

export type MessagesStats = {
  __typename?: 'MessagesStats';
  ack?: Maybe<Scalars['String']>;
  ack_details?: Maybe<AckDetails>;
};

export type Module = {
  __typename?: 'Module';
  enable: Scalars['Boolean'];
  id: Scalars['ID'];
};

export type Mutation = {
  __typename?: 'Mutation';
  artifactImport?: Maybe<Artifact>;
  askJobImport?: Maybe<File>;
  attackPatternAdd?: Maybe<AttackPattern>;
  attackPatternEdit?: Maybe<AttackPatternEditMutations>;
  bookmarkAdd?: Maybe<StixDomainObject>;
  bookmarkDelete?: Maybe<Scalars['ID']>;
  campaignAdd?: Maybe<Campaign>;
  campaignEdit?: Maybe<CampaignEditMutations>;
  cityAdd?: Maybe<City>;
  cityEdit?: Maybe<CityEditMutations>;
  containerEdit?: Maybe<ContainerEditMutations>;
  countryAdd?: Maybe<Country>;
  countryEdit?: Maybe<CountryEditMutations>;
  courseOfActionAdd?: Maybe<CourseOfAction>;
  courseOfActionEdit?: Maybe<CourseOfActionEditMutations>;
  deleteConnector: Scalars['ID'];
  deleteImport?: Maybe<Scalars['Boolean']>;
  deleteTask: Scalars['ID'];
  externalReferenceAdd?: Maybe<ExternalReference>;
  externalReferenceEdit?: Maybe<ExternalReferenceEditMutations>;
  groupAdd?: Maybe<Group>;
  groupEdit?: Maybe<GroupEditMutations>;
  identityAdd?: Maybe<Identity>;
  identityEdit?: Maybe<IdentityEditMutations>;
  incidentAdd?: Maybe<Incident>;
  incidentEdit?: Maybe<IncidentEditMutations>;
  indicatorAdd?: Maybe<Indicator>;
  indicatorEdit?: Maybe<IndicatorEditMutations>;
  individualAdd?: Maybe<Individual>;
  individualEdit?: Maybe<IndividualEditMutations>;
  infrastructureAdd?: Maybe<Infrastructure>;
  infrastructureEdit?: Maybe<InfrastructureEditMutations>;
  intrusionSetAdd?: Maybe<IntrusionSet>;
  intrusionSetEdit?: Maybe<IntrusionSetEditMutations>;
  killChainPhaseAdd?: Maybe<KillChainPhase>;
  killChainPhaseEdit?: Maybe<KillChainPhaseEditMutations>;
  labelAdd?: Maybe<Label>;
  labelEdit?: Maybe<LabelEditMutations>;
  listTaskAdd: Task;
  locationAdd?: Maybe<Location>;
  locationEdit?: Maybe<LocationEditMutations>;
  logout?: Maybe<Scalars['ID']>;
  malwareAdd?: Maybe<Malware>;
  malwareEdit?: Maybe<MalwareEditMutations>;
  markingDefinitionAdd?: Maybe<MarkingDefinition>;
  markingDefinitionEdit?: Maybe<MarkingDefinitionEditMutations>;
  meEdit?: Maybe<User>;
  meTokenRenew?: Maybe<User>;
  noteAdd?: Maybe<Note>;
  noteEdit?: Maybe<NoteEditMutations>;
  observedDataAdd?: Maybe<ObservedData>;
  observedDataEdit?: Maybe<ObservedDataEditMutations>;
  opinionAdd?: Maybe<Opinion>;
  opinionEdit?: Maybe<OpinionEditMutations>;
  organizationAdd?: Maybe<Organization>;
  organizationEdit?: Maybe<OrganizationEditMutations>;
  pingConnector?: Maybe<Connector>;
  positionAdd?: Maybe<Position>;
  positionEdit?: Maybe<PositionEditMutations>;
  queryTaskAdd: Task;
  regionAdd?: Maybe<Region>;
  regionEdit?: Maybe<RegionEditMutations>;
  registerConnector?: Maybe<Connector>;
  reportAdd?: Maybe<Report>;
  reportEdit?: Maybe<ReportEditMutations>;
  resetStateConnector?: Maybe<Connector>;
  retentionRuleAdd: RetentionRule;
  retentionRuleCheck: Scalars['Int'];
  retentionRuleEdit?: Maybe<RetentionRuleEditMutations>;
  roleAdd?: Maybe<Role>;
  roleEdit?: Maybe<RoleEditMutations>;
  ruleManagerClean: RuleManager;
  ruleSetActivation: Rule;
  runtimeAttributeEdit: Scalars['ID'];
  sectorAdd?: Maybe<Sector>;
  sectorEdit?: Maybe<SectorEditMutations>;
  sessionKill?: Maybe<Scalars['ID']>;
  settingsEdit?: Maybe<SettingsEditMutations>;
  stixCoreObjectEdit?: Maybe<StixCoreObjectEditMutations>;
  stixCoreRelationshipAdd?: Maybe<StixCoreRelationship>;
  stixCoreRelationshipDelete: Scalars['Boolean'];
  stixCoreRelationshipEdit?: Maybe<StixCoreRelationshipEditMutations>;
  stixCyberObservableAdd?: Maybe<StixCyberObservable>;
  stixCyberObservableEdit?: Maybe<StixCyberObservableEditMutations>;
  stixCyberObservableRelationshipAdd?: Maybe<StixCyberObservableRelationship>;
  stixCyberObservableRelationshipEdit?: Maybe<StixCyberObservableRelationshipEditMutations>;
  stixCyberObservablesExportAsk?: Maybe<FileConnection>;
  stixCyberObservablesExportPush?: Maybe<Scalars['Boolean']>;
  stixDomainObjectAdd?: Maybe<StixDomainObject>;
  stixDomainObjectEdit?: Maybe<StixDomainObjectEditMutations>;
  stixDomainObjectsDelete: Array<Maybe<Scalars['ID']>>;
  stixDomainObjectsExportAsk?: Maybe<FileConnection>;
  stixDomainObjectsExportPush?: Maybe<Scalars['Boolean']>;
  stixEdit?: Maybe<StixEditMutations>;
  stixRelationshipEdit?: Maybe<StixRelationshipEditMutations>;
  stixSightingRelationshipAdd?: Maybe<StixSightingRelationship>;
  stixSightingRelationshipEdit?: Maybe<StixSightingRelationshipEditMutations>;
  streamCollectionAdd?: Maybe<StreamCollection>;
  streamCollectionEdit?: Maybe<StreamCollectionEditMutations>;
  subTypeEdit?: Maybe<SubTypeEditMutations>;
  synchronizerAdd?: Maybe<Synchronizer>;
  synchronizerEdit?: Maybe<SynchronizerEditMutations>;
  synchronizerStart?: Maybe<Synchronizer>;
  synchronizerStop?: Maybe<Synchronizer>;
  synchronizerTest?: Maybe<Scalars['String']>;
  systemAdd?: Maybe<System>;
  systemEdit?: Maybe<SystemEditMutations>;
  taxiiCollectionAdd?: Maybe<TaxiiCollection>;
  taxiiCollectionEdit?: Maybe<TaxiiCollectionEditMutations>;
  threatActorAdd?: Maybe<ThreatActor>;
  threatActorEdit?: Maybe<ThreatActorEditMutations>;
  token?: Maybe<Scalars['String']>;
  toolAdd?: Maybe<Tool>;
  toolEdit?: Maybe<ToolEditMutations>;
  uploadImport?: Maybe<File>;
  uploadPending?: Maybe<File>;
  userAdd?: Maybe<User>;
  userEdit?: Maybe<UserEditMutations>;
  userSessionsKill?: Maybe<Array<Maybe<Scalars['ID']>>>;
  userSubscriptionAdd?: Maybe<UserSubscription>;
  userSubscriptionEdit?: Maybe<UserSubscriptionEditMutations>;
  vulnerabilityAdd?: Maybe<Vulnerability>;
  vulnerabilityEdit?: Maybe<VulnerabilityEditMutations>;
  workAdd: Work;
  workDelete?: Maybe<Scalars['Boolean']>;
  workEdit?: Maybe<WorkEditMutations>;
  workspaceAdd?: Maybe<Workspace>;
  workspaceEdit?: Maybe<WorkspaceEditMutations>;
};


export type MutationArtifactImportArgs = {
  createdBy?: InputMaybe<Scalars['String']>;
  file: Scalars['Upload'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_description?: InputMaybe<Scalars['String']>;
};


export type MutationAskJobImportArgs = {
  bypassEntityId?: InputMaybe<Scalars['String']>;
  bypassValidation?: InputMaybe<Scalars['Boolean']>;
  connectorId?: InputMaybe<Scalars['String']>;
  fileName: Scalars['ID'];
};


export type MutationAttackPatternAddArgs = {
  input?: InputMaybe<AttackPatternAddInput>;
};


export type MutationAttackPatternEditArgs = {
  id: Scalars['ID'];
};


export type MutationBookmarkAddArgs = {
  id: Scalars['ID'];
  type: Scalars['String'];
};


export type MutationBookmarkDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCampaignAddArgs = {
  input?: InputMaybe<CampaignAddInput>;
};


export type MutationCampaignEditArgs = {
  id: Scalars['ID'];
};


export type MutationCityAddArgs = {
  input?: InputMaybe<CityAddInput>;
};


export type MutationCityEditArgs = {
  id: Scalars['ID'];
};


export type MutationContainerEditArgs = {
  id: Scalars['ID'];
};


export type MutationCountryAddArgs = {
  input?: InputMaybe<CountryAddInput>;
};


export type MutationCountryEditArgs = {
  id: Scalars['ID'];
};


export type MutationCourseOfActionAddArgs = {
  input?: InputMaybe<CourseOfActionAddInput>;
};


export type MutationCourseOfActionEditArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteConnectorArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteImportArgs = {
  fileName?: InputMaybe<Scalars['String']>;
};


export type MutationDeleteTaskArgs = {
  id: Scalars['ID'];
};


export type MutationExternalReferenceAddArgs = {
  input?: InputMaybe<ExternalReferenceAddInput>;
};


export type MutationExternalReferenceEditArgs = {
  id: Scalars['ID'];
};


export type MutationGroupAddArgs = {
  input?: InputMaybe<GroupAddInput>;
};


export type MutationGroupEditArgs = {
  id: Scalars['ID'];
};


export type MutationIdentityAddArgs = {
  input?: InputMaybe<IdentityAddInput>;
};


export type MutationIdentityEditArgs = {
  id: Scalars['ID'];
};


export type MutationIncidentAddArgs = {
  input?: InputMaybe<IncidentAddInput>;
};


export type MutationIncidentEditArgs = {
  id: Scalars['ID'];
};


export type MutationIndicatorAddArgs = {
  input?: InputMaybe<IndicatorAddInput>;
};


export type MutationIndicatorEditArgs = {
  id: Scalars['ID'];
};


export type MutationIndividualAddArgs = {
  input?: InputMaybe<IndividualAddInput>;
};


export type MutationIndividualEditArgs = {
  id: Scalars['ID'];
};


export type MutationInfrastructureAddArgs = {
  input?: InputMaybe<InfrastructureAddInput>;
};


export type MutationInfrastructureEditArgs = {
  id: Scalars['ID'];
};


export type MutationIntrusionSetAddArgs = {
  input?: InputMaybe<IntrusionSetAddInput>;
};


export type MutationIntrusionSetEditArgs = {
  id: Scalars['ID'];
};


export type MutationKillChainPhaseAddArgs = {
  input?: InputMaybe<KillChainPhaseAddInput>;
};


export type MutationKillChainPhaseEditArgs = {
  id: Scalars['ID'];
};


export type MutationLabelAddArgs = {
  input?: InputMaybe<LabelAddInput>;
};


export type MutationLabelEditArgs = {
  id: Scalars['ID'];
};


export type MutationListTaskAddArgs = {
  input?: InputMaybe<ListTaskAddInput>;
};


export type MutationLocationAddArgs = {
  input?: InputMaybe<LocationAddInput>;
};


export type MutationLocationEditArgs = {
  id: Scalars['ID'];
};


export type MutationMalwareAddArgs = {
  input?: InputMaybe<MalwareAddInput>;
};


export type MutationMalwareEditArgs = {
  id: Scalars['ID'];
};


export type MutationMarkingDefinitionAddArgs = {
  input?: InputMaybe<MarkingDefinitionAddInput>;
};


export type MutationMarkingDefinitionEditArgs = {
  id: Scalars['ID'];
};


export type MutationMeEditArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type MutationNoteAddArgs = {
  input?: InputMaybe<NoteAddInput>;
};


export type MutationNoteEditArgs = {
  id: Scalars['ID'];
};


export type MutationObservedDataAddArgs = {
  input?: InputMaybe<ObservedDataAddInput>;
};


export type MutationObservedDataEditArgs = {
  id: Scalars['ID'];
};


export type MutationOpinionAddArgs = {
  input?: InputMaybe<OpinionAddInput>;
};


export type MutationOpinionEditArgs = {
  id: Scalars['ID'];
};


export type MutationOrganizationAddArgs = {
  input?: InputMaybe<OrganizationAddInput>;
};


export type MutationOrganizationEditArgs = {
  id: Scalars['ID'];
};


export type MutationPingConnectorArgs = {
  id: Scalars['ID'];
  state?: InputMaybe<Scalars['String']>;
};


export type MutationPositionAddArgs = {
  input?: InputMaybe<PositionAddInput>;
};


export type MutationPositionEditArgs = {
  id: Scalars['ID'];
};


export type MutationQueryTaskAddArgs = {
  input?: InputMaybe<QueryTaskAddInput>;
};


export type MutationRegionAddArgs = {
  input?: InputMaybe<RegionAddInput>;
};


export type MutationRegionEditArgs = {
  id: Scalars['ID'];
};


export type MutationRegisterConnectorArgs = {
  input?: InputMaybe<RegisterConnectorInput>;
};


export type MutationReportAddArgs = {
  input?: InputMaybe<ReportAddInput>;
};


export type MutationReportEditArgs = {
  id: Scalars['ID'];
};


export type MutationResetStateConnectorArgs = {
  id: Scalars['ID'];
};


export type MutationRetentionRuleAddArgs = {
  input?: InputMaybe<RetentionRuleAddInput>;
};


export type MutationRetentionRuleCheckArgs = {
  input?: InputMaybe<RetentionRuleAddInput>;
};


export type MutationRetentionRuleEditArgs = {
  id: Scalars['ID'];
};


export type MutationRoleAddArgs = {
  input?: InputMaybe<RoleAddInput>;
};


export type MutationRoleEditArgs = {
  id: Scalars['ID'];
};


export type MutationRuleManagerCleanArgs = {
  eventId?: InputMaybe<Scalars['ID']>;
};


export type MutationRuleSetActivationArgs = {
  enable: Scalars['Boolean'];
  id: Scalars['ID'];
};


export type MutationRuntimeAttributeEditArgs = {
  current: Scalars['String'];
  id: Scalars['String'];
  previous: Scalars['String'];
};


export type MutationSectorAddArgs = {
  input?: InputMaybe<SectorAddInput>;
};


export type MutationSectorEditArgs = {
  id: Scalars['ID'];
};


export type MutationSessionKillArgs = {
  id: Scalars['ID'];
};


export type MutationSettingsEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCoreObjectEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCoreRelationshipAddArgs = {
  input?: InputMaybe<StixCoreRelationshipAddInput>;
  reversedReturn?: InputMaybe<Scalars['Boolean']>;
};


export type MutationStixCoreRelationshipDeleteArgs = {
  fromId: Scalars['String'];
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};


export type MutationStixCoreRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCyberObservableAddArgs = {
  Artifact?: InputMaybe<ArtifactAddInput>;
  AutonomousSystem?: InputMaybe<AutonomousSystemAddInput>;
  CryptocurrencyWallet?: InputMaybe<CryptocurrencyWalletAddInput>;
  CryptographicKey?: InputMaybe<CryptographicKeyAddInput>;
  Directory?: InputMaybe<DirectoryAddInput>;
  DomainName?: InputMaybe<DomainNameAddInput>;
  EmailAddr?: InputMaybe<EmailAddrAddInput>;
  EmailMessage?: InputMaybe<EmailMessageAddInput>;
  EmailMimePartType?: InputMaybe<EmailMimePartTypeAddInput>;
  Hostname?: InputMaybe<HostnameAddInput>;
  IPv4Addr?: InputMaybe<IPv4AddrAddInput>;
  IPv6Addr?: InputMaybe<IPv6AddrAddInput>;
  MacAddr?: InputMaybe<MacAddrAddInput>;
  Mutex?: InputMaybe<MutexAddInput>;
  NetworkTraffic?: InputMaybe<NetworkTrafficAddInput>;
  Process?: InputMaybe<ProcessAddInput>;
  Software?: InputMaybe<SoftwareAddInput>;
  StixFile?: InputMaybe<StixFileAddInput>;
  Text?: InputMaybe<TextAddInput>;
  Url?: InputMaybe<UrlAddInput>;
  UserAccount?: InputMaybe<UserAccountAddInput>;
  UserAgent?: InputMaybe<UserAgentAddInput>;
  WindowsRegistryKey?: InputMaybe<WindowsRegistryKeyAddInput>;
  WindowsRegistryValueType?: InputMaybe<WindowsRegistryValueTypeAddInput>;
  X509Certificate?: InputMaybe<X509CertificateAddInput>;
  X509V3ExtensionsType?: InputMaybe<X509V3ExtensionsTypeAddInput>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  createIndicator?: InputMaybe<Scalars['Boolean']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_description?: InputMaybe<Scalars['String']>;
  x_opencti_score?: InputMaybe<Scalars['Int']>;
};


export type MutationStixCyberObservableEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCyberObservableRelationshipAddArgs = {
  input?: InputMaybe<StixCyberObservableRelationshipAddInput>;
};


export type MutationStixCyberObservableRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixCyberObservablesExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixCyberObservablesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutationStixCyberObservablesExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
};


export type MutationStixDomainObjectAddArgs = {
  input?: InputMaybe<StixDomainObjectAddInput>;
};


export type MutationStixDomainObjectEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixDomainObjectsDeleteArgs = {
  id: Array<InputMaybe<Scalars['ID']>>;
};


export type MutationStixDomainObjectsExportAskArgs = {
  context?: InputMaybe<Scalars['String']>;
  exportType: Scalars['String'];
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<StixDomainObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};


export type MutationStixDomainObjectsExportPushArgs = {
  file: Scalars['Upload'];
  listFilters?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};


export type MutationStixEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStixSightingRelationshipAddArgs = {
  input?: InputMaybe<StixSightingRelationshipAddInput>;
};


export type MutationStixSightingRelationshipEditArgs = {
  id: Scalars['ID'];
};


export type MutationStreamCollectionAddArgs = {
  input?: InputMaybe<StreamCollectionAddInput>;
};


export type MutationStreamCollectionEditArgs = {
  id: Scalars['ID'];
};


export type MutationSubTypeEditArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerAddArgs = {
  input?: InputMaybe<SynchronizerAddInput>;
};


export type MutationSynchronizerEditArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerStartArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerStopArgs = {
  id: Scalars['ID'];
};


export type MutationSynchronizerTestArgs = {
  input?: InputMaybe<SynchronizerAddInput>;
};


export type MutationSystemAddArgs = {
  input?: InputMaybe<SystemAddInput>;
};


export type MutationSystemEditArgs = {
  id: Scalars['ID'];
};


export type MutationTaxiiCollectionAddArgs = {
  input?: InputMaybe<TaxiiCollectionAddInput>;
};


export type MutationTaxiiCollectionEditArgs = {
  id: Scalars['ID'];
};


export type MutationThreatActorAddArgs = {
  input?: InputMaybe<ThreatActorAddInput>;
};


export type MutationThreatActorEditArgs = {
  id: Scalars['ID'];
};


export type MutationTokenArgs = {
  input?: InputMaybe<UserLoginInput>;
};


export type MutationToolAddArgs = {
  input?: InputMaybe<ToolAddInput>;
};


export type MutationToolEditArgs = {
  id: Scalars['ID'];
};


export type MutationUploadImportArgs = {
  file: Scalars['Upload'];
};


export type MutationUploadPendingArgs = {
  entityId?: InputMaybe<Scalars['String']>;
  file: Scalars['Upload'];
};


export type MutationUserAddArgs = {
  input?: InputMaybe<UserAddInput>;
};


export type MutationUserEditArgs = {
  id: Scalars['ID'];
};


export type MutationUserSessionsKillArgs = {
  id: Scalars['ID'];
};


export type MutationUserSubscriptionAddArgs = {
  input?: InputMaybe<UserSubscriptionAddInput>;
};


export type MutationUserSubscriptionEditArgs = {
  id: Scalars['ID'];
};


export type MutationVulnerabilityAddArgs = {
  input?: InputMaybe<VulnerabilityAddInput>;
};


export type MutationVulnerabilityEditArgs = {
  id: Scalars['ID'];
};


export type MutationWorkAddArgs = {
  connectorId: Scalars['String'];
  friendlyName?: InputMaybe<Scalars['String']>;
};


export type MutationWorkDeleteArgs = {
  connectorId: Scalars['String'];
};


export type MutationWorkEditArgs = {
  id: Scalars['ID'];
};


export type MutationWorkspaceAddArgs = {
  input?: InputMaybe<WorkspaceAddInput>;
};


export type MutationWorkspaceEditArgs = {
  id: Scalars['ID'];
};

export type Mutex = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Mutex';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type MutexConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type MutexExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type MutexStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type MutexStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type MutexAddInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type NetworkTraffic = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'NetworkTraffic';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  dst_byte_count?: Maybe<Scalars['Int']>;
  dst_packets?: Maybe<Scalars['Int']>;
  dst_port?: Maybe<Scalars['Int']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  end?: Maybe<Scalars['DateTime']>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  protocols?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  src_byte_count?: Maybe<Scalars['Int']>;
  src_packets?: Maybe<Scalars['Int']>;
  src_port?: Maybe<Scalars['Int']>;
  standard_id: Scalars['String'];
  start?: Maybe<Scalars['DateTime']>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type NetworkTrafficConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type NetworkTrafficExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NetworkTrafficStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NetworkTrafficStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NetworkTrafficAddInput = {
  dst_byte_count?: InputMaybe<Scalars['Int']>;
  dst_packets?: InputMaybe<Scalars['Int']>;
  dst_port?: InputMaybe<Scalars['Int']>;
  end?: InputMaybe<Scalars['DateTime']>;
  is_active?: InputMaybe<Scalars['Boolean']>;
  protocols?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  src_byte_count?: InputMaybe<Scalars['Int']>;
  src_packets?: InputMaybe<Scalars['Int']>;
  src_port?: InputMaybe<Scalars['Int']>;
  start?: InputMaybe<Scalars['DateTime']>;
};

export type Note = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Note';
  attribute_abstract?: Maybe<Scalars['String']>;
  authors?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  content: Scalars['String'];
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type NoteConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type NoteExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NotePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type NoteStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NoteAddInput = {
  attribute_abstract?: InputMaybe<Scalars['String']>;
  authors?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  content: Scalars['String'];
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type NoteConnection = {
  __typename?: 'NoteConnection';
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  pageInfo: PageInfo;
};

export type NoteEdge = {
  __typename?: 'NoteEdge';
  cursor: Scalars['String'];
  node: Note;
};

export type NoteEditMutations = {
  __typename?: 'NoteEditMutations';
  contextClean?: Maybe<Note>;
  contextPatch?: Maybe<Note>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Note>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Note>;
};


export type NoteEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type NoteEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type NoteEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type NoteEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum NotesFilter {
  AttributeAbstract = 'attribute_abstract',
  Authors = 'authors',
  Content = 'content',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ObjectContains = 'objectContains',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type NotesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: NotesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum NotesOrdering {
  AttributeAbstract = 'attribute_abstract',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Modified = 'modified',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Number = {
  __typename?: 'Number';
  count: Scalars['Int'];
  total: Scalars['Int'];
};

export type ObjectTotals = {
  __typename?: 'ObjectTotals';
  channels?: Maybe<Scalars['String']>;
  consumers?: Maybe<Scalars['String']>;
  queues?: Maybe<Scalars['String']>;
};

export type ObservedData = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'ObservedData';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_observed: Scalars['DateTime'];
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_observed: Scalars['DateTime'];
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  number_observed: Scalars['Int'];
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ObservedDataConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ObservedDataExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ObservedDataStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ObservedDataAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_observed: Scalars['DateTime'];
  lang?: InputMaybe<Scalars['String']>;
  last_observed: Scalars['DateTime'];
  modified?: InputMaybe<Scalars['DateTime']>;
  number_observed?: InputMaybe<Scalars['Int']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects: Array<InputMaybe<Scalars['String']>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ObservedDataConnection = {
  __typename?: 'ObservedDataConnection';
  edges?: Maybe<Array<Maybe<ObservedDataEdge>>>;
  pageInfo: PageInfo;
};

export type ObservedDataEdge = {
  __typename?: 'ObservedDataEdge';
  cursor: Scalars['String'];
  node: ObservedData;
};

export type ObservedDataEditMutations = {
  __typename?: 'ObservedDataEditMutations';
  contextClean?: Maybe<ObservedData>;
  contextPatch?: Maybe<ObservedData>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ObservedData>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ObservedData>;
};


export type ObservedDataEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ObservedDataEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ObservedDataEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ObservedDataEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum ObservedDatasFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstObserved = 'first_observed',
  LabelledBy = 'labelledBy',
  LastObserved = 'last_observed',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  NumberObserved = 'number_observed',
  ObjectContains = 'objectContains',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type ObservedDatasFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ObservedDatasFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ObservedDatasOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FirstObserved = 'first_observed',
  LastObserved = 'last_observed',
  Modified = 'modified',
  NumberObserved = 'number_observed',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Opinion = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Opinion';
  authors?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  explanation?: Maybe<Scalars['String']>;
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  opinion: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  relatedContainers?: Maybe<ContainerConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type OpinionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type OpinionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OpinionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OpinionAddInput = {
  authors?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  explanation?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  opinion: Scalars['String'];
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OpinionConnection = {
  __typename?: 'OpinionConnection';
  edges?: Maybe<Array<Maybe<OpinionEdge>>>;
  pageInfo: PageInfo;
};

export type OpinionEdge = {
  __typename?: 'OpinionEdge';
  cursor: Scalars['String'];
  node: Opinion;
};

export type OpinionEditMutations = {
  __typename?: 'OpinionEditMutations';
  contextClean?: Maybe<Opinion>;
  contextPatch?: Maybe<Opinion>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Opinion>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Opinion>;
};


export type OpinionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type OpinionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OpinionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type OpinionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum OpinionsFilter {
  Authors = 'authors',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Explanation = 'explanation',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ObjectContains = 'objectContains',
  Opinion = 'opinion',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type OpinionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: OpinionsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum OpinionsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Modified = 'modified',
  ObjectMarking = 'objectMarking',
  Opinion = 'opinion',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export enum OrderingMode {
  Asc = 'asc',
  Desc = 'desc'
}

export type Organization = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Organization';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  sectors?: Maybe<SectorConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_organization_type?: Maybe<Scalars['String']>;
  x_opencti_reliability?: Maybe<OrganizationReliability>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type OrganizationConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type OrganizationExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type OrganizationStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OrganizationAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_organization_type?: InputMaybe<Scalars['String']>;
  x_opencti_reliability?: InputMaybe<OrganizationReliability>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type OrganizationConnection = {
  __typename?: 'OrganizationConnection';
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;
  pageInfo: PageInfo;
};

export type OrganizationEdge = {
  __typename?: 'OrganizationEdge';
  cursor: Scalars['String'];
  node: Organization;
};

export type OrganizationEditMutations = {
  __typename?: 'OrganizationEditMutations';
  contextClean?: Maybe<Organization>;
  contextPatch?: Maybe<Organization>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Organization>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Organization>;
};


export type OrganizationEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type OrganizationEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type OrganizationEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type OrganizationEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type OrganizationOrIndividual = Individual | Organization;

export enum OrganizationReliability {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  E = 'E',
  F = 'F'
}

export enum OrganizationsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiReliability = 'x_opencti_reliability'
}

export type OrganizationsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: OrganizationsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum OrganizationsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  XOpenctiOrganizationType = 'x_opencti_organization_type'
}

export type OverviewMetrics = {
  __typename?: 'OverviewMetrics';
  message_stats?: Maybe<MessagesStats>;
  node?: Maybe<Scalars['String']>;
  object_totals?: Maybe<ObjectTotals>;
  queue_totals?: Maybe<QueueTotals>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor: Scalars['String'];
  globalCount: Scalars['Int'];
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
};

export type Position = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Position';
  city?: Maybe<City>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  postal_code?: Maybe<Scalars['String']>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  street_address?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type PositionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type PositionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type PositionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type PositionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  postal_code?: InputMaybe<Scalars['String']>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  street_address?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type PositionConnection = {
  __typename?: 'PositionConnection';
  edges?: Maybe<Array<Maybe<PositionEdge>>>;
  pageInfo: PageInfo;
};

export type PositionEdge = {
  __typename?: 'PositionEdge';
  cursor: Scalars['String'];
  node: Position;
};

export type PositionEditMutations = {
  __typename?: 'PositionEditMutations';
  contextClean?: Maybe<Position>;
  contextPatch?: Maybe<Position>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Position>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Position>;
};


export type PositionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type PositionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type PositionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type PositionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum PositionsFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type PositionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: PositionsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum PositionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  PostalAddress = 'postal_address',
  PostalCode = 'postal_code',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Process = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Process';
  command_line?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  created_time?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<User>;
  cwd?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  environment_variables?: Maybe<Array<Maybe<Scalars['String']>>>;
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_hidden?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  pid?: Maybe<Scalars['Int']>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ProcessConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ProcessExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ProcessStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ProcessStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ProcessAddInput = {
  command_line?: InputMaybe<Scalars['String']>;
  created_time?: InputMaybe<Scalars['DateTime']>;
  cwd?: InputMaybe<Scalars['String']>;
  environment_variables?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  is_hidden?: InputMaybe<Scalars['Boolean']>;
  pid?: InputMaybe<Scalars['Int']>;
};

export type Provider = {
  __typename?: 'Provider';
  name: Scalars['String'];
  provider?: Maybe<Scalars['String']>;
  strategy?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  about?: Maybe<AppInfo>;
  attackPattern?: Maybe<AttackPattern>;
  attackPatterns?: Maybe<AttackPatternConnection>;
  bookmarks?: Maybe<StixDomainObjectConnection>;
  campaign?: Maybe<Campaign>;
  campaigns?: Maybe<CampaignConnection>;
  campaignsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  capabilities?: Maybe<CapabilityConnection>;
  cities?: Maybe<CityConnection>;
  city?: Maybe<City>;
  connector?: Maybe<Connector>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  connectorsForExport?: Maybe<Array<Maybe<Connector>>>;
  connectorsForImport?: Maybe<Array<Maybe<Connector>>>;
  container?: Maybe<Container>;
  containers?: Maybe<ContainerConnection>;
  containersObjectsOfObject?: Maybe<StixObjectOrStixRelationshipConnection>;
  countries?: Maybe<CountryConnection>;
  country?: Maybe<Country>;
  courseOfAction?: Maybe<CourseOfAction>;
  coursesOfAction?: Maybe<CourseOfActionConnection>;
  elasticSearchMetrics?: Maybe<ElasticSearchMetrics>;
  externalReference?: Maybe<ExternalReference>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  file?: Maybe<File>;
  group?: Maybe<Group>;
  groups?: Maybe<GroupConnection>;
  identities?: Maybe<IdentityConnection>;
  identity?: Maybe<Identity>;
  importFiles?: Maybe<FileConnection>;
  incident?: Maybe<Incident>;
  incidents?: Maybe<IncidentConnection>;
  incidentsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  indicator?: Maybe<Indicator>;
  indicators?: Maybe<IndicatorConnection>;
  indicatorsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  indicatorsNumber?: Maybe<Number>;
  indicatorsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  individual?: Maybe<Individual>;
  individuals?: Maybe<IndividualConnection>;
  infrastructure?: Maybe<Infrastructure>;
  infrastructures?: Maybe<InfrastructureConnection>;
  intrusionSet?: Maybe<IntrusionSet>;
  intrusionSets?: Maybe<IntrusionSetConnection>;
  killChainPhase?: Maybe<KillChainPhase>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  label?: Maybe<Label>;
  labels?: Maybe<LabelConnection>;
  location?: Maybe<Location>;
  locations?: Maybe<LocationConnection>;
  logs?: Maybe<LogConnection>;
  logsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  logsWorkerConfig?: Maybe<LogsWorkerConfig>;
  malware?: Maybe<Malware>;
  malwares?: Maybe<MalwareConnection>;
  markingDefinition?: Maybe<MarkingDefinition>;
  markingDefinitions?: Maybe<MarkingDefinitionConnection>;
  me?: Maybe<User>;
  myOpinion?: Maybe<Opinion>;
  note?: Maybe<Note>;
  noteContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<NoteConnection>;
  notesDistribution?: Maybe<Array<Maybe<Distribution>>>;
  notesNumber?: Maybe<Number>;
  notesTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  observedData?: Maybe<ObservedData>;
  observedDataContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  observedDatas?: Maybe<ObservedDataConnection>;
  observedDatasDistribution?: Maybe<Array<Maybe<Distribution>>>;
  observedDatasNumber?: Maybe<Number>;
  observedDatasTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  opinion?: Maybe<Opinion>;
  opinionContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  opinions?: Maybe<OpinionConnection>;
  opinionsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  opinionsNumber?: Maybe<Number>;
  opinionsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  organization?: Maybe<Organization>;
  organizations?: Maybe<OrganizationConnection>;
  pendingFiles?: Maybe<FileConnection>;
  platform_theme?: Maybe<Scalars['String']>;
  position?: Maybe<Position>;
  positions?: Maybe<PositionConnection>;
  rabbitMQMetrics?: Maybe<RabbitMqMetrics>;
  region?: Maybe<Region>;
  regions?: Maybe<RegionConnection>;
  report?: Maybe<Report>;
  reportContainsStixObjectOrStixRelationship?: Maybe<Scalars['Boolean']>;
  reports?: Maybe<ReportConnection>;
  reportsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  reportsNumber?: Maybe<Number>;
  reportsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  retentionRule?: Maybe<RetentionRule>;
  retentionRules?: Maybe<RetentionRuleConnection>;
  role?: Maybe<Role>;
  roles?: Maybe<RoleConnection>;
  rule?: Maybe<Rule>;
  ruleManagerInfo?: Maybe<RuleManager>;
  rules?: Maybe<Array<Maybe<Rule>>>;
  runtimeAttributes?: Maybe<AttributeConnection>;
  schemaAttributes?: Maybe<AttributeConnection>;
  sector?: Maybe<Sector>;
  sectors?: Maybe<SectorConnection>;
  sessions?: Maybe<Array<Maybe<UserSession>>>;
  settings?: Maybe<Settings>;
  status?: Maybe<Status>;
  statusTemplate?: Maybe<StatusTemplate>;
  statusTemplates?: Maybe<StatusTemplateConnection>;
  statuses?: Maybe<StatusConnection>;
  stix?: Maybe<Scalars['String']>;
  stixCoreObject?: Maybe<StixCoreObject>;
  stixCoreObjectOrStixCoreRelationship?: Maybe<StixCoreObjectOrStixCoreRelationship>;
  stixCoreObjectRaw?: Maybe<Scalars['String']>;
  stixCoreObjects?: Maybe<StixCoreObjectConnection>;
  stixCoreRelationship?: Maybe<StixCoreRelationship>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCoreRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCoreRelationshipsNumber?: Maybe<Number>;
  stixCoreRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixCyberObservable?: Maybe<StixCyberObservable>;
  stixCyberObservableRelationship?: Maybe<StixCyberObservableRelationship>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  stixCyberObservableRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservableRelationshipsNumber?: Maybe<Number>;
  stixCyberObservableRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixCyberObservables?: Maybe<StixCyberObservableConnection>;
  stixCyberObservablesDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixCyberObservablesExportFiles?: Maybe<FileConnection>;
  stixCyberObservablesNumber?: Maybe<Number>;
  stixCyberObservablesTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixDomainObject?: Maybe<StixDomainObject>;
  stixDomainObjects?: Maybe<StixDomainObjectConnection>;
  stixDomainObjectsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixDomainObjectsExportFiles?: Maybe<FileConnection>;
  stixDomainObjectsNumber?: Maybe<Number>;
  stixDomainObjectsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  stixMetaRelationship?: Maybe<StixMetaRelationship>;
  stixMetaRelationships?: Maybe<StixMetaRelationshipConnection>;
  stixMetaRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixMetaRelationshipsNumber?: Maybe<Number>;
  stixObjectOrStixRelationship?: Maybe<StixObjectOrStixRelationship>;
  stixRelationship?: Maybe<StixRelationship>;
  stixRelationships?: Maybe<StixRelationshipConnection>;
  stixSightingRelationship?: Maybe<StixSightingRelationship>;
  stixSightingRelationships?: Maybe<StixSightingRelationshipConnection>;
  stixSightingRelationshipsDistribution?: Maybe<Array<Maybe<Distribution>>>;
  stixSightingRelationshipsNumber?: Maybe<Number>;
  stixSightingRelationshipsTimeSeries?: Maybe<Array<Maybe<TimeSeries>>>;
  streamCollection?: Maybe<StreamCollection>;
  streamCollections?: Maybe<StreamCollectionConnection>;
  subType?: Maybe<SubType>;
  subTypes?: Maybe<SubTypeConnection>;
  synchronizer?: Maybe<Synchronizer>;
  synchronizers?: Maybe<SynchronizerConnection>;
  system?: Maybe<System>;
  systems?: Maybe<SystemConnection>;
  task?: Maybe<Task>;
  tasks?: Maybe<TaskConnection>;
  taxiiCollection?: Maybe<TaxiiCollection>;
  taxiiCollections?: Maybe<TaxiiCollectionConnection>;
  threatActor?: Maybe<ThreatActor>;
  threatActors?: Maybe<ThreatActorConnection>;
  tool?: Maybe<Tool>;
  tools?: Maybe<ToolConnection>;
  user?: Maybe<User>;
  userSubscription?: Maybe<UserSubscription>;
  userSubscriptions?: Maybe<UserSubscriptionConnection>;
  users?: Maybe<UserConnection>;
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  vulnerability?: Maybe<Vulnerability>;
  work?: Maybe<Work>;
  works?: Maybe<WorkConnection>;
  workspace?: Maybe<Workspace>;
  workspaces?: Maybe<WorkspaceConnection>;
};


export type QueryAttackPatternArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryAttackPatternsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<AttackPatternsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AttackPatternsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryCampaignArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCampaignsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CampaignsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CampaignsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCampaignsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  relationship_type?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryCapabilitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryCitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCityArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryConnectorArgs = {
  id: Scalars['String'];
};


export type QueryContainerArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryContainersObjectsOfObjectArgs = {
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  id: Scalars['String'];
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryCountriesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CountriesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CountriesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCountryArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCourseOfActionArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryCoursesOfActionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<CoursesOfActionFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CoursesOfActionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryExternalReferenceArgs = {
  id: Scalars['String'];
};


export type QueryExternalReferencesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ExternalReferencesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ExternalReferencesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryFileArgs = {
  id: Scalars['String'];
};


export type QueryGroupArgs = {
  id: Scalars['String'];
};


export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GroupsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIdentitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IdentitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IdentitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryIdentityArgs = {
  id: Scalars['String'];
};


export type QueryImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryIncidentArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryIncidentsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IncidentsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IncidentsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryIncidentsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  relationship_type?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryIndicatorArgs = {
  id: Scalars['String'];
};


export type QueryIndicatorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IndicatorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndicatorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIndicatorsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryIndicatorsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
  pattern_type?: InputMaybe<Scalars['String']>;
};


export type QueryIndicatorsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  pattern_type?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryIndividualArgs = {
  id: Scalars['String'];
};


export type QueryIndividualsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IndividualsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndividualsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryInfrastructureArgs = {
  id: Scalars['String'];
};


export type QueryInfrastructuresArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<InfrastructuresFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<InfrastructuresOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryIntrusionSetArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryIntrusionSetsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<IntrusionSetsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IntrusionSetsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryKillChainPhaseArgs = {
  id: Scalars['String'];
};


export type QueryKillChainPhasesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<KillChainPhasesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<KillChainPhasesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLabelArgs = {
  id: Scalars['String'];
};


export type QueryLabelsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<LabelsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLocationArgs = {
  id: Scalars['String'];
};


export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<LocationsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LocationsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryLogsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<LogsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LogsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryLogsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
  userId?: InputMaybe<Scalars['String']>;
};


export type QueryMalwareArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryMalwaresArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<MalwaresFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MalwaresOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryMarkingDefinitionArgs = {
  id: Scalars['String'];
};


export type QueryMarkingDefinitionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<MarkingDefinitionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MarkingDefinitionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryMyOpinionArgs = {
  id: Scalars['String'];
};


export type QueryNoteArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryNoteContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryNotesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<NotesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NotesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryNotesDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
};


export type QueryNotesNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryNotesTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryObservedDataArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDataContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryObservedDatasArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ObservedDatasFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ObservedDatasOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryObservedDatasDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDatasNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryObservedDatasTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryOpinionArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryOpinionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<OpinionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OpinionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryOpinionsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
};


export type QueryOpinionsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryOrganizationArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<OrganizationsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrganizationsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryPositionArgs = {
  id: Scalars['String'];
};


export type QueryPositionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<PositionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PositionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRabbitMqMetricsArgs = {
  prefix?: InputMaybe<Scalars['String']>;
};


export type QueryRegionArgs = {
  id: Scalars['String'];
};


export type QueryRegionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<RegionsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RegionsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryReportArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryReportContainsStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
  stixObjectOrStixRelationshipId: Scalars['String'];
};


export type QueryReportsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ReportsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ReportsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryReportsDistributionArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
};


export type QueryReportsNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  objectId?: InputMaybe<Scalars['String']>;
  reportType?: InputMaybe<Scalars['String']>;
};


export type QueryReportsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  interval: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  reportType?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
};


export type QueryRetentionRuleArgs = {
  id: Scalars['String'];
};


export type QueryRetentionRulesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryRoleArgs = {
  id: Scalars['String'];
};


export type QueryRolesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RolesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryRuleArgs = {
  id: Scalars['String'];
};


export type QueryRuntimeAttributesArgs = {
  attributeName: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySchemaAttributesArgs = {
  elementType: Scalars['String'];
};


export type QuerySectorArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QuerySectorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<SectorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SectorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryStatusArgs = {
  id: Scalars['String'];
};


export type QueryStatusTemplateArgs = {
  id: Scalars['String'];
};


export type QueryStatusTemplatesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StatusTemplateOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
};


export type QueryStatusesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StatusesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StatusOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryStixArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectOrStixCoreRelationshipArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectRawArgs = {
  id: Scalars['String'];
};


export type QueryStixCoreObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreObjectsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixCoreObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  fromId?: InputMaybe<Scalars['String']>;
  isTo?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  noDirection?: InputMaybe<Scalars['Boolean']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCoreRelationshipsNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  noDirection?: InputMaybe<Scalars['Boolean']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type?: InputMaybe<Scalars['String']>;
};


export type QueryStixCoreRelationshipsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  fromId?: InputMaybe<Scalars['String']>;
  interval: Scalars['String'];
  operation: StatsOperation;
  relationship_type?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableArgs = {
  id: Scalars['String'];
};


export type QueryStixCyberObservableRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  fromId: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservableRelationshipsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
};


export type QueryStixCyberObservableRelationshipsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  fromId?: InputMaybe<Scalars['String']>;
  interval: Scalars['String'];
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryStixCyberObservablesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservablesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixCyberObservablesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservablesDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  objectId?: InputMaybe<Scalars['String']>;
  operation: Scalars['String'];
};


export type QueryStixCyberObservablesExportFilesArgs = {
  context?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type QueryStixCyberObservablesNumberArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixCyberObservablesTimeSeriesArgs = {
  type?: InputMaybe<Scalars['String']>;
};


export type QueryStixDomainObjectArgs = {
  id: Scalars['String'];
};


export type QueryStixDomainObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixDomainObjectsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixDomainObjectsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  objectId?: InputMaybe<Scalars['String']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type: Scalars['String'];
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  type: Scalars['String'];
};


export type QueryStixDomainObjectsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixDomainObjectsTimeSeriesArgs = {
  authorId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  interval: Scalars['String'];
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
  type?: InputMaybe<Scalars['String']>;
};


export type QueryStixMetaRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixMetaRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixMetaRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixMetaRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixMetaRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  relationship_type?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixMetaRelationshipsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};


export type QueryStixObjectOrStixRelationshipArgs = {
  id: Scalars['String'];
};


export type QueryStixRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  elementId?: InputMaybe<Scalars['String']>;
  elementWithTargetTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromRole?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  search?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stix?: InputMaybe<Scalars['Boolean']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toRole?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryStixSightingRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  elementId?: InputMaybe<Scalars['String']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixSightingRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixSightingRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipsDistributionArgs = {
  dateAttribute?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  field: Scalars['String'];
  fromId: Scalars['String'];
  limit?: InputMaybe<Scalars['Int']>;
  operation: StatsOperation;
  order?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type QueryStixSightingRelationshipsNumberArgs = {
  endDate?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
};


export type QueryStixSightingRelationshipsTimeSeriesArgs = {
  endDate: Scalars['DateTime'];
  field: Scalars['String'];
  fromId?: InputMaybe<Scalars['String']>;
  interval: Scalars['String'];
  operation: StatsOperation;
  startDate: Scalars['DateTime'];
};


export type QueryStreamCollectionArgs = {
  id: Scalars['String'];
};


export type QueryStreamCollectionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamCollectionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySubTypeArgs = {
  id: Scalars['String'];
};


export type QuerySubTypesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  includeParents?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<SubTypesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};


export type QuerySynchronizerArgs = {
  id: Scalars['String'];
};


export type QuerySynchronizersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SynchronizersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QuerySystemArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QuerySystemsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<SystemsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SystemsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryTaskArgs = {
  id: Scalars['String'];
};


export type QueryTasksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<TasksFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TasksOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryTaxiiCollectionArgs = {
  id: Scalars['String'];
};


export type QueryTaxiiCollectionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TaxiiCollectionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryThreatActorArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryThreatActorsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ThreatActorsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ThreatActorsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryToolArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryToolsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ToolsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ToolsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryUserArgs = {
  id: Scalars['String'];
};


export type QueryUserSubscriptionArgs = {
  id: Scalars['String'];
};


export type QueryUserSubscriptionsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserSubscriptionOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<UsersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UsersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<VulnerabilitiesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<VulnerabilitiesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  toStix?: InputMaybe<Scalars['Boolean']>;
};


export type QueryVulnerabilityArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryWorkArgs = {
  id: Scalars['ID'];
};


export type QueryWorksArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<WorksFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WorksOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryWorkspaceArgs = {
  id?: InputMaybe<Scalars['String']>;
};


export type QueryWorkspacesArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<WorkspacesFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WorkspacesOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryTask = Task & {
  __typename?: 'QueryTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<User>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_filters: Scalars['String'];
  task_processed_number?: Maybe<Scalars['Int']>;
  task_search?: Maybe<Scalars['String']>;
  type?: Maybe<TaskType>;
};

export type QueryTaskAddInput = {
  actions: Array<InputMaybe<TaskActionInput>>;
  excluded_ids?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  filters: Scalars['String'];
  search?: InputMaybe<Scalars['String']>;
};

export type QueueArguments = {
  __typename?: 'QueueArguments';
  config?: Maybe<Scalars['String']>;
};

export type QueueMetrics = {
  __typename?: 'QueueMetrics';
  arguments?: Maybe<QueueArguments>;
  consumers?: Maybe<Scalars['String']>;
  idle_since?: Maybe<Scalars['DateTime']>;
  message_stats?: Maybe<MessagesStats>;
  messages?: Maybe<Scalars['String']>;
  messages_ready?: Maybe<Scalars['String']>;
  messages_unacknowledged?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

export type QueueTotals = {
  __typename?: 'QueueTotals';
  messages?: Maybe<Scalars['String']>;
  messages_ready?: Maybe<Scalars['String']>;
  messages_unacknowledged?: Maybe<Scalars['String']>;
};

export type RabbitMqConnection = {
  __typename?: 'RabbitMQConnection';
  ca?: Maybe<Array<Maybe<Scalars['String']>>>;
  host: Scalars['String'];
  pass: Scalars['String'];
  port: Scalars['Int'];
  use_ssl: Scalars['Boolean'];
  user: Scalars['String'];
};

export type RabbitMqMetrics = {
  __typename?: 'RabbitMQMetrics';
  consumers?: Maybe<Scalars['String']>;
  overview?: Maybe<OverviewMetrics>;
  queues?: Maybe<Array<Maybe<QueueMetrics>>>;
};

export type Region = BasicObject & Location & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Region';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  countries?: Maybe<CountryConnection>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  isSubRegion?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentRegions?: Maybe<RegionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  precision?: Maybe<Scalars['Float']>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  subRegions?: Maybe<RegionConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type RegionConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type RegionExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RegionStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type RegionAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  precision?: InputMaybe<Scalars['Float']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type RegionConnection = {
  __typename?: 'RegionConnection';
  edges?: Maybe<Array<Maybe<RegionEdge>>>;
  pageInfo: PageInfo;
};

export type RegionEdge = {
  __typename?: 'RegionEdge';
  cursor: Scalars['String'];
  node: Region;
};

export type RegionEditMutations = {
  __typename?: 'RegionEditMutations';
  contextClean?: Maybe<Region>;
  contextPatch?: Maybe<Region>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Region>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Region>;
};


export type RegionEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type RegionEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type RegionEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type RegionEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum RegionsFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  StatusId = 'status_id'
}

export type RegionsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: RegionsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum RegionsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type RegisterConnectorInput = {
  auto?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  only_contextual?: InputMaybe<Scalars['Boolean']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
  type: ConnectorType;
};

export type Report = BasicObject & Container & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Report';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  published?: Maybe<Scalars['DateTime']>;
  relatedContainers?: Maybe<ContainerConnection>;
  report_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ReportConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ReportExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportRelatedContainersArgs = {
  after?: InputMaybe<Scalars['ID']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<ContainersFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContainersOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  viaTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ReportStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ReportAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  published: Scalars['DateTime'];
  report_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ReportConnection = {
  __typename?: 'ReportConnection';
  edges?: Maybe<Array<Maybe<ReportEdge>>>;
  pageInfo: PageInfo;
};

export type ReportEdge = {
  __typename?: 'ReportEdge';
  cursor: Scalars['String'];
  node: Report;
};

export type ReportEditMutations = {
  __typename?: 'ReportEditMutations';
  contextClean?: Maybe<Report>;
  contextPatch?: Maybe<Report>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Report>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Report>;
};


export type ReportEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ReportEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ReportEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ReportEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum ReportsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Name = 'name',
  ObjectContains = 'objectContains',
  ObjectLabel = 'objectLabel',
  Published = 'published',
  PublishedDay = 'published_day',
  ReportTypes = 'report_types',
  Revoked = 'revoked',
  StatusId = 'status_id'
}

export type ReportsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ReportsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum ReportsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type RetentionRule = {
  __typename?: 'RetentionRule';
  filters: Scalars['String'];
  id: Scalars['ID'];
  last_deleted_count?: Maybe<Scalars['Int']>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  max_retention: Scalars['Int'];
  name: Scalars['String'];
  remaining_count?: Maybe<Scalars['Int']>;
  standard_id: Scalars['String'];
};

export type RetentionRuleAddInput = {
  filters: Scalars['String'];
  max_retention: Scalars['Int'];
  name: Scalars['String'];
};

export type RetentionRuleConnection = {
  __typename?: 'RetentionRuleConnection';
  edges?: Maybe<Array<Maybe<RetentionRuleEdge>>>;
  pageInfo: PageInfo;
};

export type RetentionRuleEdge = {
  __typename?: 'RetentionRuleEdge';
  cursor: Scalars['String'];
  node: RetentionRule;
};

export type RetentionRuleEditMutations = {
  __typename?: 'RetentionRuleEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<RetentionRule>;
};


export type RetentionRuleEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export type Role = BasicObject & InternalObject & {
  __typename?: 'Role';
  capabilities?: Maybe<Array<Maybe<Capability>>>;
  created_at: Scalars['DateTime'];
  default_assignation?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type RoleAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type RoleConnection = {
  __typename?: 'RoleConnection';
  edges?: Maybe<Array<Maybe<RoleEdge>>>;
  pageInfo: PageInfo;
};

export type RoleEdge = {
  __typename?: 'RoleEdge';
  cursor: Scalars['String'];
  node: Role;
};

export type RoleEditMutations = {
  __typename?: 'RoleEditMutations';
  contextClean?: Maybe<Role>;
  contextPatch?: Maybe<Role>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Role>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<Role>;
};


export type RoleEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type RoleEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type RoleEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type RoleEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum RolesOrdering {
  CreatedAt = 'created_at',
  DefaultAssignation = 'default_assignation',
  Name = 'name',
  UpdatedAt = 'updated_at'
}

export type Rule = {
  __typename?: 'Rule';
  activated: Scalars['Boolean'];
  description: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type RuleExecutionError = {
  __typename?: 'RuleExecutionError';
  error?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export type RuleManager = {
  __typename?: 'RuleManager';
  activated: Scalars['Boolean'];
  errors?: Maybe<Array<Maybe<RuleExecutionError>>>;
  id: Scalars['ID'];
  lastEventId?: Maybe<Scalars['String']>;
};

export type RuleTask = Task & {
  __typename?: 'RuleTask';
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  enable?: Maybe<Scalars['Boolean']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<User>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  rule: Scalars['ID'];
  task_expected_number?: Maybe<Scalars['Int']>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type SearchMetrics = {
  __typename?: 'SearchMetrics';
  fetch_total?: Maybe<Scalars['String']>;
  query_total?: Maybe<Scalars['String']>;
};

export type Sector = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Sector';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  isSubSector?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parentSectors?: Maybe<SectorConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  subSectors?: Maybe<SectorConnection>;
  targetedOrganizations?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type SectorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SectorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SectorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SectorAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SectorConnection = {
  __typename?: 'SectorConnection';
  edges?: Maybe<Array<Maybe<SectorEdge>>>;
  pageInfo: PageInfo;
};

export type SectorEdge = {
  __typename?: 'SectorEdge';
  cursor: Scalars['String'];
  node: Sector;
};

export type SectorEditMutations = {
  __typename?: 'SectorEditMutations';
  contextClean?: Maybe<Sector>;
  contextPatch?: Maybe<Sector>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Sector>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Sector>;
};


export type SectorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SectorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SectorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type SectorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum SectorsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  PartOf = 'partOf',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type SectorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: SectorsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum SectorsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  Description = 'description',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type SessionDetail = {
  __typename?: 'SessionDetail';
  created?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  ttl?: Maybe<Scalars['Int']>;
};

export type Settings = BasicObject & InternalObject & {
  __typename?: 'Settings';
  created_at: Scalars['DateTime'];
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  parent_types: Array<Maybe<Scalars['String']>>;
  platform_email?: Maybe<Scalars['String']>;
  platform_enable_reference?: Maybe<Array<Maybe<Scalars['String']>>>;
  platform_favicon?: Maybe<Scalars['String']>;
  platform_feature_flags?: Maybe<Array<Maybe<Module>>>;
  platform_language?: Maybe<Scalars['String']>;
  platform_login_message?: Maybe<Scalars['String']>;
  platform_map_tile_server_dark?: Maybe<Scalars['String']>;
  platform_map_tile_server_light?: Maybe<Scalars['String']>;
  platform_modules?: Maybe<Array<Maybe<Module>>>;
  platform_providers?: Maybe<Array<Maybe<Provider>>>;
  platform_reference_attachment?: Maybe<Scalars['Boolean']>;
  platform_theme?: Maybe<Scalars['String']>;
  platform_theme_dark_accent?: Maybe<Scalars['String']>;
  platform_theme_dark_background?: Maybe<Scalars['String']>;
  platform_theme_dark_logo?: Maybe<Scalars['String']>;
  platform_theme_dark_logo_login?: Maybe<Scalars['String']>;
  platform_theme_dark_nav?: Maybe<Scalars['String']>;
  platform_theme_dark_paper?: Maybe<Scalars['String']>;
  platform_theme_dark_primary?: Maybe<Scalars['String']>;
  platform_theme_dark_secondary?: Maybe<Scalars['String']>;
  platform_theme_light_accent?: Maybe<Scalars['String']>;
  platform_theme_light_background?: Maybe<Scalars['String']>;
  platform_theme_light_logo?: Maybe<Scalars['String']>;
  platform_theme_light_logo_login?: Maybe<Scalars['String']>;
  platform_theme_light_nav?: Maybe<Scalars['String']>;
  platform_theme_light_paper?: Maybe<Scalars['String']>;
  platform_theme_light_primary?: Maybe<Scalars['String']>;
  platform_theme_light_secondary?: Maybe<Scalars['String']>;
  platform_title?: Maybe<Scalars['String']>;
  platform_url?: Maybe<Scalars['String']>;
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
};

export type SettingsEditMutations = {
  __typename?: 'SettingsEditMutations';
  contextClean?: Maybe<Settings>;
  contextPatch?: Maybe<Settings>;
  fieldPatch?: Maybe<Settings>;
};


export type SettingsEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SettingsEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export type Software = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Software';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  cpe?: Maybe<Scalars['String']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  languages?: Maybe<Array<Maybe<Scalars['String']>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  swid?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  vendor?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type SoftwareConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SoftwareExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwarePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SoftwareStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SoftwareStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SoftwareAddInput = {
  cpe?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name?: InputMaybe<Scalars['String']>;
  swid?: InputMaybe<Scalars['String']>;
  vendor?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

export enum State {
  Complete = 'complete',
  Progress = 'progress',
  Timeout = 'timeout',
  Wait = 'wait'
}

export enum StatsOperation {
  Count = 'count',
  Sum = 'sum'
}

export type Status = {
  __typename?: 'Status';
  disabled?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  order: Scalars['Int'];
  template?: Maybe<StatusTemplate>;
  template_id: Scalars['String'];
  type: Scalars['String'];
};

export type StatusAddInput = {
  order: Scalars['Int'];
  template_id: Scalars['String'];
};

export type StatusConnection = {
  __typename?: 'StatusConnection';
  edges?: Maybe<Array<Maybe<StatusEdge>>>;
  pageInfo: PageInfo;
};

export type StatusEdge = {
  __typename?: 'StatusEdge';
  cursor: Scalars['String'];
  node: Status;
};

export enum StatusFilter {
  Type = 'type'
}

export enum StatusOrdering {
  Order = 'order',
  Type = 'type'
}

export type StatusTemplate = {
  __typename?: 'StatusTemplate';
  color: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type StatusTemplateConnection = {
  __typename?: 'StatusTemplateConnection';
  edges?: Maybe<Array<Maybe<StatusTemplateEdge>>>;
  pageInfo: PageInfo;
};

export type StatusTemplateEdge = {
  __typename?: 'StatusTemplateEdge';
  cursor: Scalars['String'];
  node: StatusTemplate;
};

export enum StatusTemplateOrdering {
  Name = 'name'
}

export type StatusesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StatusFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreObject = {
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixCoreObjectConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixCoreObjectExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreObjectStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreObjectConnection = {
  __typename?: 'StixCoreObjectConnection';
  edges?: Maybe<Array<Maybe<StixCoreObjectEdge>>>;
  pageInfo: PageInfo;
};

export type StixCoreObjectEdge = {
  __typename?: 'StixCoreObjectEdge';
  cursor: Scalars['String'];
  node: StixCoreObject;
};

export type StixCoreObjectEditMutations = {
  __typename?: 'StixCoreObjectEditMutations';
  askEnrichment?: Maybe<Work>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  importPush?: Maybe<File>;
  merge?: Maybe<StixCoreObject>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCoreObject>;
  relationsAdd?: Maybe<StixCoreObject>;
};


export type StixCoreObjectEditMutationsAskEnrichmentArgs = {
  connectorId: Scalars['ID'];
};


export type StixCoreObjectEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixCoreObjectEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCoreObjectEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCoreObjectEditMutationsMergeArgs = {
  stixCoreObjectsIds: Array<InputMaybe<Scalars['String']>>;
};


export type StixCoreObjectEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCoreObjectEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};


export type StixCoreObjectEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};

export type StixCoreObjectOrStixCoreRelationship = Artifact | AttackPattern | AutonomousSystem | Campaign | City | Country | CourseOfAction | CryptocurrencyWallet | CryptographicKey | Directory | DomainName | EmailAddr | EmailMessage | EmailMimePartType | Hostname | IPv4Addr | IPv6Addr | Incident | Indicator | Individual | Infrastructure | IntrusionSet | MacAddr | Malware | Mutex | NetworkTraffic | Note | ObservedData | Opinion | Organization | Position | Process | Region | Report | Sector | Software | StixCoreRelationship | StixFile | Text | ThreatActor | Tool | Url | UserAccount | UserAgent | Vulnerability | WindowsRegistryKey | WindowsRegistryValueType | X509Certificate | X509V3ExtensionsType;

export enum StixCoreObjectsFilter {
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  HasExternalReference = 'hasExternalReference',
  Indicates = 'indicates',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContains = 'objectContains'
}

export type StixCoreObjectsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixCoreObjectsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreObjectsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  IndicatorPattern = 'indicator_pattern',
  Modified = 'modified',
  Name = 'name',
  Published = 'published',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidTo = 'valid_to'
}

export type StixCoreRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixCoreRelationship';
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_time?: Maybe<Scalars['DateTime']>;
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stop_time?: Maybe<Scalars['DateTime']>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixCoreRelationshipExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCoreRelationshipStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreRelationshipAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  fromId: Scalars['String'];
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type: Scalars['String'];
  revoked?: InputMaybe<Scalars['Boolean']>;
  start_time?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['String']>;
  stop_time?: InputMaybe<Scalars['DateTime']>;
  toId: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCoreRelationshipConnection = {
  __typename?: 'StixCoreRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixCoreRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixCoreRelationshipEdge = {
  __typename?: 'StixCoreRelationshipEdge';
  cursor: Scalars['String'];
  node: StixCoreRelationship;
};

export type StixCoreRelationshipEditMutations = {
  __typename?: 'StixCoreRelationshipEditMutations';
  contextClean?: Maybe<StixCoreRelationship>;
  contextPatch?: Maybe<StixCoreRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixCoreRelationship>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCoreRelationship>;
};


export type StixCoreRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCoreRelationshipEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCoreRelationshipEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCoreRelationshipEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum StixCoreRelationshipsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FromId = 'fromId',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Revoked = 'revoked',
  StatusId = 'status_id',
  ToCreatedAt = 'toCreatedAt',
  ToId = 'toId',
  ToMainObservableType = 'toMainObservableType',
  ToName = 'toName',
  ToPatternType = 'toPatternType'
}

export type StixCoreRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixCoreRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCoreRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  KillChainPhase = 'killChainPhase',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StatusId = 'status_id',
  StopTime = 'stop_time',
  ToName = 'toName',
  ToObservableValue = 'toObservableValue',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at'
}

export type StixCyberObservable = {
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixCyberObservableConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixCyberObservableExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservablePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixCyberObservableStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCyberObservableConnection = {
  __typename?: 'StixCyberObservableConnection';
  edges?: Maybe<Array<Maybe<StixCyberObservableEdge>>>;
  pageInfo: PageInfo;
};

export type StixCyberObservableEdge = {
  __typename?: 'StixCyberObservableEdge';
  cursor: Scalars['String'];
  node: StixCyberObservable;
};

export type StixCyberObservableEditMutations = {
  __typename?: 'StixCyberObservableEditMutations';
  contextClean?: Maybe<StixCyberObservable>;
  contextPatch?: Maybe<StixCyberObservable>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  fieldPatch?: Maybe<StixCyberObservable>;
  importPush?: Maybe<File>;
  promote?: Maybe<StixCyberObservable>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixCyberObservable>;
  relationsAdd?: Maybe<StixCyberObservable>;
};


export type StixCyberObservableEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCyberObservableEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixCyberObservableEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCyberObservableEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixCyberObservableEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
};


export type StixCyberObservableEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixCyberObservableEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};


export type StixCyberObservableEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};

export type StixCyberObservableRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixCyberObservableRelationship';
  created_at: Scalars['DateTime'];
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  start_time?: Maybe<Scalars['DateTime']>;
  stop_time?: Maybe<Scalars['DateTime']>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StixCyberObservableRelationshipAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  fromId: Scalars['String'];
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  relationship_type: Scalars['String'];
  start_time?: InputMaybe<Scalars['DateTime']>;
  stix_id?: InputMaybe<Scalars['String']>;
  stop_time?: InputMaybe<Scalars['DateTime']>;
  toId: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixCyberObservableRelationshipConnection = {
  __typename?: 'StixCyberObservableRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixCyberObservableRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixCyberObservableRelationshipEdge = {
  __typename?: 'StixCyberObservableRelationshipEdge';
  cursor: Scalars['String'];
  node: StixCyberObservableRelationship;
};

export type StixCyberObservableRelationshipEditMutations = {
  __typename?: 'StixCyberObservableRelationshipEditMutations';
  contextClean?: Maybe<StixCyberObservableRelationship>;
  contextPatch?: Maybe<StixCyberObservableRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixCyberObservableRelationship>;
};


export type StixCyberObservableRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixCyberObservableRelationshipEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum StixCyberObservableRelationshipsFilter {
  CreatedAt = 'created_at'
}

export type StixCyberObservableRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixCyberObservableRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCyberObservableRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  Modified = 'modified',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StopTime = 'stop_time',
  ToCreatedAt = 'toCreatedAt',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at'
}

export enum StixCyberObservablesFilter {
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  HashesMd5 = 'hashes_MD5',
  HashesSha1 = 'hashes_SHA1',
  HashesSha256 = 'hashes_SHA256',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContained = 'objectContained',
  RelatedTo = 'relatedTo',
  SightedBy = 'sightedBy',
  UpdatedAt = 'updated_at',
  Value = 'value',
  XOpenctiOrganizationType = 'x_opencti_organization_type',
  XOpenctiScore = 'x_opencti_score'
}

export type StixCyberObservablesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixCyberObservablesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixCyberObservablesOrdering {
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  ObjectMarking = 'objectMarking',
  ObservableValue = 'observable_value',
  UpdatedAt = 'updated_at'
}

export type StixDomainObject = {
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixDomainObjectConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixDomainObjectExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixDomainObjectStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixDomainObjectAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objects?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  pattern?: InputMaybe<Scalars['String']>;
  pattern_type?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixDomainObjectConnection = {
  __typename?: 'StixDomainObjectConnection';
  edges?: Maybe<Array<Maybe<StixDomainObjectEdge>>>;
  pageInfo: PageInfo;
};

export type StixDomainObjectEdge = {
  __typename?: 'StixDomainObjectEdge';
  cursor: Scalars['String'];
  node: StixDomainObject;
};

export type StixDomainObjectEditMutations = {
  __typename?: 'StixDomainObjectEditMutations';
  changeType?: Maybe<StixDomainObject>;
  contextClean?: Maybe<StixDomainObject>;
  contextPatch?: Maybe<StixDomainObject>;
  delete?: Maybe<Scalars['ID']>;
  exportAsk?: Maybe<Array<Maybe<File>>>;
  exportPush?: Maybe<Scalars['Boolean']>;
  fieldPatch?: Maybe<StixDomainObject>;
  importPush?: Maybe<File>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixDomainObject>;
  relationsAdd?: Maybe<StixDomainObject>;
};


export type StixDomainObjectEditMutationsChangeTypeArgs = {
  newType: Scalars['String'];
};


export type StixDomainObjectEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixDomainObjectEditMutationsExportAskArgs = {
  exportType: Scalars['String'];
  format: Scalars['String'];
  maxMarkingDefinition?: InputMaybe<Scalars['String']>;
};


export type StixDomainObjectEditMutationsExportPushArgs = {
  file: Scalars['Upload'];
};


export type StixDomainObjectEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixDomainObjectEditMutationsImportPushArgs = {
  file: Scalars['Upload'];
};


export type StixDomainObjectEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixDomainObjectEditMutationsRelationDeleteArgs = {
  relationship_type?: InputMaybe<Scalars['String']>;
  toId: Scalars['String'];
};


export type StixDomainObjectEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};

export enum StixDomainObjectsFilter {
  Aliases = 'aliases',
  Confidence = 'confidence',
  ContainedBy = 'containedBy',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  HasExternalReference = 'hasExternalReference',
  Indicates = 'indicates',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  ObjectContains = 'objectContains',
  PatternType = 'pattern_type',
  Published = 'published',
  ReportTypes = 'report_types',
  StatusId = 'status_id',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until',
  XOpenctiAliases = 'x_opencti_aliases',
  XOpenctiMainObservableType = 'x_opencti_main_observable_type',
  XOpenctiOrganizationType = 'x_opencti_organization_type'
}

export type StixDomainObjectsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixDomainObjectsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixDomainObjectsOrdering {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  IndicatorPattern = 'indicator_pattern',
  Modified = 'modified',
  Name = 'name',
  ObjectMarking = 'objectMarking',
  Published = 'published',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  ValidFrom = 'valid_from',
  ValidUntil = 'valid_until'
}

export type StixEditMutations = {
  __typename?: 'StixEditMutations';
  delete?: Maybe<Scalars['ID']>;
};

export type StixFile = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'StixFile';
  atime?: Maybe<Scalars['DateTime']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  ctime?: Maybe<Scalars['DateTime']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  magic_number_hex?: Maybe<Scalars['String']>;
  mime_type?: Maybe<Scalars['String']>;
  mtime?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  name_enc?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  size?: Maybe<Scalars['Int']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_additional_names?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixFileConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type StixFileExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFilePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixFileStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixFileStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixFileAddInput = {
  atime?: InputMaybe<Scalars['DateTime']>;
  ctime?: InputMaybe<Scalars['DateTime']>;
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  magic_number_hex?: InputMaybe<Scalars['String']>;
  mime_type?: InputMaybe<Scalars['String']>;
  mtime?: InputMaybe<Scalars['DateTime']>;
  name?: InputMaybe<Scalars['String']>;
  name_enc?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  x_opencti_additional_names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixMetaObject = {
  created?: Maybe<Scalars['DateTime']>;
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  modified?: Maybe<Scalars['DateTime']>;
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StixMetaRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixMetaRelationship';
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StixMetaRelationshipAddInput = {
  fromId?: InputMaybe<Scalars['ID']>;
  relationship_type: Scalars['String'];
  toId?: InputMaybe<Scalars['ID']>;
};

export type StixMetaRelationshipConnection = {
  __typename?: 'StixMetaRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixMetaRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixMetaRelationshipEdge = {
  __typename?: 'StixMetaRelationshipEdge';
  cursor: Scalars['String'];
  node: StixMetaRelationship;
};

export type StixMetaRelationshipsAddInput = {
  fromIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  relationship_type: Scalars['String'];
  toIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export enum StixMetaRelationshipsFilter {
  CreatedAt = 'created_at'
}

export type StixMetaRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixMetaRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixMetaRelationshipsOrdering {
  CreatedAt = 'created_at',
  UpdatedAt = 'updated_at'
}

export type StixObject = {
  created_at: Scalars['DateTime'];
  entity_type: Scalars['String'];
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  updated_at: Scalars['DateTime'];
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StixObjectOrStixRelationship = Artifact | AttackPattern | AutonomousSystem | Campaign | City | Country | CourseOfAction | CryptocurrencyWallet | CryptographicKey | Directory | DomainName | EmailAddr | EmailMessage | EmailMimePartType | ExternalReference | Hostname | IPv4Addr | IPv6Addr | Incident | Indicator | Individual | Infrastructure | IntrusionSet | KillChainPhase | Label | MacAddr | Malware | MarkingDefinition | Mutex | NetworkTraffic | Note | ObservedData | Opinion | Organization | Position | Process | Region | Report | Sector | Software | StixCoreRelationship | StixCyberObservableRelationship | StixFile | StixMetaRelationship | StixSightingRelationship | System | Text | ThreatActor | Tool | Url | UserAccount | UserAgent | Vulnerability | WindowsRegistryKey | WindowsRegistryValueType | X509Certificate | X509V3ExtensionsType;

export type StixObjectOrStixRelationshipConnection = {
  __typename?: 'StixObjectOrStixRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixObjectOrStixRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixObjectOrStixRelationshipEdge = {
  __typename?: 'StixObjectOrStixRelationshipEdge';
  cursor: Scalars['String'];
  node: StixObjectOrStixRelationship;
};

export enum StixObjectOrStixRelationshipsFilter {
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  UpdatedAt = 'updated_at'
}

export type StixObjectOrStixRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixObjectOrStixRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum StixObjectOrStixRelationshipsOrdering {
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  Name = 'name',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  ObservableValue = 'observable_value',
  UpdatedAt = 'updated_at'
}

export type StixRelationship = {
  entity_type: Scalars['String'];
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  parent_types: Array<Maybe<Scalars['String']>>;
  standard_id: Scalars['String'];
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StixRelationshipConnection = {
  __typename?: 'StixRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixRelationshipEdge>>>;
  pageInfo: PageInfo;
};

export type StixRelationshipEdge = {
  __typename?: 'StixRelationshipEdge';
  cursor: Scalars['String'];
  node: StixRelationship;
};

export type StixRelationshipEditMutations = {
  __typename?: 'StixRelationshipEditMutations';
  delete?: Maybe<Scalars['ID']>;
};

export enum StixRelationshipsFilter {
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  ToCreatedAt = 'toCreatedAt',
  ToMainObservableType = 'toMainObservableType',
  ToName = 'toName',
  ToPatternType = 'toPatternType'
}

export type StixRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixRelationshipsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  KillChainPhase = 'killChainPhase',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  RelationshipType = 'relationship_type',
  StartTime = 'start_time',
  StopTime = 'stop_time',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at'
}

export type StixSightingRelationship = BasicRelationship & StixRelationship & {
  __typename?: 'StixSightingRelationship';
  attribute_count: Scalars['Int'];
  confidence?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  from?: Maybe<StixObjectOrStixRelationship>;
  fromRole?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  is_inferred: Scalars['Boolean'];
  last_seen?: Maybe<Scalars['DateTime']>;
  modified?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  relationship_type: Scalars['String'];
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  to?: Maybe<StixObjectOrStixRelationship>;
  toRole?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_negative: Scalars['Boolean'];
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type StixSightingRelationshipExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type StixSightingRelationshipReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type StixSightingRelationshipAddInput = {
  attribute_count: Scalars['Int'];
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  fromId: Scalars['String'];
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  toId?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_negative?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StixSightingRelationshipConnection = {
  __typename?: 'StixSightingRelationshipConnection';
  edges?: Maybe<Array<Maybe<StixSightingRelationshipsEdge>>>;
  pageInfo: PageInfo;
};

export type StixSightingRelationshipEditMutations = {
  __typename?: 'StixSightingRelationshipEditMutations';
  contextClean?: Maybe<StixSightingRelationship>;
  contextPatch?: Maybe<StixSightingRelationship>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<StixSightingRelationship>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<StixSightingRelationship>;
};


export type StixSightingRelationshipEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type StixSightingRelationshipEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type StixSightingRelationshipEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type StixSightingRelationshipEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type StixSightingRelationshipsEdge = {
  __typename?: 'StixSightingRelationshipsEdge';
  cursor: Scalars['String'];
  node: StixSightingRelationship;
};

export enum StixSightingRelationshipsFilter {
  AttributeCount = 'attribute_count',
  Confidence = 'confidence',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  FromId = 'fromId',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  StatusId = 'status_id',
  ToId = 'toId',
  ToMainObservableType = 'toMainObservableType',
  ToPatternType = 'toPatternType',
  XOpenctiNegative = 'x_opencti_negative'
}

export type StixSightingRelationshipsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: StixSightingRelationshipsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StixSightingRelationshipsOrdering {
  AttributeCount = 'attribute_count',
  Confidence = 'confidence',
  Created = 'created',
  CreatedAt = 'created_at',
  FirstSeen = 'first_seen',
  LastSeen = 'last_seen',
  Modified = 'modified',
  ObjectLabel = 'objectLabel',
  ObjectMarking = 'objectMarking',
  StatusId = 'status_id',
  ToCreatedAt = 'toCreatedAt',
  ToName = 'toName',
  ToPatternType = 'toPatternType',
  ToValidFrom = 'toValidFrom',
  ToValidUntil = 'toValidUntil',
  UpdatedAt = 'updated_at',
  XOpenctiNegative = 'x_opencti_negative'
}

export type StreamCollection = {
  __typename?: 'StreamCollection';
  description?: Maybe<Scalars['String']>;
  filters?: Maybe<Scalars['String']>;
  groups?: Maybe<Array<Maybe<Group>>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type StreamCollectionAddInput = {
  description?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<Scalars['String']>;
  groups?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  name: Scalars['String'];
};

export type StreamCollectionConnection = {
  __typename?: 'StreamCollectionConnection';
  edges?: Maybe<Array<Maybe<StreamCollectionEdge>>>;
  pageInfo: PageInfo;
};

export type StreamCollectionEdge = {
  __typename?: 'StreamCollectionEdge';
  cursor: Scalars['String'];
  node: StreamCollection;
};

export type StreamCollectionEditMutations = {
  __typename?: 'StreamCollectionEditMutations';
  addGroup?: Maybe<StreamCollection>;
  delete?: Maybe<Scalars['ID']>;
  deleteGroup?: Maybe<StreamCollection>;
  fieldPatch?: Maybe<StreamCollection>;
};


export type StreamCollectionEditMutationsAddGroupArgs = {
  id: Scalars['ID'];
};


export type StreamCollectionEditMutationsDeleteGroupArgs = {
  id: Scalars['ID'];
};


export type StreamCollectionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum StreamCollectionOrdering {
  Description = 'description',
  Name = 'name'
}

export type SubType = {
  __typename?: 'SubType';
  id: Scalars['ID'];
  label: Scalars['String'];
  statuses?: Maybe<StatusConnection>;
  workflowEnabled?: Maybe<Scalars['Boolean']>;
};

export type SubTypeConnection = {
  __typename?: 'SubTypeConnection';
  edges?: Maybe<Array<Maybe<SubTypeEdge>>>;
  pageInfo: PageInfo;
};

export type SubTypeEdge = {
  __typename?: 'SubTypeEdge';
  cursor: Scalars['String'];
  node: SubType;
};

export type SubTypeEditMutations = {
  __typename?: 'SubTypeEditMutations';
  statusAdd?: Maybe<SubType>;
  statusDelete?: Maybe<SubType>;
  statusFieldPatch?: Maybe<SubType>;
};


export type SubTypeEditMutationsStatusAddArgs = {
  input?: InputMaybe<StatusAddInput>;
};


export type SubTypeEditMutationsStatusDeleteArgs = {
  statusId: Scalars['String'];
};


export type SubTypeEditMutationsStatusFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
  statusId: Scalars['String'];
};

export enum SubTypesOrdering {
  Label = 'label'
}

export type Subscription = {
  __typename?: 'Subscription';
  externalReference?: Maybe<ExternalReference>;
  group?: Maybe<Group>;
  killChainPhase?: Maybe<KillChainPhase>;
  label?: Maybe<Label>;
  markingDefinition?: Maybe<MarkingDefinition>;
  settings?: Maybe<Settings>;
  stixCoreObject?: Maybe<StixCoreObject>;
  stixCoreRelationship?: Maybe<StixCoreRelationship>;
  stixCyberObservable?: Maybe<StixCyberObservable>;
  stixCyberObservableRelationship?: Maybe<StixCyberObservableRelationship>;
  stixDomainObject?: Maybe<StixDomainObject>;
  stixSightingRelationship?: Maybe<StixSightingRelationship>;
  user?: Maybe<User>;
  workspace?: Maybe<Workspace>;
};


export type SubscriptionExternalReferenceArgs = {
  id: Scalars['ID'];
};


export type SubscriptionGroupArgs = {
  id: Scalars['ID'];
};


export type SubscriptionKillChainPhaseArgs = {
  id: Scalars['ID'];
};


export type SubscriptionLabelArgs = {
  id: Scalars['ID'];
};


export type SubscriptionMarkingDefinitionArgs = {
  id: Scalars['ID'];
};


export type SubscriptionSettingsArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCoreObjectArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCoreRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCyberObservableArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixCyberObservableRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixDomainObjectArgs = {
  id: Scalars['ID'];
};


export type SubscriptionStixSightingRelationshipArgs = {
  id: Scalars['ID'];
};


export type SubscriptionUserArgs = {
  id: Scalars['ID'];
};


export type SubscriptionWorkspaceArgs = {
  id: Scalars['ID'];
};

export type Synchronizer = {
  __typename?: 'Synchronizer';
  current_state?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  listen_deletion: Scalars['Boolean'];
  name: Scalars['String'];
  running: Scalars['Boolean'];
  ssl_verify?: Maybe<Scalars['Boolean']>;
  stream_id: Scalars['String'];
  token: Scalars['String'];
  uri: Scalars['String'];
  user?: Maybe<User>;
};

export type SynchronizerAddInput = {
  current_state?: InputMaybe<Scalars['String']>;
  listen_deletion: Scalars['Boolean'];
  name: Scalars['String'];
  ssl_verify?: InputMaybe<Scalars['Boolean']>;
  stream_id: Scalars['String'];
  token: Scalars['String'];
  uri: Scalars['String'];
  user_id?: InputMaybe<Scalars['String']>;
};

export type SynchronizerConnection = {
  __typename?: 'SynchronizerConnection';
  edges?: Maybe<Array<Maybe<SynchronizerEdge>>>;
  pageInfo: PageInfo;
};

export type SynchronizerEdge = {
  __typename?: 'SynchronizerEdge';
  cursor: Scalars['String'];
  node: Synchronizer;
};

export type SynchronizerEditMutations = {
  __typename?: 'SynchronizerEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Synchronizer>;
};


export type SynchronizerEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum SynchronizersOrdering {
  CurrentState = 'current_state',
  Id = 'id',
  Name = 'name',
  Running = 'running',
  StreamId = 'stream_id',
  Uri = 'uri'
}

export type System = BasicObject & Identity & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'System';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  contact_information?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  identity_class: Scalars['String'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  organizations?: Maybe<OrganizationConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  x_opencti_firstname?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_lastname?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type SystemConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type SystemExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type SystemStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SystemAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  contact_information?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  x_opencti_firstname?: InputMaybe<Scalars['String']>;
  x_opencti_lastname?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type SystemConnection = {
  __typename?: 'SystemConnection';
  edges?: Maybe<Array<Maybe<SystemEdge>>>;
  pageInfo: PageInfo;
};

export type SystemEdge = {
  __typename?: 'SystemEdge';
  cursor: Scalars['String'];
  node: System;
};

export type SystemEditMutations = {
  __typename?: 'SystemEditMutations';
  contextClean?: Maybe<System>;
  contextPatch?: Maybe<System>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<System>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<System>;
};


export type SystemEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type SystemEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type SystemEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type SystemEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum SystemsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  Revoked = 'revoked',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type SystemsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: SystemsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum SystemsOrdering {
  Confidence = 'confidence',
  Created = 'created',
  Firstname = 'firstname',
  Lastname = 'lastname',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id'
}

export type Task = {
  actions?: Maybe<Array<Maybe<TaskAction>>>;
  completed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['DateTime']>;
  errors?: Maybe<Array<Maybe<TaskError>>>;
  id: Scalars['ID'];
  initiator?: Maybe<User>;
  last_execution_date?: Maybe<Scalars['DateTime']>;
  task_expected_number?: Maybe<Scalars['Int']>;
  task_processed_number?: Maybe<Scalars['Int']>;
  type?: Maybe<TaskType>;
};

export type TaskAction = {
  __typename?: 'TaskAction';
  context?: Maybe<TaskContext>;
  type?: Maybe<TaskActionType>;
};

export type TaskActionInput = {
  context?: InputMaybe<TaskContextInput>;
  type: TaskActionType;
};

export enum TaskActionType {
  Add = 'ADD',
  Delete = 'DELETE',
  Merge = 'MERGE',
  Remove = 'REMOVE',
  Replace = 'REPLACE',
  Rescan = 'RESCAN'
}

export type TaskConnection = {
  __typename?: 'TaskConnection';
  edges?: Maybe<Array<Maybe<TaskConnectionEdge>>>;
  pageInfo: PageInfo;
};

export type TaskConnectionEdge = {
  __typename?: 'TaskConnectionEdge';
  cursor: Scalars['String'];
  node: Task;
};

export type TaskContext = {
  __typename?: 'TaskContext';
  field?: Maybe<Scalars['String']>;
  type?: Maybe<TaskContextType>;
  values: Array<Maybe<Scalars['String']>>;
};

export type TaskContextInput = {
  field?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<TaskContextType>;
  values: Array<InputMaybe<Scalars['String']>>;
};

export enum TaskContextType {
  Attribute = 'ATTRIBUTE',
  Relation = 'RELATION',
  ReversedRelation = 'REVERSED_RELATION'
}

export type TaskError = {
  __typename?: 'TaskError';
  id: Scalars['ID'];
  message?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export enum TaskType {
  List = 'LIST',
  Query = 'QUERY',
  Rule = 'RULE'
}

export enum TasksFilter {
  Completed = 'completed',
  Initiator = 'initiator',
  Type = 'type'
}

export type TasksFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: TasksFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum TasksOrdering {
  Completed = 'completed',
  CreatedAt = 'created_at',
  Id = 'id',
  LastExecutionDate = 'last_execution_date',
  Type = 'type'
}

export type TaxiiCollection = {
  __typename?: 'TaxiiCollection';
  description?: Maybe<Scalars['String']>;
  filters?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type TaxiiCollectionAddInput = {
  description?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type TaxiiCollectionConnection = {
  __typename?: 'TaxiiCollectionConnection';
  edges?: Maybe<Array<Maybe<TaxiiCollectionEdge>>>;
  pageInfo: PageInfo;
};

export type TaxiiCollectionEdge = {
  __typename?: 'TaxiiCollectionEdge';
  cursor: Scalars['String'];
  node: TaxiiCollection;
};

export type TaxiiCollectionEditMutations = {
  __typename?: 'TaxiiCollectionEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<TaxiiCollection>;
};


export type TaxiiCollectionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum TaxiiCollectionOrdering {
  Description = 'description',
  Name = 'name'
}

export type Text = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Text';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type TextConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type TextExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type TextStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type TextStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type TextAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type ThreatActor = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'ThreatActor';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  first_seen?: Maybe<Scalars['DateTime']>;
  goals?: Maybe<Array<Maybe<Scalars['String']>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  last_seen?: Maybe<Scalars['DateTime']>;
  locations?: Maybe<LocationConnection>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  personal_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  primary_motivation?: Maybe<Scalars['String']>;
  reports?: Maybe<ReportConnection>;
  resource_level?: Maybe<Scalars['String']>;
  revoked: Scalars['Boolean'];
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
  secondary_motivations?: Maybe<Array<Maybe<Scalars['String']>>>;
  sophistication?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  threat_actor_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ThreatActorConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ThreatActorExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ThreatActorStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ThreatActorAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  first_seen?: InputMaybe<Scalars['DateTime']>;
  goals?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  last_seen?: InputMaybe<Scalars['DateTime']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  personal_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  primary_motivation?: InputMaybe<Scalars['String']>;
  resource_level?: InputMaybe<Scalars['String']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  secondary_motivations?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  sophistication?: InputMaybe<Scalars['String']>;
  stix_id?: InputMaybe<Scalars['String']>;
  threat_actor_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ThreatActorConnection = {
  __typename?: 'ThreatActorConnection';
  edges?: Maybe<Array<Maybe<ThreatActorEdge>>>;
  pageInfo: PageInfo;
};

export type ThreatActorEdge = {
  __typename?: 'ThreatActorEdge';
  cursor: Scalars['String'];
  node: ThreatActor;
};

export type ThreatActorEditMutations = {
  __typename?: 'ThreatActorEditMutations';
  contextClean?: Maybe<ThreatActor>;
  contextPatch?: Maybe<ThreatActor>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<ThreatActor>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<ThreatActor>;
};


export type ThreatActorEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ThreatActorEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ThreatActorEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ThreatActorEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum ThreatActorsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type ThreatActorsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ThreatActorsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ThreatActorsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type TimeSeries = {
  __typename?: 'TimeSeries';
  date: Scalars['DateTime'];
  value: Scalars['Int'];
};

export type Tool = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Tool';
  aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  killChainPhases?: Maybe<KillChainPhaseConnection>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  tool_types?: Maybe<Array<Maybe<Scalars['String']>>>;
  tool_version?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type ToolConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type ToolExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type ToolStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ToolAddInput = {
  aliases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  killChainPhases?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  tool_types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  tool_version?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ToolConnection = {
  __typename?: 'ToolConnection';
  edges?: Maybe<Array<Maybe<ToolEdge>>>;
  pageInfo: PageInfo;
};

export type ToolEdge = {
  __typename?: 'ToolEdge';
  cursor: Scalars['String'];
  node: Tool;
};

export type ToolEditMutations = {
  __typename?: 'ToolEditMutations';
  contextClean?: Maybe<Tool>;
  contextPatch?: Maybe<Tool>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Tool>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Tool>;
};


export type ToolEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type ToolEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type ToolEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type ToolEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export enum ToolsFilter {
  Aliases = 'aliases',
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id'
}

export type ToolsFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: ToolsFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum ToolsOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at'
}

export type Url = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'Url';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type UrlConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UrlExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UrlStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UrlStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UrlAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type User = BasicObject & InternalObject & {
  __typename?: 'User';
  allowed_marking?: Maybe<Array<Maybe<MarkingDefinition>>>;
  api_token: Scalars['String'];
  capabilities: Array<Maybe<Capability>>;
  created_at: Scalars['DateTime'];
  dashboard?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  external?: Maybe<Scalars['Boolean']>;
  firstname?: Maybe<Scalars['String']>;
  groups?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  language?: Maybe<Scalars['String']>;
  lastname?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  parent_types: Array<Maybe<Scalars['String']>>;
  roles: Array<Maybe<Role>>;
  sessions?: Maybe<Array<Maybe<SessionDetail>>>;
  standard_id: Scalars['String'];
  theme?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  userSubscriptions?: Maybe<UserSubscriptionConnection>;
  user_email: Scalars['String'];
};


export type UserUserSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type UserAccount = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'UserAccount';
  account_created?: Maybe<Scalars['DateTime']>;
  account_expires?: Maybe<Scalars['DateTime']>;
  account_first_login?: Maybe<Scalars['DateTime']>;
  account_last_login?: Maybe<Scalars['DateTime']>;
  account_login?: Maybe<Scalars['String']>;
  account_type?: Maybe<Scalars['String']>;
  can_escalate_privs?: Maybe<Scalars['Boolean']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  credential?: Maybe<Scalars['String']>;
  credential_last_changed?: Maybe<Scalars['DateTime']>;
  display_name?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extensions?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_disabled?: Maybe<Scalars['Boolean']>;
  is_inferred: Scalars['Boolean'];
  is_privileged?: Maybe<Scalars['Boolean']>;
  is_service_account?: Maybe<Scalars['Boolean']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  user_id?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type UserAccountConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UserAccountExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAccountStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAccountStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserAccountAddInput = {
  account_created?: InputMaybe<Scalars['DateTime']>;
  account_expires?: InputMaybe<Scalars['DateTime']>;
  account_first_login?: InputMaybe<Scalars['DateTime']>;
  account_last_login?: InputMaybe<Scalars['DateTime']>;
  account_login?: InputMaybe<Scalars['String']>;
  account_type?: InputMaybe<Scalars['String']>;
  can_escalate_privs?: InputMaybe<Scalars['Boolean']>;
  credential?: InputMaybe<Scalars['String']>;
  credential_last_changed?: InputMaybe<Scalars['DateTime']>;
  display_name?: InputMaybe<Scalars['String']>;
  is_disabled?: InputMaybe<Scalars['Boolean']>;
  is_privileged?: InputMaybe<Scalars['Boolean']>;
  is_service_account?: InputMaybe<Scalars['Boolean']>;
  user_id?: InputMaybe<Scalars['String']>;
};

export type UserAddInput = {
  description?: InputMaybe<Scalars['String']>;
  firstname?: InputMaybe<Scalars['String']>;
  language?: InputMaybe<Scalars['String']>;
  lastname?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  theme?: InputMaybe<Scalars['String']>;
  user_email?: InputMaybe<Scalars['String']>;
};

export type UserAgent = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'UserAgent';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  value?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type UserAgentConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type UserAgentExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type UserAgentStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type UserAgentStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserAgentAddInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['String'];
  node: User;
};

export type UserEditMutations = {
  __typename?: 'UserEditMutations';
  contextClean?: Maybe<User>;
  contextPatch?: Maybe<User>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<User>;
  relationAdd?: Maybe<InternalRelationship>;
  relationDelete?: Maybe<User>;
  tokenRenew?: Maybe<User>;
};


export type UserEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type UserEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type UserEditMutationsRelationAddArgs = {
  input?: InputMaybe<InternalRelationshipAddInput>;
};


export type UserEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type UserLoginInput = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type UserSession = {
  __typename?: 'UserSession';
  sessions?: Maybe<Array<Maybe<SessionDetail>>>;
  user?: Maybe<User>;
};

export type UserSubscription = {
  __typename?: 'UserSubscription';
  cron?: Maybe<Scalars['String']>;
  entities?: Maybe<Array<Maybe<StixDomainObject>>>;
  entities_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
  filters?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  last_run: Scalars['DateTime'];
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Array<Maybe<Scalars['String']>>>;
  user?: Maybe<User>;
  user_id?: Maybe<Scalars['String']>;
};

export type UserSubscriptionAddInput = {
  cron?: InputMaybe<Scalars['String']>;
  entities_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  filters?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  options?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type UserSubscriptionConnection = {
  __typename?: 'UserSubscriptionConnection';
  edges?: Maybe<Array<Maybe<UserSubscriptionEdge>>>;
  pageInfo: PageInfo;
};

export type UserSubscriptionEdge = {
  __typename?: 'UserSubscriptionEdge';
  cursor: Scalars['String'];
  node: UserSubscription;
};

export type UserSubscriptionEditMutations = {
  __typename?: 'UserSubscriptionEditMutations';
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<UserSubscription>;
};


export type UserSubscriptionEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};

export enum UserSubscriptionOrdering {
  CreatedAt = 'created_at'
}

export enum UsersFilter {
  CreatedAt = 'created_at',
  EntityType = 'entity_type',
  Name = 'name'
}

export type UsersFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: UsersFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum UsersOrdering {
  CreatedAt = 'created_at',
  External = 'external',
  Firstname = 'firstname',
  Language = 'language',
  Lastname = 'lastname',
  Name = 'name',
  UpdatedAt = 'updated_at',
  UserEmail = 'user_email'
}

export enum VulnerabilitiesFilter {
  Created = 'created',
  CreatedBy = 'createdBy',
  CreatedAt = 'created_at',
  LabelledBy = 'labelledBy',
  MarkedBy = 'markedBy',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  XOpenctiAttackVector = 'x_opencti_attack_vector',
  XOpenctiBaseScore = 'x_opencti_base_score',
  XOpenctiBaseSeverity = 'x_opencti_base_severity'
}

export type VulnerabilitiesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: VulnerabilitiesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum VulnerabilitiesOrdering {
  Created = 'created',
  CreatedAt = 'created_at',
  Modified = 'modified',
  Name = 'name',
  StatusId = 'status_id',
  UpdatedAt = 'updated_at',
  XOpenctiAttackVector = 'x_opencti_attack_vector',
  XOpenctiBaseScore = 'x_opencti_base_score',
  XOpenctiBaseSeverity = 'x_opencti_base_severity'
}

export type Vulnerability = BasicObject & StixCoreObject & StixDomainObject & StixObject & {
  __typename?: 'Vulnerability';
  confidence?: Maybe<Scalars['Int']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  created?: Maybe<Scalars['DateTime']>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  lang?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  revoked: Scalars['Boolean'];
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  status?: Maybe<Status>;
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  workflowEnabled?: Maybe<Scalars['Boolean']>;
  x_opencti_attack_vector?: Maybe<Scalars['String']>;
  x_opencti_availability_impact?: Maybe<Scalars['String']>;
  x_opencti_base_score?: Maybe<Scalars['Float']>;
  x_opencti_base_severity?: Maybe<Scalars['String']>;
  x_opencti_confidentiality_impact?: Maybe<Scalars['String']>;
  x_opencti_graph_data?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_integrity_impact?: Maybe<Scalars['String']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type VulnerabilityConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type VulnerabilityExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type VulnerabilityStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type VulnerabilityAddInput = {
  clientMutationId?: InputMaybe<Scalars['String']>;
  confidence?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['DateTime']>;
  createdBy?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  externalReferences?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lang?: InputMaybe<Scalars['String']>;
  modified?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  objectLabel?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  objectMarking?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  revoked?: InputMaybe<Scalars['Boolean']>;
  stix_id?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['Boolean']>;
  x_opencti_attack_vector?: InputMaybe<Scalars['String']>;
  x_opencti_availability_impact?: InputMaybe<Scalars['String']>;
  x_opencti_base_score?: InputMaybe<Scalars['Float']>;
  x_opencti_base_severity?: InputMaybe<Scalars['String']>;
  x_opencti_confidentiality_impact?: InputMaybe<Scalars['String']>;
  x_opencti_integrity_impact?: InputMaybe<Scalars['String']>;
  x_opencti_stix_ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type VulnerabilityConnection = {
  __typename?: 'VulnerabilityConnection';
  edges?: Maybe<Array<Maybe<VulnerabilityEdge>>>;
  pageInfo: PageInfo;
};

export type VulnerabilityEdge = {
  __typename?: 'VulnerabilityEdge';
  cursor: Scalars['String'];
  node: Vulnerability;
};

export type VulnerabilityEditMutations = {
  __typename?: 'VulnerabilityEditMutations';
  contextClean?: Maybe<Vulnerability>;
  contextPatch?: Maybe<Vulnerability>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Vulnerability>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Vulnerability>;
};


export type VulnerabilityEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type VulnerabilityEditMutationsFieldPatchArgs = {
  commitMessage?: InputMaybe<Scalars['String']>;
  input: Array<InputMaybe<EditInput>>;
  references?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type VulnerabilityEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type VulnerabilityEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};

export type WindowsRegistryKey = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'WindowsRegistryKey';
  attribute_key?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  modified_time?: Maybe<Scalars['DateTime']>;
  notes?: Maybe<NoteConnection>;
  number_of_subkeys?: Maybe<Scalars['Int']>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type WindowsRegistryKeyConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type WindowsRegistryKeyExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyPendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryKeyStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryKeyStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WindowsRegistryKeyAddInput = {
  attribute_key?: InputMaybe<Scalars['String']>;
  modified_time?: InputMaybe<Scalars['DateTime']>;
  number_of_subkeys?: InputMaybe<Scalars['Int']>;
};

export type WindowsRegistryValueType = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'WindowsRegistryValueType';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  data?: Maybe<Scalars['String']>;
  data_type?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  jobs?: Maybe<Array<Maybe<Work>>>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type WindowsRegistryValueTypeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type WindowsRegistryValueTypeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type WindowsRegistryValueTypeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type WindowsRegistryValueTypeStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WindowsRegistryValueTypeAddInput = {
  data?: InputMaybe<Scalars['String']>;
  data_type?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type Work = {
  __typename?: 'Work';
  completed_number?: Maybe<Scalars['Int']>;
  completed_time?: Maybe<Scalars['DateTime']>;
  connector?: Maybe<Connector>;
  errors?: Maybe<Array<Maybe<WorkMessage>>>;
  event_source_id?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  messages?: Maybe<Array<Maybe<WorkMessage>>>;
  name?: Maybe<Scalars['String']>;
  processed_time?: Maybe<Scalars['DateTime']>;
  received_time?: Maybe<Scalars['DateTime']>;
  status: State;
  timestamp: Scalars['DateTime'];
  tracking?: Maybe<WorkTracking>;
  user?: Maybe<User>;
};

export type WorkConnection = {
  __typename?: 'WorkConnection';
  edges?: Maybe<Array<Maybe<WorkEdge>>>;
  pageInfo: PageInfo;
};

export type WorkEdge = {
  __typename?: 'WorkEdge';
  cursor: Scalars['String'];
  node: Work;
};

export type WorkEditMutations = {
  __typename?: 'WorkEditMutations';
  addExpectations: Scalars['ID'];
  delete: Scalars['ID'];
  ping: Scalars['ID'];
  reportExpectation: Scalars['ID'];
  toProcessed: Scalars['ID'];
  toReceived: Scalars['ID'];
};


export type WorkEditMutationsAddExpectationsArgs = {
  expectations?: InputMaybe<Scalars['Int']>;
};


export type WorkEditMutationsReportExpectationArgs = {
  error?: InputMaybe<WorkErrorInput>;
};


export type WorkEditMutationsToProcessedArgs = {
  inError?: InputMaybe<Scalars['Boolean']>;
  message?: InputMaybe<Scalars['String']>;
};


export type WorkEditMutationsToReceivedArgs = {
  message?: InputMaybe<Scalars['String']>;
};

export type WorkErrorInput = {
  error?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

export type WorkMessage = {
  __typename?: 'WorkMessage';
  message?: Maybe<Scalars['String']>;
  sequence?: Maybe<Scalars['Int']>;
  source?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

export type WorkTracking = {
  __typename?: 'WorkTracking';
  import_expected_number?: Maybe<Scalars['Int']>;
  import_last_processed?: Maybe<Scalars['DateTime']>;
  import_processed_number?: Maybe<Scalars['Int']>;
};

export enum WorksFilter {
  CompletedNumber = 'completed_number',
  CompletedTime = 'completed_time',
  ConnectorId = 'connector_id',
  Status = 'status'
}

export type WorksFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: WorksFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum WorksOrdering {
  Status = 'status',
  Timestamp = 'timestamp'
}

export type Workspace = {
  __typename?: 'Workspace';
  created_at?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  graph_data?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  manifest?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  objects?: Maybe<StixObjectOrStixRelationshipConnection>;
  owner?: Maybe<User>;
  tags?: Maybe<Array<Maybe<Scalars['String']>>>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['DateTime']>;
};


export type WorkspaceObjectsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  all?: InputMaybe<Scalars['Boolean']>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixObjectOrStixRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StixObjectOrStixRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type WorkspaceAddInput = {
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  type: Scalars['String'];
};

export type WorkspaceConnection = {
  __typename?: 'WorkspaceConnection';
  edges?: Maybe<Array<Maybe<WorkspaceEdge>>>;
  pageInfo: PageInfo;
};

export type WorkspaceEdge = {
  __typename?: 'WorkspaceEdge';
  cursor: Scalars['String'];
  node: Workspace;
};

export type WorkspaceEditMutations = {
  __typename?: 'WorkspaceEditMutations';
  contextClean?: Maybe<Workspace>;
  contextPatch?: Maybe<Workspace>;
  delete?: Maybe<Scalars['ID']>;
  fieldPatch?: Maybe<Workspace>;
  relationAdd?: Maybe<StixMetaRelationship>;
  relationDelete?: Maybe<Workspace>;
  relationsAdd?: Maybe<Workspace>;
  relationsDelete?: Maybe<Workspace>;
};


export type WorkspaceEditMutationsContextPatchArgs = {
  input?: InputMaybe<EditContext>;
};


export type WorkspaceEditMutationsFieldPatchArgs = {
  input: Array<InputMaybe<EditInput>>;
};


export type WorkspaceEditMutationsRelationAddArgs = {
  input?: InputMaybe<StixMetaRelationshipAddInput>;
};


export type WorkspaceEditMutationsRelationDeleteArgs = {
  relationship_type: Scalars['String'];
  toId: Scalars['String'];
};


export type WorkspaceEditMutationsRelationsAddArgs = {
  input?: InputMaybe<StixMetaRelationshipsAddInput>;
};


export type WorkspaceEditMutationsRelationsDeleteArgs = {
  relationship_type: Scalars['String'];
  toIds: Array<InputMaybe<Scalars['String']>>;
};

export enum WorkspacesFilter {
  Name = 'name',
  Owner = 'owner',
  Tag = 'tag',
  Type = 'type'
}

export type WorkspacesFiltering = {
  filterMode?: InputMaybe<FilterMode>;
  key: WorkspacesFilter;
  operator?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum WorkspacesOrdering {
  CreatedAt = 'created_at',
  Name = 'name',
  OwnedBy = 'ownedBy'
}

export type X509Certificate = BasicObject & HashedObservable & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'X509Certificate';
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  hashes?: Maybe<Array<Maybe<Hash>>>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  is_inferred: Scalars['Boolean'];
  is_self_signed?: Maybe<Scalars['Boolean']>;
  issuer?: Maybe<Scalars['String']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  reports?: Maybe<ReportConnection>;
  serial_number?: Maybe<Scalars['String']>;
  signature_algorithm?: Maybe<Scalars['String']>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  subject?: Maybe<Scalars['String']>;
  subject_public_key_algorithm?: Maybe<Scalars['String']>;
  subject_public_key_exponent?: Maybe<Scalars['Int']>;
  subject_public_key_modulus?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  validity_not_after?: Maybe<Scalars['DateTime']>;
  validity_not_before?: Maybe<Scalars['DateTime']>;
  version?: Maybe<Scalars['String']>;
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type X509CertificateConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type X509CertificateExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificatePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509CertificateStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type X509CertificateStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type X509CertificateAddInput = {
  hashes?: InputMaybe<Array<InputMaybe<HashInput>>>;
  is_self_signed?: InputMaybe<Scalars['Boolean']>;
  issuer?: InputMaybe<Scalars['String']>;
  serial_number?: InputMaybe<Scalars['String']>;
  signature_algorithm?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  subject_public_key_algorithm?: InputMaybe<Scalars['String']>;
  subject_public_key_exponent?: InputMaybe<Scalars['Int']>;
  subject_public_key_modulus?: InputMaybe<Scalars['String']>;
  validity_not_after?: InputMaybe<Scalars['DateTime']>;
  validity_not_before?: InputMaybe<Scalars['DateTime']>;
  version?: InputMaybe<Scalars['String']>;
};

export type X509V3ExtensionsType = BasicObject & StixCoreObject & StixCyberObservable & StixObject & {
  __typename?: 'X509V3ExtensionsType';
  authority_key_identifier?: Maybe<Scalars['String']>;
  basic_constraints?: Maybe<Scalars['String']>;
  certificate_policies?: Maybe<Scalars['String']>;
  connectors?: Maybe<Array<Maybe<Connector>>>;
  createdBy?: Maybe<Identity>;
  created_at: Scalars['DateTime'];
  creator?: Maybe<User>;
  crl_distribution_points?: Maybe<Scalars['String']>;
  editContext?: Maybe<Array<Maybe<EditUserContext>>>;
  entity_type: Scalars['String'];
  exportFiles?: Maybe<FileConnection>;
  extended_key_usage?: Maybe<Scalars['String']>;
  externalReferences?: Maybe<ExternalReferenceConnection>;
  id: Scalars['ID'];
  importFiles?: Maybe<FileConnection>;
  indicators?: Maybe<IndicatorConnection>;
  inhibit_any_policy?: Maybe<Scalars['String']>;
  is_inferred: Scalars['Boolean'];
  issuer_alternative_name?: Maybe<Scalars['String']>;
  jobs?: Maybe<Array<Maybe<Work>>>;
  key_usage?: Maybe<Scalars['String']>;
  name_constraints?: Maybe<Scalars['String']>;
  notes?: Maybe<NoteConnection>;
  objectLabel?: Maybe<LabelConnection>;
  objectMarking?: Maybe<MarkingDefinitionConnection>;
  observable_value: Scalars['String'];
  opinions?: Maybe<OpinionConnection>;
  parent_types: Array<Maybe<Scalars['String']>>;
  pendingFiles?: Maybe<FileConnection>;
  policy_constraints?: Maybe<Scalars['String']>;
  policy_mappings?: Maybe<Scalars['String']>;
  private_key_usage_period_not_after?: Maybe<Scalars['DateTime']>;
  private_key_usage_period_not_before?: Maybe<Scalars['DateTime']>;
  reports?: Maybe<ReportConnection>;
  spec_version: Scalars['String'];
  standard_id: Scalars['String'];
  stixCoreRelationships?: Maybe<StixCoreRelationshipConnection>;
  stixCyberObservableRelationships?: Maybe<StixCyberObservableRelationshipConnection>;
  subject_alternative_name?: Maybe<Scalars['String']>;
  subject_directory_attributes?: Maybe<Scalars['String']>;
  subject_key_identifier?: Maybe<Scalars['String']>;
  toStix?: Maybe<Scalars['String']>;
  updated_at: Scalars['DateTime'];
  x_opencti_description?: Maybe<Scalars['String']>;
  x_opencti_inferences?: Maybe<Array<Maybe<Inference>>>;
  x_opencti_score?: Maybe<Scalars['Int']>;
  x_opencti_stix_ids?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type X509V3ExtensionsTypeConnectorsArgs = {
  onlyAlive?: InputMaybe<Scalars['Boolean']>;
};


export type X509V3ExtensionsTypeExportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeExternalReferencesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeImportFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeIndicatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeJobsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeNotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeOpinionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypePendingFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type X509V3ExtensionsTypeStixCoreRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCoreRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCoreRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};


export type X509V3ExtensionsTypeStixCyberObservableRelationshipsArgs = {
  after?: InputMaybe<Scalars['ID']>;
  confidences?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  filterMode?: InputMaybe<FilterMode>;
  filters?: InputMaybe<Array<InputMaybe<StixCyberObservableRelationshipsFiltering>>>;
  first?: InputMaybe<Scalars['Int']>;
  firstSeenStart?: InputMaybe<Scalars['DateTime']>;
  firstSeenStop?: InputMaybe<Scalars['DateTime']>;
  fromId?: InputMaybe<Scalars['String']>;
  fromTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  lastSeenStart?: InputMaybe<Scalars['DateTime']>;
  lastSeenStop?: InputMaybe<Scalars['DateTime']>;
  orderBy?: InputMaybe<StixCyberObservableRelationshipsOrdering>;
  orderMode?: InputMaybe<OrderingMode>;
  relationship_type?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  startTimeStart?: InputMaybe<Scalars['DateTime']>;
  startTimeStop?: InputMaybe<Scalars['DateTime']>;
  stopTimeStart?: InputMaybe<Scalars['DateTime']>;
  stopTimeStop?: InputMaybe<Scalars['DateTime']>;
  toId?: InputMaybe<Scalars['String']>;
  toTypes?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type X509V3ExtensionsTypeAddInput = {
  authority_key_identifier?: InputMaybe<Scalars['String']>;
  basic_constraints?: InputMaybe<Scalars['String']>;
  certificate_policies?: InputMaybe<Scalars['String']>;
  crl_distribution_points?: InputMaybe<Scalars['String']>;
  extended_key_usage?: InputMaybe<Scalars['String']>;
  inhibit_any_policy?: InputMaybe<Scalars['String']>;
  issuer_alternative_name?: InputMaybe<Scalars['String']>;
  key_usage?: InputMaybe<Scalars['String']>;
  name_constraints?: InputMaybe<Scalars['String']>;
  policy_constraints?: InputMaybe<Scalars['String']>;
  policy_mappings?: InputMaybe<Scalars['String']>;
  private_key_usage_period_not_after?: InputMaybe<Scalars['DateTime']>;
  private_key_usage_period_not_before?: InputMaybe<Scalars['DateTime']>;
  subject_alternative_name?: InputMaybe<Scalars['String']>;
  subject_directory_attributes?: InputMaybe<Scalars['String']>;
  subject_key_identifier?: InputMaybe<Scalars['String']>;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AckDetails: ResolverTypeWrapper<AckDetails>;
  AppDebugDistribution: ResolverTypeWrapper<AppDebugDistribution>;
  AppDebugStatistics: ResolverTypeWrapper<AppDebugStatistics>;
  AppInfo: ResolverTypeWrapper<AppInfo>;
  AppMemory: ResolverTypeWrapper<AppMemory>;
  Artifact: ResolverTypeWrapper<Artifact>;
  ArtifactAddInput: ArtifactAddInput;
  AttackPattern: ResolverTypeWrapper<AttackPattern>;
  AttackPatternAddInput: AttackPatternAddInput;
  AttackPatternConnection: ResolverTypeWrapper<AttackPatternConnection>;
  AttackPatternEdge: ResolverTypeWrapper<AttackPatternEdge>;
  AttackPatternEditMutations: ResolverTypeWrapper<AttackPatternEditMutations>;
  AttackPatternsFilter: AttackPatternsFilter;
  AttackPatternsFiltering: AttackPatternsFiltering;
  AttackPatternsOrdering: AttackPatternsOrdering;
  Attribute: ResolverTypeWrapper<Attribute>;
  AttributeConnection: ResolverTypeWrapper<AttributeConnection>;
  AttributeEdge: ResolverTypeWrapper<AttributeEdge>;
  AttributeEditMutations: ResolverTypeWrapper<AttributeEditMutations>;
  AttributesOrdering: AttributesOrdering;
  AutonomousSystem: ResolverTypeWrapper<AutonomousSystem>;
  AutonomousSystemAddInput: AutonomousSystemAddInput;
  BasicObject: ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['Campaign'] | ResolversTypes['Capability'] | ResolversTypes['City'] | ResolversTypes['Connector'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['ExternalReference'] | ResolversTypes['Group'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Role'] | ResolversTypes['Sector'] | ResolversTypes['Settings'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['User'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  BasicRelationship: ResolversTypes['InternalRelationship'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'];
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Campaign: ResolverTypeWrapper<Campaign>;
  CampaignAddInput: CampaignAddInput;
  CampaignConnection: ResolverTypeWrapper<CampaignConnection>;
  CampaignEdge: ResolverTypeWrapper<CampaignEdge>;
  CampaignEditMutations: ResolverTypeWrapper<CampaignEditMutations>;
  CampaignsFilter: CampaignsFilter;
  CampaignsFiltering: CampaignsFiltering;
  CampaignsOrdering: CampaignsOrdering;
  Capabilities: Capabilities;
  Capability: ResolverTypeWrapper<Capability>;
  CapabilityConnection: ResolverTypeWrapper<CapabilityConnection>;
  CapabilityEdge: ResolverTypeWrapper<CapabilityEdge>;
  CitiesFilter: CitiesFilter;
  CitiesFiltering: CitiesFiltering;
  CitiesOrdering: CitiesOrdering;
  City: ResolverTypeWrapper<City>;
  CityAddInput: CityAddInput;
  CityConnection: ResolverTypeWrapper<CityConnection>;
  CityEdge: ResolverTypeWrapper<CityEdge>;
  CityEditMutations: ResolverTypeWrapper<CityEditMutations>;
  Connector: ResolverTypeWrapper<Connector>;
  ConnectorConfig: ResolverTypeWrapper<ConnectorConfig>;
  ConnectorType: ConnectorType;
  ConstraintNumber: ResolverTypeWrapper<Scalars['ConstraintNumber']>;
  ConstraintString: ResolverTypeWrapper<Scalars['ConstraintString']>;
  Container: ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Report'];
  ContainerConnection: ResolverTypeWrapper<ContainerConnection>;
  ContainerEdge: ResolverTypeWrapper<ContainerEdge>;
  ContainerEditMutations: ResolverTypeWrapper<ContainerEditMutations>;
  ContainersFilter: ContainersFilter;
  ContainersFiltering: ContainersFiltering;
  ContainersOrdering: ContainersOrdering;
  ContextData: ResolverTypeWrapper<ContextData>;
  CountriesFilter: CountriesFilter;
  CountriesFiltering: CountriesFiltering;
  CountriesOrdering: CountriesOrdering;
  Country: ResolverTypeWrapper<Country>;
  CountryAddInput: CountryAddInput;
  CountryConnection: ResolverTypeWrapper<CountryConnection>;
  CountryEdge: ResolverTypeWrapper<CountryEdge>;
  CountryEditMutations: ResolverTypeWrapper<CountryEditMutations>;
  CourseOfAction: ResolverTypeWrapper<CourseOfAction>;
  CourseOfActionAddInput: CourseOfActionAddInput;
  CourseOfActionConnection: ResolverTypeWrapper<CourseOfActionConnection>;
  CourseOfActionEdge: ResolverTypeWrapper<CourseOfActionEdge>;
  CourseOfActionEditMutations: ResolverTypeWrapper<CourseOfActionEditMutations>;
  CoursesOfActionFilter: CoursesOfActionFilter;
  CoursesOfActionFiltering: CoursesOfActionFiltering;
  CoursesOfActionOrdering: CoursesOfActionOrdering;
  CryptocurrencyWallet: ResolverTypeWrapper<CryptocurrencyWallet>;
  CryptocurrencyWalletAddInput: CryptocurrencyWalletAddInput;
  CryptographicKey: ResolverTypeWrapper<CryptographicKey>;
  CryptographicKeyAddInput: CryptographicKeyAddInput;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  DependencyVersion: ResolverTypeWrapper<DependencyVersion>;
  Directory: ResolverTypeWrapper<Directory>;
  DirectoryAddInput: DirectoryAddInput;
  Distribution: ResolverTypeWrapper<Omit<Distribution, 'entity'> & { entity?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  DocsMetrics: ResolverTypeWrapper<DocsMetrics>;
  DomainName: ResolverTypeWrapper<DomainName>;
  DomainNameAddInput: DomainNameAddInput;
  EditContext: EditContext;
  EditInput: EditInput;
  EditOperation: EditOperation;
  EditUserContext: ResolverTypeWrapper<EditUserContext>;
  ElasticSearchMetrics: ResolverTypeWrapper<ElasticSearchMetrics>;
  EmailAddr: ResolverTypeWrapper<EmailAddr>;
  EmailAddrAddInput: EmailAddrAddInput;
  EmailMessage: ResolverTypeWrapper<EmailMessage>;
  EmailMessageAddInput: EmailMessageAddInput;
  EmailMimePartType: ResolverTypeWrapper<EmailMimePartType>;
  EmailMimePartTypeAddInput: EmailMimePartTypeAddInput;
  ExternalReference: ResolverTypeWrapper<ExternalReference>;
  ExternalReferenceAddInput: ExternalReferenceAddInput;
  ExternalReferenceConnection: ResolverTypeWrapper<ExternalReferenceConnection>;
  ExternalReferenceEdge: ResolverTypeWrapper<ExternalReferenceEdge>;
  ExternalReferenceEditMutations: ResolverTypeWrapper<ExternalReferenceEditMutations>;
  ExternalReferencesFilter: ExternalReferencesFilter;
  ExternalReferencesFiltering: ExternalReferencesFiltering;
  ExternalReferencesOrdering: ExternalReferencesOrdering;
  File: ResolverTypeWrapper<File>;
  FileConnection: ResolverTypeWrapper<FileConnection>;
  FileEdge: ResolverTypeWrapper<FileEdge>;
  FileMetadata: ResolverTypeWrapper<FileMetadata>;
  FilterMode: FilterMode;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  GetMetrics: ResolverTypeWrapper<GetMetrics>;
  Group: ResolverTypeWrapper<Group>;
  GroupAddInput: GroupAddInput;
  GroupConnection: ResolverTypeWrapper<GroupConnection>;
  GroupEdge: ResolverTypeWrapper<GroupEdge>;
  GroupEditMutations: ResolverTypeWrapper<GroupEditMutations>;
  GroupsOrdering: GroupsOrdering;
  Hash: ResolverTypeWrapper<Hash>;
  HashInput: HashInput;
  HashedObservable: ResolversTypes['Artifact'] | ResolversTypes['StixFile'] | ResolversTypes['X509Certificate'];
  Hostname: ResolverTypeWrapper<Hostname>;
  HostnameAddInput: HostnameAddInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  IPv4Addr: ResolverTypeWrapper<IPv4Addr>;
  IPv4AddrAddInput: IPv4AddrAddInput;
  IPv6Addr: ResolverTypeWrapper<IPv6Addr>;
  IPv6AddrAddInput: IPv6AddrAddInput;
  IdentitiesFilter: IdentitiesFilter;
  IdentitiesFiltering: IdentitiesFiltering;
  IdentitiesOrdering: IdentitiesOrdering;
  Identity: ResolversTypes['Individual'] | ResolversTypes['Organization'] | ResolversTypes['Sector'] | ResolversTypes['System'];
  IdentityAddInput: IdentityAddInput;
  IdentityConnection: ResolverTypeWrapper<IdentityConnection>;
  IdentityEdge: ResolverTypeWrapper<IdentityEdge>;
  IdentityEditMutations: ResolverTypeWrapper<IdentityEditMutations>;
  IdentityType: IdentityType;
  Incident: ResolverTypeWrapper<Incident>;
  IncidentAddInput: IncidentAddInput;
  IncidentConnection: ResolverTypeWrapper<IncidentConnection>;
  IncidentEdge: ResolverTypeWrapper<IncidentEdge>;
  IncidentEditMutations: ResolverTypeWrapper<IncidentEditMutations>;
  IncidentsFilter: IncidentsFilter;
  IncidentsFiltering: IncidentsFiltering;
  IncidentsOrdering: IncidentsOrdering;
  IndexingMetrics: ResolverTypeWrapper<IndexingMetrics>;
  Indicator: ResolverTypeWrapper<Indicator>;
  IndicatorAddInput: IndicatorAddInput;
  IndicatorConnection: ResolverTypeWrapper<IndicatorConnection>;
  IndicatorEdge: ResolverTypeWrapper<IndicatorEdge>;
  IndicatorEditMutations: ResolverTypeWrapper<IndicatorEditMutations>;
  IndicatorsFilter: IndicatorsFilter;
  IndicatorsFiltering: IndicatorsFiltering;
  IndicatorsOrdering: IndicatorsOrdering;
  Individual: ResolverTypeWrapper<Individual>;
  IndividualAddInput: IndividualAddInput;
  IndividualConnection: ResolverTypeWrapper<IndividualConnection>;
  IndividualEdge: ResolverTypeWrapper<IndividualEdge>;
  IndividualEditMutations: ResolverTypeWrapper<IndividualEditMutations>;
  IndividualsFilter: IndividualsFilter;
  IndividualsFiltering: IndividualsFiltering;
  IndividualsOrdering: IndividualsOrdering;
  Inference: ResolverTypeWrapper<Omit<Inference, 'explanation'> & { explanation: Array<Maybe<ResolversTypes['StixObjectOrStixRelationship']>> }>;
  InferenceAttribute: ResolverTypeWrapper<InferenceAttribute>;
  Infrastructure: ResolverTypeWrapper<Infrastructure>;
  InfrastructureAddInput: InfrastructureAddInput;
  InfrastructureConnection: ResolverTypeWrapper<InfrastructureConnection>;
  InfrastructureEdge: ResolverTypeWrapper<InfrastructureEdge>;
  InfrastructureEditMutations: ResolverTypeWrapper<InfrastructureEditMutations>;
  InfrastructuresFilter: InfrastructuresFilter;
  InfrastructuresFiltering: InfrastructuresFiltering;
  InfrastructuresOrdering: InfrastructuresOrdering;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  InternalObject: ResolversTypes['Capability'] | ResolversTypes['Connector'] | ResolversTypes['Group'] | ResolversTypes['Role'] | ResolversTypes['Settings'] | ResolversTypes['User'];
  InternalRelationship: ResolverTypeWrapper<InternalRelationship>;
  InternalRelationshipAddInput: InternalRelationshipAddInput;
  IntrusionSet: ResolverTypeWrapper<IntrusionSet>;
  IntrusionSetAddInput: IntrusionSetAddInput;
  IntrusionSetConnection: ResolverTypeWrapper<IntrusionSetConnection>;
  IntrusionSetEdge: ResolverTypeWrapper<IntrusionSetEdge>;
  IntrusionSetEditMutations: ResolverTypeWrapper<IntrusionSetEditMutations>;
  IntrusionSetsFilter: IntrusionSetsFilter;
  IntrusionSetsFiltering: IntrusionSetsFiltering;
  IntrusionSetsOrdering: IntrusionSetsOrdering;
  KillChainPhase: ResolverTypeWrapper<KillChainPhase>;
  KillChainPhaseAddInput: KillChainPhaseAddInput;
  KillChainPhaseConnection: ResolverTypeWrapper<KillChainPhaseConnection>;
  KillChainPhaseEdge: ResolverTypeWrapper<KillChainPhaseEdge>;
  KillChainPhaseEditMutations: ResolverTypeWrapper<KillChainPhaseEditMutations>;
  KillChainPhasesFilter: KillChainPhasesFilter;
  KillChainPhasesFiltering: KillChainPhasesFiltering;
  KillChainPhasesOrdering: KillChainPhasesOrdering;
  Label: ResolverTypeWrapper<Label>;
  LabelAddInput: LabelAddInput;
  LabelConnection: ResolverTypeWrapper<LabelConnection>;
  LabelEdge: ResolverTypeWrapper<LabelEdge>;
  LabelEditMutations: ResolverTypeWrapper<LabelEditMutations>;
  LabelsFilter: LabelsFilter;
  LabelsFiltering: LabelsFiltering;
  LabelsOrdering: LabelsOrdering;
  ListTask: ResolverTypeWrapper<ListTask>;
  ListTaskAddInput: ListTaskAddInput;
  Location: ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['Position'] | ResolversTypes['Region'];
  LocationAddInput: LocationAddInput;
  LocationConnection: ResolverTypeWrapper<LocationConnection>;
  LocationEdge: ResolverTypeWrapper<LocationEdge>;
  LocationEditMutations: ResolverTypeWrapper<LocationEditMutations>;
  LocationType: LocationType;
  LocationsFilter: LocationsFilter;
  LocationsFiltering: LocationsFiltering;
  LocationsOrdering: LocationsOrdering;
  Log: ResolverTypeWrapper<Log>;
  LogConnection: ResolverTypeWrapper<LogConnection>;
  LogEdge: ResolverTypeWrapper<LogEdge>;
  LogsFilter: LogsFilter;
  LogsFiltering: LogsFiltering;
  LogsOrdering: LogsOrdering;
  LogsWorkerConfig: ResolverTypeWrapper<LogsWorkerConfig>;
  MacAddr: ResolverTypeWrapper<MacAddr>;
  MacAddrAddInput: MacAddrAddInput;
  Malware: ResolverTypeWrapper<Malware>;
  MalwareAddInput: MalwareAddInput;
  MalwareConnection: ResolverTypeWrapper<MalwareConnection>;
  MalwareEdge: ResolverTypeWrapper<MalwareEdge>;
  MalwareEditMutations: ResolverTypeWrapper<MalwareEditMutations>;
  MalwaresFilter: MalwaresFilter;
  MalwaresFiltering: MalwaresFiltering;
  MalwaresOrdering: MalwaresOrdering;
  MarkingDefinition: ResolverTypeWrapper<MarkingDefinition>;
  MarkingDefinitionAddInput: MarkingDefinitionAddInput;
  MarkingDefinitionConnection: ResolverTypeWrapper<MarkingDefinitionConnection>;
  MarkingDefinitionEdge: ResolverTypeWrapper<MarkingDefinitionEdge>;
  MarkingDefinitionEditMutations: ResolverTypeWrapper<MarkingDefinitionEditMutations>;
  MarkingDefinitionsFilter: MarkingDefinitionsFilter;
  MarkingDefinitionsFiltering: MarkingDefinitionsFiltering;
  MarkingDefinitionsOrdering: MarkingDefinitionsOrdering;
  MessagesStats: ResolverTypeWrapper<MessagesStats>;
  Module: ResolverTypeWrapper<Module>;
  Mutation: ResolverTypeWrapper<{}>;
  Mutex: ResolverTypeWrapper<Mutex>;
  MutexAddInput: MutexAddInput;
  NetworkTraffic: ResolverTypeWrapper<NetworkTraffic>;
  NetworkTrafficAddInput: NetworkTrafficAddInput;
  Note: ResolverTypeWrapper<Note>;
  NoteAddInput: NoteAddInput;
  NoteConnection: ResolverTypeWrapper<NoteConnection>;
  NoteEdge: ResolverTypeWrapper<NoteEdge>;
  NoteEditMutations: ResolverTypeWrapper<NoteEditMutations>;
  NotesFilter: NotesFilter;
  NotesFiltering: NotesFiltering;
  NotesOrdering: NotesOrdering;
  Number: ResolverTypeWrapper<Number>;
  ObjectTotals: ResolverTypeWrapper<ObjectTotals>;
  ObservedData: ResolverTypeWrapper<ObservedData>;
  ObservedDataAddInput: ObservedDataAddInput;
  ObservedDataConnection: ResolverTypeWrapper<ObservedDataConnection>;
  ObservedDataEdge: ResolverTypeWrapper<ObservedDataEdge>;
  ObservedDataEditMutations: ResolverTypeWrapper<ObservedDataEditMutations>;
  ObservedDatasFilter: ObservedDatasFilter;
  ObservedDatasFiltering: ObservedDatasFiltering;
  ObservedDatasOrdering: ObservedDatasOrdering;
  Opinion: ResolverTypeWrapper<Opinion>;
  OpinionAddInput: OpinionAddInput;
  OpinionConnection: ResolverTypeWrapper<OpinionConnection>;
  OpinionEdge: ResolverTypeWrapper<OpinionEdge>;
  OpinionEditMutations: ResolverTypeWrapper<OpinionEditMutations>;
  OpinionsFilter: OpinionsFilter;
  OpinionsFiltering: OpinionsFiltering;
  OpinionsOrdering: OpinionsOrdering;
  OrderingMode: OrderingMode;
  Organization: ResolverTypeWrapper<Organization>;
  OrganizationAddInput: OrganizationAddInput;
  OrganizationConnection: ResolverTypeWrapper<OrganizationConnection>;
  OrganizationEdge: ResolverTypeWrapper<OrganizationEdge>;
  OrganizationEditMutations: ResolverTypeWrapper<OrganizationEditMutations>;
  OrganizationOrIndividual: ResolversTypes['Individual'] | ResolversTypes['Organization'];
  OrganizationReliability: OrganizationReliability;
  OrganizationsFilter: OrganizationsFilter;
  OrganizationsFiltering: OrganizationsFiltering;
  OrganizationsOrdering: OrganizationsOrdering;
  OverviewMetrics: ResolverTypeWrapper<OverviewMetrics>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Position: ResolverTypeWrapper<Position>;
  PositionAddInput: PositionAddInput;
  PositionConnection: ResolverTypeWrapper<PositionConnection>;
  PositionEdge: ResolverTypeWrapper<PositionEdge>;
  PositionEditMutations: ResolverTypeWrapper<PositionEditMutations>;
  PositionsFilter: PositionsFilter;
  PositionsFiltering: PositionsFiltering;
  PositionsOrdering: PositionsOrdering;
  Process: ResolverTypeWrapper<Process>;
  ProcessAddInput: ProcessAddInput;
  Provider: ResolverTypeWrapper<Provider>;
  Query: ResolverTypeWrapper<{}>;
  QueryTask: ResolverTypeWrapper<QueryTask>;
  QueryTaskAddInput: QueryTaskAddInput;
  QueueArguments: ResolverTypeWrapper<QueueArguments>;
  QueueMetrics: ResolverTypeWrapper<QueueMetrics>;
  QueueTotals: ResolverTypeWrapper<QueueTotals>;
  RabbitMQConnection: ResolverTypeWrapper<RabbitMqConnection>;
  RabbitMQMetrics: ResolverTypeWrapper<RabbitMqMetrics>;
  Region: ResolverTypeWrapper<Region>;
  RegionAddInput: RegionAddInput;
  RegionConnection: ResolverTypeWrapper<RegionConnection>;
  RegionEdge: ResolverTypeWrapper<RegionEdge>;
  RegionEditMutations: ResolverTypeWrapper<RegionEditMutations>;
  RegionsFilter: RegionsFilter;
  RegionsFiltering: RegionsFiltering;
  RegionsOrdering: RegionsOrdering;
  RegisterConnectorInput: RegisterConnectorInput;
  Report: ResolverTypeWrapper<Report>;
  ReportAddInput: ReportAddInput;
  ReportConnection: ResolverTypeWrapper<ReportConnection>;
  ReportEdge: ResolverTypeWrapper<ReportEdge>;
  ReportEditMutations: ResolverTypeWrapper<ReportEditMutations>;
  ReportsFilter: ReportsFilter;
  ReportsFiltering: ReportsFiltering;
  ReportsOrdering: ReportsOrdering;
  RetentionRule: ResolverTypeWrapper<RetentionRule>;
  RetentionRuleAddInput: RetentionRuleAddInput;
  RetentionRuleConnection: ResolverTypeWrapper<RetentionRuleConnection>;
  RetentionRuleEdge: ResolverTypeWrapper<RetentionRuleEdge>;
  RetentionRuleEditMutations: ResolverTypeWrapper<RetentionRuleEditMutations>;
  Role: ResolverTypeWrapper<Role>;
  RoleAddInput: RoleAddInput;
  RoleConnection: ResolverTypeWrapper<RoleConnection>;
  RoleEdge: ResolverTypeWrapper<RoleEdge>;
  RoleEditMutations: ResolverTypeWrapper<RoleEditMutations>;
  RolesOrdering: RolesOrdering;
  Rule: ResolverTypeWrapper<Rule>;
  RuleExecutionError: ResolverTypeWrapper<RuleExecutionError>;
  RuleManager: ResolverTypeWrapper<RuleManager>;
  RuleTask: ResolverTypeWrapper<RuleTask>;
  SearchMetrics: ResolverTypeWrapper<SearchMetrics>;
  Sector: ResolverTypeWrapper<Sector>;
  SectorAddInput: SectorAddInput;
  SectorConnection: ResolverTypeWrapper<SectorConnection>;
  SectorEdge: ResolverTypeWrapper<SectorEdge>;
  SectorEditMutations: ResolverTypeWrapper<SectorEditMutations>;
  SectorsFilter: SectorsFilter;
  SectorsFiltering: SectorsFiltering;
  SectorsOrdering: SectorsOrdering;
  SessionDetail: ResolverTypeWrapper<SessionDetail>;
  Settings: ResolverTypeWrapper<Settings>;
  SettingsEditMutations: ResolverTypeWrapper<SettingsEditMutations>;
  Software: ResolverTypeWrapper<Software>;
  SoftwareAddInput: SoftwareAddInput;
  State: State;
  StatsOperation: StatsOperation;
  Status: ResolverTypeWrapper<Status>;
  StatusAddInput: StatusAddInput;
  StatusConnection: ResolverTypeWrapper<StatusConnection>;
  StatusEdge: ResolverTypeWrapper<StatusEdge>;
  StatusFilter: StatusFilter;
  StatusOrdering: StatusOrdering;
  StatusTemplate: ResolverTypeWrapper<StatusTemplate>;
  StatusTemplateConnection: ResolverTypeWrapper<StatusTemplateConnection>;
  StatusTemplateEdge: ResolverTypeWrapper<StatusTemplateEdge>;
  StatusTemplateOrdering: StatusTemplateOrdering;
  StatusesFiltering: StatusesFiltering;
  StixCoreObject: ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['Campaign'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  StixCoreObjectConnection: ResolverTypeWrapper<StixCoreObjectConnection>;
  StixCoreObjectEdge: ResolverTypeWrapper<StixCoreObjectEdge>;
  StixCoreObjectEditMutations: ResolverTypeWrapper<StixCoreObjectEditMutations>;
  StixCoreObjectOrStixCoreRelationship: ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['Campaign'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixFile'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  StixCoreObjectsFilter: StixCoreObjectsFilter;
  StixCoreObjectsFiltering: StixCoreObjectsFiltering;
  StixCoreObjectsOrdering: StixCoreObjectsOrdering;
  StixCoreRelationship: ResolverTypeWrapper<Omit<StixCoreRelationship, 'from' | 'to'> & { from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixCoreRelationshipAddInput: StixCoreRelationshipAddInput;
  StixCoreRelationshipConnection: ResolverTypeWrapper<StixCoreRelationshipConnection>;
  StixCoreRelationshipEdge: ResolverTypeWrapper<StixCoreRelationshipEdge>;
  StixCoreRelationshipEditMutations: ResolverTypeWrapper<StixCoreRelationshipEditMutations>;
  StixCoreRelationshipsFilter: StixCoreRelationshipsFilter;
  StixCoreRelationshipsFiltering: StixCoreRelationshipsFiltering;
  StixCoreRelationshipsOrdering: StixCoreRelationshipsOrdering;
  StixCyberObservable: ResolversTypes['Artifact'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['MacAddr'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Process'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['Text'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  StixCyberObservableConnection: ResolverTypeWrapper<StixCyberObservableConnection>;
  StixCyberObservableEdge: ResolverTypeWrapper<StixCyberObservableEdge>;
  StixCyberObservableEditMutations: ResolverTypeWrapper<StixCyberObservableEditMutations>;
  StixCyberObservableRelationship: ResolverTypeWrapper<Omit<StixCyberObservableRelationship, 'from' | 'to'> & { from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixCyberObservableRelationshipAddInput: StixCyberObservableRelationshipAddInput;
  StixCyberObservableRelationshipConnection: ResolverTypeWrapper<StixCyberObservableRelationshipConnection>;
  StixCyberObservableRelationshipEdge: ResolverTypeWrapper<StixCyberObservableRelationshipEdge>;
  StixCyberObservableRelationshipEditMutations: ResolverTypeWrapper<StixCyberObservableRelationshipEditMutations>;
  StixCyberObservableRelationshipsFilter: StixCyberObservableRelationshipsFilter;
  StixCyberObservableRelationshipsFiltering: StixCyberObservableRelationshipsFiltering;
  StixCyberObservableRelationshipsOrdering: StixCyberObservableRelationshipsOrdering;
  StixCyberObservablesFilter: StixCyberObservablesFilter;
  StixCyberObservablesFiltering: StixCyberObservablesFiltering;
  StixCyberObservablesOrdering: StixCyberObservablesOrdering;
  StixDomainObject: ResolversTypes['AttackPattern'] | ResolversTypes['Campaign'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['Malware'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['System'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Vulnerability'];
  StixDomainObjectAddInput: StixDomainObjectAddInput;
  StixDomainObjectConnection: ResolverTypeWrapper<StixDomainObjectConnection>;
  StixDomainObjectEdge: ResolverTypeWrapper<StixDomainObjectEdge>;
  StixDomainObjectEditMutations: ResolverTypeWrapper<StixDomainObjectEditMutations>;
  StixDomainObjectsFilter: StixDomainObjectsFilter;
  StixDomainObjectsFiltering: StixDomainObjectsFiltering;
  StixDomainObjectsOrdering: StixDomainObjectsOrdering;
  StixEditMutations: ResolverTypeWrapper<StixEditMutations>;
  StixFile: ResolverTypeWrapper<StixFile>;
  StixFileAddInput: StixFileAddInput;
  StixMetaObject: ResolversTypes['ExternalReference'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['MarkingDefinition'];
  StixMetaRelationship: ResolverTypeWrapper<Omit<StixMetaRelationship, 'from' | 'to'> & { from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixMetaRelationshipAddInput: StixMetaRelationshipAddInput;
  StixMetaRelationshipConnection: ResolverTypeWrapper<StixMetaRelationshipConnection>;
  StixMetaRelationshipEdge: ResolverTypeWrapper<StixMetaRelationshipEdge>;
  StixMetaRelationshipsAddInput: StixMetaRelationshipsAddInput;
  StixMetaRelationshipsFilter: StixMetaRelationshipsFilter;
  StixMetaRelationshipsFiltering: StixMetaRelationshipsFiltering;
  StixMetaRelationshipsOrdering: StixMetaRelationshipsOrdering;
  StixObject: ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['Campaign'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['ExternalReference'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixFile'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  StixObjectOrStixRelationship: ResolversTypes['Artifact'] | ResolversTypes['AttackPattern'] | ResolversTypes['AutonomousSystem'] | ResolversTypes['Campaign'] | ResolversTypes['City'] | ResolversTypes['Country'] | ResolversTypes['CourseOfAction'] | ResolversTypes['CryptocurrencyWallet'] | ResolversTypes['CryptographicKey'] | ResolversTypes['Directory'] | ResolversTypes['DomainName'] | ResolversTypes['EmailAddr'] | ResolversTypes['EmailMessage'] | ResolversTypes['EmailMimePartType'] | ResolversTypes['ExternalReference'] | ResolversTypes['Hostname'] | ResolversTypes['IPv4Addr'] | ResolversTypes['IPv6Addr'] | ResolversTypes['Incident'] | ResolversTypes['Indicator'] | ResolversTypes['Individual'] | ResolversTypes['Infrastructure'] | ResolversTypes['IntrusionSet'] | ResolversTypes['KillChainPhase'] | ResolversTypes['Label'] | ResolversTypes['MacAddr'] | ResolversTypes['Malware'] | ResolversTypes['MarkingDefinition'] | ResolversTypes['Mutex'] | ResolversTypes['NetworkTraffic'] | ResolversTypes['Note'] | ResolversTypes['ObservedData'] | ResolversTypes['Opinion'] | ResolversTypes['Organization'] | ResolversTypes['Position'] | ResolversTypes['Process'] | ResolversTypes['Region'] | ResolversTypes['Report'] | ResolversTypes['Sector'] | ResolversTypes['Software'] | ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixFile'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'] | ResolversTypes['System'] | ResolversTypes['Text'] | ResolversTypes['ThreatActor'] | ResolversTypes['Tool'] | ResolversTypes['Url'] | ResolversTypes['UserAccount'] | ResolversTypes['UserAgent'] | ResolversTypes['Vulnerability'] | ResolversTypes['WindowsRegistryKey'] | ResolversTypes['WindowsRegistryValueType'] | ResolversTypes['X509Certificate'] | ResolversTypes['X509V3ExtensionsType'];
  StixObjectOrStixRelationshipConnection: ResolverTypeWrapper<StixObjectOrStixRelationshipConnection>;
  StixObjectOrStixRelationshipEdge: ResolverTypeWrapper<Omit<StixObjectOrStixRelationshipEdge, 'node'> & { node: ResolversTypes['StixObjectOrStixRelationship'] }>;
  StixObjectOrStixRelationshipsFilter: StixObjectOrStixRelationshipsFilter;
  StixObjectOrStixRelationshipsFiltering: StixObjectOrStixRelationshipsFiltering;
  StixObjectOrStixRelationshipsOrdering: StixObjectOrStixRelationshipsOrdering;
  StixRelationship: ResolversTypes['StixCoreRelationship'] | ResolversTypes['StixCyberObservableRelationship'] | ResolversTypes['StixMetaRelationship'] | ResolversTypes['StixSightingRelationship'];
  StixRelationshipConnection: ResolverTypeWrapper<StixRelationshipConnection>;
  StixRelationshipEdge: ResolverTypeWrapper<StixRelationshipEdge>;
  StixRelationshipEditMutations: ResolverTypeWrapper<StixRelationshipEditMutations>;
  StixRelationshipsFilter: StixRelationshipsFilter;
  StixRelationshipsFiltering: StixRelationshipsFiltering;
  StixRelationshipsOrdering: StixRelationshipsOrdering;
  StixSightingRelationship: ResolverTypeWrapper<Omit<StixSightingRelationship, 'from' | 'to'> & { from?: Maybe<ResolversTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversTypes['StixObjectOrStixRelationship']> }>;
  StixSightingRelationshipAddInput: StixSightingRelationshipAddInput;
  StixSightingRelationshipConnection: ResolverTypeWrapper<StixSightingRelationshipConnection>;
  StixSightingRelationshipEditMutations: ResolverTypeWrapper<StixSightingRelationshipEditMutations>;
  StixSightingRelationshipsEdge: ResolverTypeWrapper<StixSightingRelationshipsEdge>;
  StixSightingRelationshipsFilter: StixSightingRelationshipsFilter;
  StixSightingRelationshipsFiltering: StixSightingRelationshipsFiltering;
  StixSightingRelationshipsOrdering: StixSightingRelationshipsOrdering;
  StreamCollection: ResolverTypeWrapper<StreamCollection>;
  StreamCollectionAddInput: StreamCollectionAddInput;
  StreamCollectionConnection: ResolverTypeWrapper<StreamCollectionConnection>;
  StreamCollectionEdge: ResolverTypeWrapper<StreamCollectionEdge>;
  StreamCollectionEditMutations: ResolverTypeWrapper<StreamCollectionEditMutations>;
  StreamCollectionOrdering: StreamCollectionOrdering;
  String: ResolverTypeWrapper<Scalars['String']>;
  SubType: ResolverTypeWrapper<SubType>;
  SubTypeConnection: ResolverTypeWrapper<SubTypeConnection>;
  SubTypeEdge: ResolverTypeWrapper<SubTypeEdge>;
  SubTypeEditMutations: ResolverTypeWrapper<SubTypeEditMutations>;
  SubTypesOrdering: SubTypesOrdering;
  Subscription: ResolverTypeWrapper<{}>;
  Synchronizer: ResolverTypeWrapper<Synchronizer>;
  SynchronizerAddInput: SynchronizerAddInput;
  SynchronizerConnection: ResolverTypeWrapper<SynchronizerConnection>;
  SynchronizerEdge: ResolverTypeWrapper<SynchronizerEdge>;
  SynchronizerEditMutations: ResolverTypeWrapper<SynchronizerEditMutations>;
  SynchronizersOrdering: SynchronizersOrdering;
  System: ResolverTypeWrapper<System>;
  SystemAddInput: SystemAddInput;
  SystemConnection: ResolverTypeWrapper<SystemConnection>;
  SystemEdge: ResolverTypeWrapper<SystemEdge>;
  SystemEditMutations: ResolverTypeWrapper<SystemEditMutations>;
  SystemsFilter: SystemsFilter;
  SystemsFiltering: SystemsFiltering;
  SystemsOrdering: SystemsOrdering;
  Task: ResolversTypes['ListTask'] | ResolversTypes['QueryTask'] | ResolversTypes['RuleTask'];
  TaskAction: ResolverTypeWrapper<TaskAction>;
  TaskActionInput: TaskActionInput;
  TaskActionType: TaskActionType;
  TaskConnection: ResolverTypeWrapper<TaskConnection>;
  TaskConnectionEdge: ResolverTypeWrapper<TaskConnectionEdge>;
  TaskContext: ResolverTypeWrapper<TaskContext>;
  TaskContextInput: TaskContextInput;
  TaskContextType: TaskContextType;
  TaskError: ResolverTypeWrapper<TaskError>;
  TaskType: TaskType;
  TasksFilter: TasksFilter;
  TasksFiltering: TasksFiltering;
  TasksOrdering: TasksOrdering;
  TaxiiCollection: ResolverTypeWrapper<TaxiiCollection>;
  TaxiiCollectionAddInput: TaxiiCollectionAddInput;
  TaxiiCollectionConnection: ResolverTypeWrapper<TaxiiCollectionConnection>;
  TaxiiCollectionEdge: ResolverTypeWrapper<TaxiiCollectionEdge>;
  TaxiiCollectionEditMutations: ResolverTypeWrapper<TaxiiCollectionEditMutations>;
  TaxiiCollectionOrdering: TaxiiCollectionOrdering;
  Text: ResolverTypeWrapper<Text>;
  TextAddInput: TextAddInput;
  ThreatActor: ResolverTypeWrapper<ThreatActor>;
  ThreatActorAddInput: ThreatActorAddInput;
  ThreatActorConnection: ResolverTypeWrapper<ThreatActorConnection>;
  ThreatActorEdge: ResolverTypeWrapper<ThreatActorEdge>;
  ThreatActorEditMutations: ResolverTypeWrapper<ThreatActorEditMutations>;
  ThreatActorsFilter: ThreatActorsFilter;
  ThreatActorsFiltering: ThreatActorsFiltering;
  ThreatActorsOrdering: ThreatActorsOrdering;
  TimeSeries: ResolverTypeWrapper<TimeSeries>;
  Tool: ResolverTypeWrapper<Tool>;
  ToolAddInput: ToolAddInput;
  ToolConnection: ResolverTypeWrapper<ToolConnection>;
  ToolEdge: ResolverTypeWrapper<ToolEdge>;
  ToolEditMutations: ResolverTypeWrapper<ToolEditMutations>;
  ToolsFilter: ToolsFilter;
  ToolsFiltering: ToolsFiltering;
  ToolsOrdering: ToolsOrdering;
  Upload: ResolverTypeWrapper<Scalars['Upload']>;
  Url: ResolverTypeWrapper<Url>;
  UrlAddInput: UrlAddInput;
  User: ResolverTypeWrapper<User>;
  UserAccount: ResolverTypeWrapper<UserAccount>;
  UserAccountAddInput: UserAccountAddInput;
  UserAddInput: UserAddInput;
  UserAgent: ResolverTypeWrapper<UserAgent>;
  UserAgentAddInput: UserAgentAddInput;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserEditMutations: ResolverTypeWrapper<UserEditMutations>;
  UserLoginInput: UserLoginInput;
  UserSession: ResolverTypeWrapper<UserSession>;
  UserSubscription: ResolverTypeWrapper<UserSubscription>;
  UserSubscriptionAddInput: UserSubscriptionAddInput;
  UserSubscriptionConnection: ResolverTypeWrapper<UserSubscriptionConnection>;
  UserSubscriptionEdge: ResolverTypeWrapper<UserSubscriptionEdge>;
  UserSubscriptionEditMutations: ResolverTypeWrapper<UserSubscriptionEditMutations>;
  UserSubscriptionOrdering: UserSubscriptionOrdering;
  UsersFilter: UsersFilter;
  UsersFiltering: UsersFiltering;
  UsersOrdering: UsersOrdering;
  VulnerabilitiesFilter: VulnerabilitiesFilter;
  VulnerabilitiesFiltering: VulnerabilitiesFiltering;
  VulnerabilitiesOrdering: VulnerabilitiesOrdering;
  Vulnerability: ResolverTypeWrapper<Vulnerability>;
  VulnerabilityAddInput: VulnerabilityAddInput;
  VulnerabilityConnection: ResolverTypeWrapper<VulnerabilityConnection>;
  VulnerabilityEdge: ResolverTypeWrapper<VulnerabilityEdge>;
  VulnerabilityEditMutations: ResolverTypeWrapper<VulnerabilityEditMutations>;
  WindowsRegistryKey: ResolverTypeWrapper<WindowsRegistryKey>;
  WindowsRegistryKeyAddInput: WindowsRegistryKeyAddInput;
  WindowsRegistryValueType: ResolverTypeWrapper<WindowsRegistryValueType>;
  WindowsRegistryValueTypeAddInput: WindowsRegistryValueTypeAddInput;
  Work: ResolverTypeWrapper<Work>;
  WorkConnection: ResolverTypeWrapper<WorkConnection>;
  WorkEdge: ResolverTypeWrapper<WorkEdge>;
  WorkEditMutations: ResolverTypeWrapper<WorkEditMutations>;
  WorkErrorInput: WorkErrorInput;
  WorkMessage: ResolverTypeWrapper<WorkMessage>;
  WorkTracking: ResolverTypeWrapper<WorkTracking>;
  WorksFilter: WorksFilter;
  WorksFiltering: WorksFiltering;
  WorksOrdering: WorksOrdering;
  Workspace: ResolverTypeWrapper<Workspace>;
  WorkspaceAddInput: WorkspaceAddInput;
  WorkspaceConnection: ResolverTypeWrapper<WorkspaceConnection>;
  WorkspaceEdge: ResolverTypeWrapper<WorkspaceEdge>;
  WorkspaceEditMutations: ResolverTypeWrapper<WorkspaceEditMutations>;
  WorkspacesFilter: WorkspacesFilter;
  WorkspacesFiltering: WorkspacesFiltering;
  WorkspacesOrdering: WorkspacesOrdering;
  X509Certificate: ResolverTypeWrapper<X509Certificate>;
  X509CertificateAddInput: X509CertificateAddInput;
  X509V3ExtensionsType: ResolverTypeWrapper<X509V3ExtensionsType>;
  X509V3ExtensionsTypeAddInput: X509V3ExtensionsTypeAddInput;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AckDetails: AckDetails;
  AppDebugDistribution: AppDebugDistribution;
  AppDebugStatistics: AppDebugStatistics;
  AppInfo: AppInfo;
  AppMemory: AppMemory;
  Artifact: Artifact;
  ArtifactAddInput: ArtifactAddInput;
  AttackPattern: AttackPattern;
  AttackPatternAddInput: AttackPatternAddInput;
  AttackPatternConnection: AttackPatternConnection;
  AttackPatternEdge: AttackPatternEdge;
  AttackPatternEditMutations: AttackPatternEditMutations;
  AttackPatternsFiltering: AttackPatternsFiltering;
  Attribute: Attribute;
  AttributeConnection: AttributeConnection;
  AttributeEdge: AttributeEdge;
  AttributeEditMutations: AttributeEditMutations;
  AutonomousSystem: AutonomousSystem;
  AutonomousSystemAddInput: AutonomousSystemAddInput;
  BasicObject: ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['Capability'] | ResolversParentTypes['City'] | ResolversParentTypes['Connector'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Group'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Role'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Settings'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['User'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  BasicRelationship: ResolversParentTypes['InternalRelationship'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'];
  Boolean: Scalars['Boolean'];
  Campaign: Campaign;
  CampaignAddInput: CampaignAddInput;
  CampaignConnection: CampaignConnection;
  CampaignEdge: CampaignEdge;
  CampaignEditMutations: CampaignEditMutations;
  CampaignsFiltering: CampaignsFiltering;
  Capability: Capability;
  CapabilityConnection: CapabilityConnection;
  CapabilityEdge: CapabilityEdge;
  CitiesFiltering: CitiesFiltering;
  City: City;
  CityAddInput: CityAddInput;
  CityConnection: CityConnection;
  CityEdge: CityEdge;
  CityEditMutations: CityEditMutations;
  Connector: Connector;
  ConnectorConfig: ConnectorConfig;
  ConstraintNumber: Scalars['ConstraintNumber'];
  ConstraintString: Scalars['ConstraintString'];
  Container: ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Report'];
  ContainerConnection: ContainerConnection;
  ContainerEdge: ContainerEdge;
  ContainerEditMutations: ContainerEditMutations;
  ContainersFiltering: ContainersFiltering;
  ContextData: ContextData;
  CountriesFiltering: CountriesFiltering;
  Country: Country;
  CountryAddInput: CountryAddInput;
  CountryConnection: CountryConnection;
  CountryEdge: CountryEdge;
  CountryEditMutations: CountryEditMutations;
  CourseOfAction: CourseOfAction;
  CourseOfActionAddInput: CourseOfActionAddInput;
  CourseOfActionConnection: CourseOfActionConnection;
  CourseOfActionEdge: CourseOfActionEdge;
  CourseOfActionEditMutations: CourseOfActionEditMutations;
  CoursesOfActionFiltering: CoursesOfActionFiltering;
  CryptocurrencyWallet: CryptocurrencyWallet;
  CryptocurrencyWalletAddInput: CryptocurrencyWalletAddInput;
  CryptographicKey: CryptographicKey;
  CryptographicKeyAddInput: CryptographicKeyAddInput;
  DateTime: Scalars['DateTime'];
  DependencyVersion: DependencyVersion;
  Directory: Directory;
  DirectoryAddInput: DirectoryAddInput;
  Distribution: Omit<Distribution, 'entity'> & { entity?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  DocsMetrics: DocsMetrics;
  DomainName: DomainName;
  DomainNameAddInput: DomainNameAddInput;
  EditContext: EditContext;
  EditInput: EditInput;
  EditUserContext: EditUserContext;
  ElasticSearchMetrics: ElasticSearchMetrics;
  EmailAddr: EmailAddr;
  EmailAddrAddInput: EmailAddrAddInput;
  EmailMessage: EmailMessage;
  EmailMessageAddInput: EmailMessageAddInput;
  EmailMimePartType: EmailMimePartType;
  EmailMimePartTypeAddInput: EmailMimePartTypeAddInput;
  ExternalReference: ExternalReference;
  ExternalReferenceAddInput: ExternalReferenceAddInput;
  ExternalReferenceConnection: ExternalReferenceConnection;
  ExternalReferenceEdge: ExternalReferenceEdge;
  ExternalReferenceEditMutations: ExternalReferenceEditMutations;
  ExternalReferencesFiltering: ExternalReferencesFiltering;
  File: File;
  FileConnection: FileConnection;
  FileEdge: FileEdge;
  FileMetadata: FileMetadata;
  Float: Scalars['Float'];
  GetMetrics: GetMetrics;
  Group: Group;
  GroupAddInput: GroupAddInput;
  GroupConnection: GroupConnection;
  GroupEdge: GroupEdge;
  GroupEditMutations: GroupEditMutations;
  Hash: Hash;
  HashInput: HashInput;
  HashedObservable: ResolversParentTypes['Artifact'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['X509Certificate'];
  Hostname: Hostname;
  HostnameAddInput: HostnameAddInput;
  ID: Scalars['ID'];
  IPv4Addr: IPv4Addr;
  IPv4AddrAddInput: IPv4AddrAddInput;
  IPv6Addr: IPv6Addr;
  IPv6AddrAddInput: IPv6AddrAddInput;
  IdentitiesFiltering: IdentitiesFiltering;
  Identity: ResolversParentTypes['Individual'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Sector'] | ResolversParentTypes['System'];
  IdentityAddInput: IdentityAddInput;
  IdentityConnection: IdentityConnection;
  IdentityEdge: IdentityEdge;
  IdentityEditMutations: IdentityEditMutations;
  Incident: Incident;
  IncidentAddInput: IncidentAddInput;
  IncidentConnection: IncidentConnection;
  IncidentEdge: IncidentEdge;
  IncidentEditMutations: IncidentEditMutations;
  IncidentsFiltering: IncidentsFiltering;
  IndexingMetrics: IndexingMetrics;
  Indicator: Indicator;
  IndicatorAddInput: IndicatorAddInput;
  IndicatorConnection: IndicatorConnection;
  IndicatorEdge: IndicatorEdge;
  IndicatorEditMutations: IndicatorEditMutations;
  IndicatorsFiltering: IndicatorsFiltering;
  Individual: Individual;
  IndividualAddInput: IndividualAddInput;
  IndividualConnection: IndividualConnection;
  IndividualEdge: IndividualEdge;
  IndividualEditMutations: IndividualEditMutations;
  IndividualsFiltering: IndividualsFiltering;
  Inference: Omit<Inference, 'explanation'> & { explanation: Array<Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>> };
  InferenceAttribute: InferenceAttribute;
  Infrastructure: Infrastructure;
  InfrastructureAddInput: InfrastructureAddInput;
  InfrastructureConnection: InfrastructureConnection;
  InfrastructureEdge: InfrastructureEdge;
  InfrastructureEditMutations: InfrastructureEditMutations;
  InfrastructuresFiltering: InfrastructuresFiltering;
  Int: Scalars['Int'];
  InternalObject: ResolversParentTypes['Capability'] | ResolversParentTypes['Connector'] | ResolversParentTypes['Group'] | ResolversParentTypes['Role'] | ResolversParentTypes['Settings'] | ResolversParentTypes['User'];
  InternalRelationship: InternalRelationship;
  InternalRelationshipAddInput: InternalRelationshipAddInput;
  IntrusionSet: IntrusionSet;
  IntrusionSetAddInput: IntrusionSetAddInput;
  IntrusionSetConnection: IntrusionSetConnection;
  IntrusionSetEdge: IntrusionSetEdge;
  IntrusionSetEditMutations: IntrusionSetEditMutations;
  IntrusionSetsFiltering: IntrusionSetsFiltering;
  KillChainPhase: KillChainPhase;
  KillChainPhaseAddInput: KillChainPhaseAddInput;
  KillChainPhaseConnection: KillChainPhaseConnection;
  KillChainPhaseEdge: KillChainPhaseEdge;
  KillChainPhaseEditMutations: KillChainPhaseEditMutations;
  KillChainPhasesFiltering: KillChainPhasesFiltering;
  Label: Label;
  LabelAddInput: LabelAddInput;
  LabelConnection: LabelConnection;
  LabelEdge: LabelEdge;
  LabelEditMutations: LabelEditMutations;
  LabelsFiltering: LabelsFiltering;
  ListTask: ListTask;
  ListTaskAddInput: ListTaskAddInput;
  Location: ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['Position'] | ResolversParentTypes['Region'];
  LocationAddInput: LocationAddInput;
  LocationConnection: LocationConnection;
  LocationEdge: LocationEdge;
  LocationEditMutations: LocationEditMutations;
  LocationsFiltering: LocationsFiltering;
  Log: Log;
  LogConnection: LogConnection;
  LogEdge: LogEdge;
  LogsFiltering: LogsFiltering;
  LogsWorkerConfig: LogsWorkerConfig;
  MacAddr: MacAddr;
  MacAddrAddInput: MacAddrAddInput;
  Malware: Malware;
  MalwareAddInput: MalwareAddInput;
  MalwareConnection: MalwareConnection;
  MalwareEdge: MalwareEdge;
  MalwareEditMutations: MalwareEditMutations;
  MalwaresFiltering: MalwaresFiltering;
  MarkingDefinition: MarkingDefinition;
  MarkingDefinitionAddInput: MarkingDefinitionAddInput;
  MarkingDefinitionConnection: MarkingDefinitionConnection;
  MarkingDefinitionEdge: MarkingDefinitionEdge;
  MarkingDefinitionEditMutations: MarkingDefinitionEditMutations;
  MarkingDefinitionsFiltering: MarkingDefinitionsFiltering;
  MessagesStats: MessagesStats;
  Module: Module;
  Mutation: {};
  Mutex: Mutex;
  MutexAddInput: MutexAddInput;
  NetworkTraffic: NetworkTraffic;
  NetworkTrafficAddInput: NetworkTrafficAddInput;
  Note: Note;
  NoteAddInput: NoteAddInput;
  NoteConnection: NoteConnection;
  NoteEdge: NoteEdge;
  NoteEditMutations: NoteEditMutations;
  NotesFiltering: NotesFiltering;
  Number: Number;
  ObjectTotals: ObjectTotals;
  ObservedData: ObservedData;
  ObservedDataAddInput: ObservedDataAddInput;
  ObservedDataConnection: ObservedDataConnection;
  ObservedDataEdge: ObservedDataEdge;
  ObservedDataEditMutations: ObservedDataEditMutations;
  ObservedDatasFiltering: ObservedDatasFiltering;
  Opinion: Opinion;
  OpinionAddInput: OpinionAddInput;
  OpinionConnection: OpinionConnection;
  OpinionEdge: OpinionEdge;
  OpinionEditMutations: OpinionEditMutations;
  OpinionsFiltering: OpinionsFiltering;
  Organization: Organization;
  OrganizationAddInput: OrganizationAddInput;
  OrganizationConnection: OrganizationConnection;
  OrganizationEdge: OrganizationEdge;
  OrganizationEditMutations: OrganizationEditMutations;
  OrganizationOrIndividual: ResolversParentTypes['Individual'] | ResolversParentTypes['Organization'];
  OrganizationsFiltering: OrganizationsFiltering;
  OverviewMetrics: OverviewMetrics;
  PageInfo: PageInfo;
  Position: Position;
  PositionAddInput: PositionAddInput;
  PositionConnection: PositionConnection;
  PositionEdge: PositionEdge;
  PositionEditMutations: PositionEditMutations;
  PositionsFiltering: PositionsFiltering;
  Process: Process;
  ProcessAddInput: ProcessAddInput;
  Provider: Provider;
  Query: {};
  QueryTask: QueryTask;
  QueryTaskAddInput: QueryTaskAddInput;
  QueueArguments: QueueArguments;
  QueueMetrics: QueueMetrics;
  QueueTotals: QueueTotals;
  RabbitMQConnection: RabbitMqConnection;
  RabbitMQMetrics: RabbitMqMetrics;
  Region: Region;
  RegionAddInput: RegionAddInput;
  RegionConnection: RegionConnection;
  RegionEdge: RegionEdge;
  RegionEditMutations: RegionEditMutations;
  RegionsFiltering: RegionsFiltering;
  RegisterConnectorInput: RegisterConnectorInput;
  Report: Report;
  ReportAddInput: ReportAddInput;
  ReportConnection: ReportConnection;
  ReportEdge: ReportEdge;
  ReportEditMutations: ReportEditMutations;
  ReportsFiltering: ReportsFiltering;
  RetentionRule: RetentionRule;
  RetentionRuleAddInput: RetentionRuleAddInput;
  RetentionRuleConnection: RetentionRuleConnection;
  RetentionRuleEdge: RetentionRuleEdge;
  RetentionRuleEditMutations: RetentionRuleEditMutations;
  Role: Role;
  RoleAddInput: RoleAddInput;
  RoleConnection: RoleConnection;
  RoleEdge: RoleEdge;
  RoleEditMutations: RoleEditMutations;
  Rule: Rule;
  RuleExecutionError: RuleExecutionError;
  RuleManager: RuleManager;
  RuleTask: RuleTask;
  SearchMetrics: SearchMetrics;
  Sector: Sector;
  SectorAddInput: SectorAddInput;
  SectorConnection: SectorConnection;
  SectorEdge: SectorEdge;
  SectorEditMutations: SectorEditMutations;
  SectorsFiltering: SectorsFiltering;
  SessionDetail: SessionDetail;
  Settings: Settings;
  SettingsEditMutations: SettingsEditMutations;
  Software: Software;
  SoftwareAddInput: SoftwareAddInput;
  Status: Status;
  StatusAddInput: StatusAddInput;
  StatusConnection: StatusConnection;
  StatusEdge: StatusEdge;
  StatusTemplate: StatusTemplate;
  StatusTemplateConnection: StatusTemplateConnection;
  StatusTemplateEdge: StatusTemplateEdge;
  StatusesFiltering: StatusesFiltering;
  StixCoreObject: ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  StixCoreObjectConnection: StixCoreObjectConnection;
  StixCoreObjectEdge: StixCoreObjectEdge;
  StixCoreObjectEditMutations: StixCoreObjectEditMutations;
  StixCoreObjectOrStixCoreRelationship: ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  StixCoreObjectsFiltering: StixCoreObjectsFiltering;
  StixCoreRelationship: Omit<StixCoreRelationship, 'from' | 'to'> & { from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixCoreRelationshipAddInput: StixCoreRelationshipAddInput;
  StixCoreRelationshipConnection: StixCoreRelationshipConnection;
  StixCoreRelationshipEdge: StixCoreRelationshipEdge;
  StixCoreRelationshipEditMutations: StixCoreRelationshipEditMutations;
  StixCoreRelationshipsFiltering: StixCoreRelationshipsFiltering;
  StixCyberObservable: ResolversParentTypes['Artifact'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Process'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['Text'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  StixCyberObservableConnection: StixCyberObservableConnection;
  StixCyberObservableEdge: StixCyberObservableEdge;
  StixCyberObservableEditMutations: StixCyberObservableEditMutations;
  StixCyberObservableRelationship: Omit<StixCyberObservableRelationship, 'from' | 'to'> & { from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixCyberObservableRelationshipAddInput: StixCyberObservableRelationshipAddInput;
  StixCyberObservableRelationshipConnection: StixCyberObservableRelationshipConnection;
  StixCyberObservableRelationshipEdge: StixCyberObservableRelationshipEdge;
  StixCyberObservableRelationshipEditMutations: StixCyberObservableRelationshipEditMutations;
  StixCyberObservableRelationshipsFiltering: StixCyberObservableRelationshipsFiltering;
  StixCyberObservablesFiltering: StixCyberObservablesFiltering;
  StixDomainObject: ResolversParentTypes['AttackPattern'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['Malware'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['System'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Vulnerability'];
  StixDomainObjectAddInput: StixDomainObjectAddInput;
  StixDomainObjectConnection: StixDomainObjectConnection;
  StixDomainObjectEdge: StixDomainObjectEdge;
  StixDomainObjectEditMutations: StixDomainObjectEditMutations;
  StixDomainObjectsFiltering: StixDomainObjectsFiltering;
  StixEditMutations: StixEditMutations;
  StixFile: StixFile;
  StixFileAddInput: StixFileAddInput;
  StixMetaObject: ResolversParentTypes['ExternalReference'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['MarkingDefinition'];
  StixMetaRelationship: Omit<StixMetaRelationship, 'from' | 'to'> & { from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixMetaRelationshipAddInput: StixMetaRelationshipAddInput;
  StixMetaRelationshipConnection: StixMetaRelationshipConnection;
  StixMetaRelationshipEdge: StixMetaRelationshipEdge;
  StixMetaRelationshipsAddInput: StixMetaRelationshipsAddInput;
  StixMetaRelationshipsFiltering: StixMetaRelationshipsFiltering;
  StixObject: ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  StixObjectOrStixRelationship: ResolversParentTypes['Artifact'] | ResolversParentTypes['AttackPattern'] | ResolversParentTypes['AutonomousSystem'] | ResolversParentTypes['Campaign'] | ResolversParentTypes['City'] | ResolversParentTypes['Country'] | ResolversParentTypes['CourseOfAction'] | ResolversParentTypes['CryptocurrencyWallet'] | ResolversParentTypes['CryptographicKey'] | ResolversParentTypes['Directory'] | ResolversParentTypes['DomainName'] | ResolversParentTypes['EmailAddr'] | ResolversParentTypes['EmailMessage'] | ResolversParentTypes['EmailMimePartType'] | ResolversParentTypes['ExternalReference'] | ResolversParentTypes['Hostname'] | ResolversParentTypes['IPv4Addr'] | ResolversParentTypes['IPv6Addr'] | ResolversParentTypes['Incident'] | ResolversParentTypes['Indicator'] | ResolversParentTypes['Individual'] | ResolversParentTypes['Infrastructure'] | ResolversParentTypes['IntrusionSet'] | ResolversParentTypes['KillChainPhase'] | ResolversParentTypes['Label'] | ResolversParentTypes['MacAddr'] | ResolversParentTypes['Malware'] | ResolversParentTypes['MarkingDefinition'] | ResolversParentTypes['Mutex'] | ResolversParentTypes['NetworkTraffic'] | ResolversParentTypes['Note'] | ResolversParentTypes['ObservedData'] | ResolversParentTypes['Opinion'] | ResolversParentTypes['Organization'] | ResolversParentTypes['Position'] | ResolversParentTypes['Process'] | ResolversParentTypes['Region'] | ResolversParentTypes['Report'] | ResolversParentTypes['Sector'] | ResolversParentTypes['Software'] | ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixFile'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'] | ResolversParentTypes['System'] | ResolversParentTypes['Text'] | ResolversParentTypes['ThreatActor'] | ResolversParentTypes['Tool'] | ResolversParentTypes['Url'] | ResolversParentTypes['UserAccount'] | ResolversParentTypes['UserAgent'] | ResolversParentTypes['Vulnerability'] | ResolversParentTypes['WindowsRegistryKey'] | ResolversParentTypes['WindowsRegistryValueType'] | ResolversParentTypes['X509Certificate'] | ResolversParentTypes['X509V3ExtensionsType'];
  StixObjectOrStixRelationshipConnection: StixObjectOrStixRelationshipConnection;
  StixObjectOrStixRelationshipEdge: Omit<StixObjectOrStixRelationshipEdge, 'node'> & { node: ResolversParentTypes['StixObjectOrStixRelationship'] };
  StixObjectOrStixRelationshipsFiltering: StixObjectOrStixRelationshipsFiltering;
  StixRelationship: ResolversParentTypes['StixCoreRelationship'] | ResolversParentTypes['StixCyberObservableRelationship'] | ResolversParentTypes['StixMetaRelationship'] | ResolversParentTypes['StixSightingRelationship'];
  StixRelationshipConnection: StixRelationshipConnection;
  StixRelationshipEdge: StixRelationshipEdge;
  StixRelationshipEditMutations: StixRelationshipEditMutations;
  StixRelationshipsFiltering: StixRelationshipsFiltering;
  StixSightingRelationship: Omit<StixSightingRelationship, 'from' | 'to'> & { from?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']>, to?: Maybe<ResolversParentTypes['StixObjectOrStixRelationship']> };
  StixSightingRelationshipAddInput: StixSightingRelationshipAddInput;
  StixSightingRelationshipConnection: StixSightingRelationshipConnection;
  StixSightingRelationshipEditMutations: StixSightingRelationshipEditMutations;
  StixSightingRelationshipsEdge: StixSightingRelationshipsEdge;
  StixSightingRelationshipsFiltering: StixSightingRelationshipsFiltering;
  StreamCollection: StreamCollection;
  StreamCollectionAddInput: StreamCollectionAddInput;
  StreamCollectionConnection: StreamCollectionConnection;
  StreamCollectionEdge: StreamCollectionEdge;
  StreamCollectionEditMutations: StreamCollectionEditMutations;
  String: Scalars['String'];
  SubType: SubType;
  SubTypeConnection: SubTypeConnection;
  SubTypeEdge: SubTypeEdge;
  SubTypeEditMutations: SubTypeEditMutations;
  Subscription: {};
  Synchronizer: Synchronizer;
  SynchronizerAddInput: SynchronizerAddInput;
  SynchronizerConnection: SynchronizerConnection;
  SynchronizerEdge: SynchronizerEdge;
  SynchronizerEditMutations: SynchronizerEditMutations;
  System: System;
  SystemAddInput: SystemAddInput;
  SystemConnection: SystemConnection;
  SystemEdge: SystemEdge;
  SystemEditMutations: SystemEditMutations;
  SystemsFiltering: SystemsFiltering;
  Task: ResolversParentTypes['ListTask'] | ResolversParentTypes['QueryTask'] | ResolversParentTypes['RuleTask'];
  TaskAction: TaskAction;
  TaskActionInput: TaskActionInput;
  TaskConnection: TaskConnection;
  TaskConnectionEdge: TaskConnectionEdge;
  TaskContext: TaskContext;
  TaskContextInput: TaskContextInput;
  TaskError: TaskError;
  TasksFiltering: TasksFiltering;
  TaxiiCollection: TaxiiCollection;
  TaxiiCollectionAddInput: TaxiiCollectionAddInput;
  TaxiiCollectionConnection: TaxiiCollectionConnection;
  TaxiiCollectionEdge: TaxiiCollectionEdge;
  TaxiiCollectionEditMutations: TaxiiCollectionEditMutations;
  Text: Text;
  TextAddInput: TextAddInput;
  ThreatActor: ThreatActor;
  ThreatActorAddInput: ThreatActorAddInput;
  ThreatActorConnection: ThreatActorConnection;
  ThreatActorEdge: ThreatActorEdge;
  ThreatActorEditMutations: ThreatActorEditMutations;
  ThreatActorsFiltering: ThreatActorsFiltering;
  TimeSeries: TimeSeries;
  Tool: Tool;
  ToolAddInput: ToolAddInput;
  ToolConnection: ToolConnection;
  ToolEdge: ToolEdge;
  ToolEditMutations: ToolEditMutations;
  ToolsFiltering: ToolsFiltering;
  Upload: Scalars['Upload'];
  Url: Url;
  UrlAddInput: UrlAddInput;
  User: User;
  UserAccount: UserAccount;
  UserAccountAddInput: UserAccountAddInput;
  UserAddInput: UserAddInput;
  UserAgent: UserAgent;
  UserAgentAddInput: UserAgentAddInput;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserEditMutations: UserEditMutations;
  UserLoginInput: UserLoginInput;
  UserSession: UserSession;
  UserSubscription: UserSubscription;
  UserSubscriptionAddInput: UserSubscriptionAddInput;
  UserSubscriptionConnection: UserSubscriptionConnection;
  UserSubscriptionEdge: UserSubscriptionEdge;
  UserSubscriptionEditMutations: UserSubscriptionEditMutations;
  UsersFiltering: UsersFiltering;
  VulnerabilitiesFiltering: VulnerabilitiesFiltering;
  Vulnerability: Vulnerability;
  VulnerabilityAddInput: VulnerabilityAddInput;
  VulnerabilityConnection: VulnerabilityConnection;
  VulnerabilityEdge: VulnerabilityEdge;
  VulnerabilityEditMutations: VulnerabilityEditMutations;
  WindowsRegistryKey: WindowsRegistryKey;
  WindowsRegistryKeyAddInput: WindowsRegistryKeyAddInput;
  WindowsRegistryValueType: WindowsRegistryValueType;
  WindowsRegistryValueTypeAddInput: WindowsRegistryValueTypeAddInput;
  Work: Work;
  WorkConnection: WorkConnection;
  WorkEdge: WorkEdge;
  WorkEditMutations: WorkEditMutations;
  WorkErrorInput: WorkErrorInput;
  WorkMessage: WorkMessage;
  WorkTracking: WorkTracking;
  WorksFiltering: WorksFiltering;
  Workspace: Workspace;
  WorkspaceAddInput: WorkspaceAddInput;
  WorkspaceConnection: WorkspaceConnection;
  WorkspaceEdge: WorkspaceEdge;
  WorkspaceEditMutations: WorkspaceEditMutations;
  WorkspacesFiltering: WorkspacesFiltering;
  X509Certificate: X509Certificate;
  X509CertificateAddInput: X509CertificateAddInput;
  X509V3ExtensionsType: X509V3ExtensionsType;
  X509V3ExtensionsTypeAddInput: X509V3ExtensionsTypeAddInput;
};

export type AuthDirectiveArgs = {
  and?: Maybe<Scalars['Boolean']>;
  for?: Maybe<Array<Maybe<Capabilities>>>;
};

export type AuthDirectiveResolver<Result, Parent, ContextType = any, Args = AuthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type ConstraintDirectiveArgs = {
  endsWith?: Maybe<Scalars['String']>;
  exclusiveMax?: Maybe<Scalars['Int']>;
  exclusiveMin?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
  max?: Maybe<Scalars['Int']>;
  maxLength?: Maybe<Scalars['Int']>;
  min?: Maybe<Scalars['Int']>;
  minLength?: Maybe<Scalars['Int']>;
  multipleOf?: Maybe<Scalars['Int']>;
  notContains?: Maybe<Scalars['String']>;
  pattern?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
};

export type ConstraintDirectiveResolver<Result, Parent, ContextType = any, Args = ConstraintDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AckDetailsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AckDetails'] = ResolversParentTypes['AckDetails']> = {
  rate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppDebugDistributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDebugDistribution'] = ResolversParentTypes['AppDebugDistribution']> = {
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppDebugStatisticsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDebugStatistics'] = ResolversParentTypes['AppDebugStatistics']> = {
  objects?: Resolver<Maybe<Array<Maybe<ResolversTypes['AppDebugDistribution']>>>, ParentType, ContextType>;
  relationships?: Resolver<Maybe<Array<Maybe<ResolversTypes['AppDebugDistribution']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppInfo'] = ResolversParentTypes['AppInfo']> = {
  debugStats?: Resolver<Maybe<ResolversTypes['AppDebugStatistics']>, ParentType, ContextType>;
  dependencies?: Resolver<Array<ResolversTypes['DependencyVersion']>, ParentType, ContextType>;
  memory?: Resolver<Maybe<ResolversTypes['AppMemory']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppMemoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppMemory'] = ResolversParentTypes['AppMemory']> = {
  arrayBuffers?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  does_zap_garbage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heapTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heapUsed?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  heap_size_limit?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  malloced_memory?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  peak_malloced_memory?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  rss?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_available_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_heap_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_heap_size_executable?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  total_physical_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  used_heap_size?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArtifactResolvers<ContextType = any, ParentType extends ResolversParentTypes['Artifact'] = ResolversParentTypes['Artifact']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ArtifactConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  decryption_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  encryption_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ArtifactExternalReferencesArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<ArtifactIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ArtifactJobsArgs>>;
  mime_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ArtifactNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ArtifactOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  payload_bin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ArtifactPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ArtifactReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ArtifactStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<ArtifactStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_additional_names?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttackPatternResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPattern'] = ResolversParentTypes['AttackPattern']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<AttackPatternConnectorsArgs>>;
  coursesOfAction?: Resolver<Maybe<ResolversTypes['CourseOfActionConnection']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<AttackPatternExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternImportFilesArgs>>;
  isSubAttackPattern?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<AttackPatternJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<AttackPatternNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<AttackPatternOpinionsArgs>>;
  parentAttackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AttackPatternPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<AttackPatternReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<AttackPatternStixCoreRelationshipsArgs>>;
  subAttackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_detection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_mitre_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_mitre_permissions_required?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_mitre_platforms?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttackPatternConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternConnection'] = ResolversParentTypes['AttackPatternConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['AttackPatternEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttackPatternEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternEdge'] = ResolversParentTypes['AttackPatternEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AttackPattern'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttackPatternEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttackPatternEditMutations'] = ResolversParentTypes['AttackPatternEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<AttackPatternEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, RequireFields<AttackPatternEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<AttackPatternEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, RequireFields<AttackPatternEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attribute'] = ResolversParentTypes['Attribute']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeConnection'] = ResolversParentTypes['AttributeConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['AttributeEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeEdge'] = ResolversParentTypes['AttributeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Attribute'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeEditMutations'] = ResolversParentTypes['AttributeEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType, RequireFields<AttributeEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AutonomousSystemResolvers<ContextType = any, ParentType extends ResolversParentTypes['AutonomousSystem'] = ResolversParentTypes['AutonomousSystem']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<AutonomousSystemConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<AutonomousSystemExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<AutonomousSystemIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<AutonomousSystemJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<AutonomousSystemNotesArgs>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<AutonomousSystemOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<AutonomousSystemPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<AutonomousSystemReportsArgs>>;
  rir?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<AutonomousSystemStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<AutonomousSystemStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BasicObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['BasicObject'] = ResolversParentTypes['BasicObject']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'Campaign' | 'Capability' | 'City' | 'Connector' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'ExternalReference' | 'Group' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'Mutex' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Process' | 'Region' | 'Report' | 'Role' | 'Sector' | 'Settings' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'User' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type BasicRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['BasicRelationship'] = ResolversParentTypes['BasicRelationship']> = {
  __resolveType: TypeResolveFn<'InternalRelationship' | 'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixMetaRelationship' | 'StixSightingRelationship', ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
};

export type CampaignResolvers<ContextType = any, ParentType extends ResolversParentTypes['Campaign'] = ResolversParentTypes['Campaign']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CampaignConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CampaignExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CampaignJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CampaignNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objective?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CampaignOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CampaignPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CampaignReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CampaignStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CampaignConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignConnection'] = ResolversParentTypes['CampaignConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CampaignEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CampaignEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignEdge'] = ResolversParentTypes['CampaignEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Campaign'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CampaignEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CampaignEditMutations'] = ResolversParentTypes['CampaignEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<CampaignEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, RequireFields<CampaignEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CampaignEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, RequireFields<CampaignEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CapabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Capability'] = ResolversParentTypes['Capability']> = {
  attribute_order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CapabilityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CapabilityConnection'] = ResolversParentTypes['CapabilityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CapabilityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CapabilityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CapabilityEdge'] = ResolversParentTypes['CapabilityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Capability'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CityResolvers<ContextType = any, ParentType extends ResolversParentTypes['City'] = ResolversParentTypes['City']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CityConnectorsArgs>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CityExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CityNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CityPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CityStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityConnection'] = ResolversParentTypes['CityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityEdge'] = ResolversParentTypes['CityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['City'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CityEditMutations'] = ResolversParentTypes['CityEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<CityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<CityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, RequireFields<CityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConnectorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Connector'] = ResolversParentTypes['Connector']> = {
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  auto?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  config?: Resolver<Maybe<ResolversTypes['ConnectorConfig']>, ParentType, ContextType>;
  connector_scope?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  connector_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connector_state_reset?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  connector_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connector_user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  only_contextual?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  works?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ConnectorWorksArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConnectorConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConnectorConfig'] = ResolversParentTypes['ConnectorConfig']> = {
  connection?: Resolver<ResolversTypes['RabbitMQConnection'], ParentType, ContextType>;
  listen?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listen_exchange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  push?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  push_exchange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface ConstraintNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ConstraintNumber'], any> {
  name: 'ConstraintNumber';
}

export interface ConstraintStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ConstraintString'], any> {
  name: 'ConstraintString';
}

export type ContainerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Container'] = ResolversParentTypes['Container']> = {
  __resolveType: TypeResolveFn<'Note' | 'ObservedData' | 'Opinion' | 'Report', ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ContainerExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ContainerNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<ContainerObjectsArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ContainerOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ContainerRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ContainerReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ContainerStixCoreRelationshipsArgs>>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type ContainerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerConnection'] = ResolversParentTypes['ContainerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ContainerEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContainerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerEdge'] = ResolversParentTypes['ContainerEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Container'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContainerEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContainerEditMutations'] = ResolversParentTypes['ContainerEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, Partial<ContainerEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, RequireFields<ContainerEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ContainerEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, RequireFields<ContainerEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContextDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContextData'] = ResolversParentTypes['ContextData']> = {
  commit?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  references?: Resolver<Maybe<Array<Maybe<ResolversTypes['ExternalReference']>>>, ParentType, ContextType>;
  to_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Country'] = ResolversParentTypes['Country']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CountryConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CountryExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CountryJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CountryNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CountryOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CountryPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CountryReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CountryStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryConnection'] = ResolversParentTypes['CountryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CountryEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryEdge'] = ResolversParentTypes['CountryEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryEditMutations'] = ResolversParentTypes['CountryEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<CountryEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<CountryEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CountryEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, RequireFields<CountryEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CourseOfActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfAction'] = ResolversParentTypes['CourseOfAction']> = {
  attackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CourseOfActionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CourseOfActionExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CourseOfActionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CourseOfActionNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CourseOfActionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CourseOfActionPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CourseOfActionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CourseOfActionStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_log_sources?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_threat_hunting?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CourseOfActionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionConnection'] = ResolversParentTypes['CourseOfActionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CourseOfActionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CourseOfActionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionEdge'] = ResolversParentTypes['CourseOfActionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CourseOfAction'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CourseOfActionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CourseOfActionEditMutations'] = ResolversParentTypes['CourseOfActionEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<CourseOfActionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, RequireFields<CourseOfActionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<CourseOfActionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, RequireFields<CourseOfActionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CryptocurrencyWalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['CryptocurrencyWallet'] = ResolversParentTypes['CryptocurrencyWallet']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CryptocurrencyWalletConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CryptocurrencyWalletJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<CryptocurrencyWalletStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CryptographicKeyResolvers<ContextType = any, ParentType extends ResolversParentTypes['CryptographicKey'] = ResolversParentTypes['CryptographicKey']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<CryptographicKeyConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<CryptographicKeyExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<CryptographicKeyIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<CryptographicKeyJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<CryptographicKeyNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<CryptographicKeyOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<CryptographicKeyPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<CryptographicKeyReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<CryptographicKeyStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<CryptographicKeyStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type DependencyVersionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DependencyVersion'] = ResolversParentTypes['DependencyVersion']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DirectoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Directory'] = ResolversParentTypes['Directory']> = {
  atime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DirectoryConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  ctime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DirectoryExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<DirectoryIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DirectoryJobsArgs>>;
  mtime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DirectoryNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DirectoryOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path_enc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DirectoryPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DirectoryReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DirectoryStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<DirectoryStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DistributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Distribution'] = ResolversParentTypes['Distribution']> = {
  entity?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DocsMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocsMetrics'] = ResolversParentTypes['DocsMetrics']> = {
  count?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DomainNameResolvers<ContextType = any, ParentType extends ResolversParentTypes['DomainName'] = ResolversParentTypes['DomainName']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<DomainNameConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNameExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<DomainNameExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNameImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<DomainNameIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<DomainNameJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<DomainNameNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<DomainNameOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<DomainNamePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<DomainNameReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<DomainNameStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<DomainNameStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EditUserContextResolvers<ContextType = any, ParentType extends ResolversParentTypes['EditUserContext'] = ResolversParentTypes['EditUserContext']> = {
  focusOn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElasticSearchMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElasticSearchMetrics'] = ResolversParentTypes['ElasticSearchMetrics']> = {
  docs?: Resolver<Maybe<ResolversTypes['DocsMetrics']>, ParentType, ContextType>;
  get?: Resolver<Maybe<ResolversTypes['GetMetrics']>, ParentType, ContextType>;
  indexing?: Resolver<Maybe<ResolversTypes['IndexingMetrics']>, ParentType, ContextType>;
  search?: Resolver<Maybe<ResolversTypes['SearchMetrics']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmailAddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailAddr'] = ResolversParentTypes['EmailAddr']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailAddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  display_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailAddrExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailAddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailAddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailAddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailAddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailAddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailAddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailAddrStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailAddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmailMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailMessage'] = ResolversParentTypes['EmailMessage']> = {
  attribute_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailMessageConnectorsArgs>>;
  content_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessageExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailMessageExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessageImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailMessageIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_multipart?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailMessageJobsArgs>>;
  message_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailMessageNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailMessageOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMessagePendingFilesArgs>>;
  received_lines?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailMessageReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailMessageStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailMessageStixCyberObservableRelationshipsArgs>>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmailMimePartTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailMimePartType'] = ResolversParentTypes['EmailMimePartType']> = {
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<EmailMimePartTypeConnectorsArgs>>;
  content_disposition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<EmailMimePartTypeJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<EmailMimePartTypePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<EmailMimePartTypeStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalReferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReference'] = ResolversParentTypes['ExternalReference']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ExternalReferenceConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferenceExportFilesArgs>>;
  external_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferenceImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ExternalReferenceJobsArgs>>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ExternalReferencePendingFilesArgs>>;
  references?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<ExternalReferenceReferencesArgs>>;
  source_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalReferenceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceConnection'] = ResolversParentTypes['ExternalReferenceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ExternalReferenceEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalReferenceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceEdge'] = ResolversParentTypes['ExternalReferenceEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ExternalReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalReferenceEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalReferenceEditMutations'] = ResolversParentTypes['ExternalReferenceEditMutations']> = {
  askEnrichment?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsAskEnrichmentArgs, 'connectorId'>>;
  contextClean?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, Partial<ExternalReferenceEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsImportPushArgs, 'file'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ExternalReferenceEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<ExternalReferenceEditMutationsRelationDeleteArgs, 'fromId' | 'relationship_type'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<ContextType = any, ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastModifiedSinceMin?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  metaData?: Resolver<Maybe<ResolversTypes['FileMetadata']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  uploadStatus?: Resolver<ResolversTypes['State'], ParentType, ContextType>;
  works?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileConnection'] = ResolversParentTypes['FileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['FileEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileEdge'] = ResolversParentTypes['FileEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['File'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileMetadata'] = ResolversParentTypes['FileMetadata']> = {
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType>;
  entity_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  list_filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  mimetype?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GetMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['GetMetrics'] = ResolversParentTypes['GetMetrics']> = {
  total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['Group'] = ResolversParentTypes['Group']> = {
  allowed_marking?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarkingDefinition']>>>, ParentType, ContextType>;
  auto_new_marking?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  default_assignation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  members?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupConnection'] = ResolversParentTypes['GroupConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupEdge'] = ResolversParentTypes['GroupEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupEditMutations'] = ResolversParentTypes['GroupEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, Partial<GroupEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<GroupEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<GroupEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<GroupEditMutationsRelationDeleteArgs, 'relationship_type'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HashResolvers<ContextType = any, ParentType extends ResolversParentTypes['Hash'] = ResolversParentTypes['Hash']> = {
  algorithm?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HashedObservableResolvers<ContextType = any, ParentType extends ResolversParentTypes['HashedObservable'] = ResolversParentTypes['HashedObservable']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'StixFile' | 'X509Certificate', ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<HashedObservableConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservableExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<HashedObservableExternalReferencesArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservableImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<HashedObservableIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<HashedObservableJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<HashedObservableNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<HashedObservableOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HashedObservablePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<HashedObservableReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<HashedObservableStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<HashedObservableStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type HostnameResolvers<ContextType = any, ParentType extends ResolversParentTypes['Hostname'] = ResolversParentTypes['Hostname']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<HostnameConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnameExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<HostnameExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnameImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<HostnameIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<HostnameJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<HostnameNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<HostnameOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<HostnamePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<HostnameReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<HostnameStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<HostnameStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IPv4AddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['IPv4Addr'] = ResolversParentTypes['IPv4Addr']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IPv4AddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IPv4AddrExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<IPv4AddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IPv4AddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IPv4AddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IPv4AddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv4AddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IPv4AddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IPv4AddrStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<IPv4AddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IPv6AddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['IPv6Addr'] = ResolversParentTypes['IPv6Addr']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IPv6AddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IPv6AddrExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<IPv6AddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IPv6AddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IPv6AddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IPv6AddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IPv6AddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IPv6AddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IPv6AddrStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<IPv6AddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IdentityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Identity'] = ResolversParentTypes['Identity']> = {
  __resolveType: TypeResolveFn<'Individual' | 'Organization' | 'Sector' | 'System', ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IdentityConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IdentityExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IdentityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IdentityNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IdentityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IdentityPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IdentityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IdentityStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type IdentityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityConnection'] = ResolversParentTypes['IdentityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IdentityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IdentityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityEdge'] = ResolversParentTypes['IdentityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Identity'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IdentityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IdentityEditMutations'] = ResolversParentTypes['IdentityEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, Partial<IdentityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<IdentityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IdentityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<IdentityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IncidentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Incident'] = ResolversParentTypes['Incident']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IncidentConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IncidentExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IncidentJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IncidentNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objective?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IncidentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IncidentPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IncidentReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IncidentStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IncidentConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentConnection'] = ResolversParentTypes['IncidentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IncidentEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IncidentEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentEdge'] = ResolversParentTypes['IncidentEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Incident'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IncidentEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncidentEditMutations'] = ResolversParentTypes['IncidentEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<IncidentEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, RequireFields<IncidentEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IncidentEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, RequireFields<IncidentEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndexingMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndexingMetrics'] = ResolversParentTypes['IndexingMetrics']> = {
  delete_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndicatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Indicator'] = ResolversParentTypes['Indicator']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IndicatorConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IndicatorExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorImportFilesArgs>>;
  indicator_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IndicatorJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IndicatorNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observables?: Resolver<Maybe<ResolversTypes['StixCyberObservableConnection']>, ParentType, ContextType, Partial<IndicatorObservablesArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IndicatorOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pattern?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern_version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndicatorPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IndicatorReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IndicatorStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  valid_from?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  valid_until?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_mitre_platforms?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_detection?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_main_observable_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndicatorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorConnection'] = ResolversParentTypes['IndicatorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndicatorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndicatorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorEdge'] = ResolversParentTypes['IndicatorEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Indicator'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndicatorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndicatorEditMutations'] = ResolversParentTypes['IndicatorEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, Partial<IndicatorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<IndicatorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IndicatorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<IndicatorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualResolvers<ContextType = any, ParentType extends ResolversParentTypes['Individual'] = ResolversParentTypes['Individual']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IndividualConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IndividualExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IndividualJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IndividualNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IndividualOpinionsArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IndividualPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IndividualReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IndividualStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualConnection'] = ResolversParentTypes['IndividualConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndividualEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualEdge'] = ResolversParentTypes['IndividualEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Individual'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualEditMutations'] = ResolversParentTypes['IndividualEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, Partial<IndividualEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<IndividualEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IndividualEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<IndividualEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Inference'] = ResolversParentTypes['Inference']> = {
  attributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['InferenceAttribute']>>>, ParentType, ContextType>;
  explanation?: Resolver<Array<Maybe<ResolversTypes['StixObjectOrStixRelationship']>>, ParentType, ContextType>;
  rule?: Resolver<ResolversTypes['Rule'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InferenceAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InferenceAttribute'] = ResolversParentTypes['InferenceAttribute']> = {
  field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InfrastructureResolvers<ContextType = any, ParentType extends ResolversParentTypes['Infrastructure'] = ResolversParentTypes['Infrastructure']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<InfrastructureConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructureExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<InfrastructureExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructureImportFilesArgs>>;
  infrastructure_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<InfrastructureJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<InfrastructureNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<InfrastructureOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<InfrastructurePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<InfrastructureReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<InfrastructureStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InfrastructureConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureConnection'] = ResolversParentTypes['InfrastructureConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['InfrastructureEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InfrastructureEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureEdge'] = ResolversParentTypes['InfrastructureEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Infrastructure'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InfrastructureEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['InfrastructureEditMutations'] = ResolversParentTypes['InfrastructureEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, Partial<InfrastructureEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<InfrastructureEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<InfrastructureEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<InfrastructureEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InternalObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['InternalObject'] = ResolversParentTypes['InternalObject']> = {
  __resolveType: TypeResolveFn<'Capability' | 'Connector' | 'Group' | 'Role' | 'Settings' | 'User', ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type InternalRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['InternalRelationship'] = ResolversParentTypes['InternalRelationship']> = {
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['InternalObject']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['InternalObject']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntrusionSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSet'] = ResolversParentTypes['IntrusionSet']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<IntrusionSetConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<IntrusionSetExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  goals?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<IntrusionSetJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<IntrusionSetNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<IntrusionSetOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<IntrusionSetPendingFilesArgs>>;
  primary_motivation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<IntrusionSetReportsArgs>>;
  resource_level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  secondary_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<IntrusionSetStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntrusionSetConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetConnection'] = ResolversParentTypes['IntrusionSetConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['IntrusionSetEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntrusionSetEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetEdge'] = ResolversParentTypes['IntrusionSetEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['IntrusionSet'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntrusionSetEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntrusionSetEditMutations'] = ResolversParentTypes['IntrusionSetEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<IntrusionSetEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, RequireFields<IntrusionSetEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<IntrusionSetEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, RequireFields<IntrusionSetEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KillChainPhaseResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhase'] = ResolversParentTypes['KillChainPhase']> = {
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  kill_chain_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  phase_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KillChainPhaseConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseConnection'] = ResolversParentTypes['KillChainPhaseConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['KillChainPhaseEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KillChainPhaseEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseEdge'] = ResolversParentTypes['KillChainPhaseEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['KillChainPhase'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KillChainPhaseEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['KillChainPhaseEditMutations'] = ResolversParentTypes['KillChainPhaseEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, Partial<KillChainPhaseEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<KillChainPhaseEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<KillChainPhaseEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<KillChainPhaseEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Label'] = ResolversParentTypes['Label']> = {
  color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelConnection'] = ResolversParentTypes['LabelConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LabelEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelEdge'] = ResolversParentTypes['LabelEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Label'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelEditMutations'] = ResolversParentTypes['LabelEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, Partial<LabelEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, RequireFields<LabelEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ListTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['ListTask'] = ResolversParentTypes['ListTask']> = {
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_ids?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Location'] = ResolversParentTypes['Location']> = {
  __resolveType: TypeResolveFn<'City' | 'Country' | 'Position' | 'Region', ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<LocationConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<LocationExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<LocationJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<LocationNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<LocationOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<LocationPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<LocationReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<LocationStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type LocationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationConnection'] = ResolversParentTypes['LocationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LocationEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationEdge'] = ResolversParentTypes['LocationEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Location'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocationEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocationEditMutations'] = ResolversParentTypes['LocationEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, Partial<LocationEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<LocationEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<LocationEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<LocationEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogResolvers<ContextType = any, ParentType extends ResolversParentTypes['Log'] = ResolversParentTypes['Log']> = {
  context_data?: Resolver<Maybe<ResolversTypes['ContextData']>, ParentType, ContextType>;
  event_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  user_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogConnection'] = ResolversParentTypes['LogConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['LogEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogEdge'] = ResolversParentTypes['LogEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Log'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogsWorkerConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogsWorkerConfig'] = ResolversParentTypes['LogsWorkerConfig']> = {
  elasticsearch_api_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  elasticsearch_password?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_proxy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elasticsearch_ssl_reject_unauthorized?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  elasticsearch_url?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  elasticsearch_username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MacAddrResolvers<ContextType = any, ParentType extends ResolversParentTypes['MacAddr'] = ResolversParentTypes['MacAddr']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MacAddrConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MacAddrExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<MacAddrIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MacAddrJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MacAddrNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MacAddrOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MacAddrPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MacAddrReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MacAddrStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<MacAddrStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MalwareResolvers<ContextType = any, ParentType extends ResolversParentTypes['Malware'] = ResolversParentTypes['Malware']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  architecture_execution_envs?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  capabilities?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MalwareConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwareExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MalwareExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  implementation_languages?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwareImportFilesArgs>>;
  is_family?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MalwareJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  malware_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MalwareNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MalwareOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MalwarePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MalwareReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MalwareStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MalwareConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareConnection'] = ResolversParentTypes['MalwareConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MalwareEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MalwareEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareEdge'] = ResolversParentTypes['MalwareEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Malware'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MalwareEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MalwareEditMutations'] = ResolversParentTypes['MalwareEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<MalwareEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, RequireFields<MalwareEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<MalwareEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, RequireFields<MalwareEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkingDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinition'] = ResolversParentTypes['MarkingDefinition']> = {
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  definition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  definition_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkingDefinitionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionConnection'] = ResolversParentTypes['MarkingDefinitionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarkingDefinitionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkingDefinitionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionEdge'] = ResolversParentTypes['MarkingDefinitionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MarkingDefinition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkingDefinitionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkingDefinitionEditMutations'] = ResolversParentTypes['MarkingDefinitionEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, Partial<MarkingDefinitionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, RequireFields<MarkingDefinitionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessagesStatsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagesStats'] = ResolversParentTypes['MessagesStats']> = {
  ack?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ack_details?: Resolver<Maybe<ResolversTypes['AckDetails']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Module'] = ResolversParentTypes['Module']> = {
  enable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  artifactImport?: Resolver<Maybe<ResolversTypes['Artifact']>, ParentType, ContextType, RequireFields<MutationArtifactImportArgs, 'file'>>;
  askJobImport?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationAskJobImportArgs, 'fileName'>>;
  attackPatternAdd?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<MutationAttackPatternAddArgs>>;
  attackPatternEdit?: Resolver<Maybe<ResolversTypes['AttackPatternEditMutations']>, ParentType, ContextType, RequireFields<MutationAttackPatternEditArgs, 'id'>>;
  bookmarkAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<MutationBookmarkAddArgs, 'id' | 'type'>>;
  bookmarkDelete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationBookmarkDeleteArgs, 'id'>>;
  campaignAdd?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<MutationCampaignAddArgs>>;
  campaignEdit?: Resolver<Maybe<ResolversTypes['CampaignEditMutations']>, ParentType, ContextType, RequireFields<MutationCampaignEditArgs, 'id'>>;
  cityAdd?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<MutationCityAddArgs>>;
  cityEdit?: Resolver<Maybe<ResolversTypes['CityEditMutations']>, ParentType, ContextType, RequireFields<MutationCityEditArgs, 'id'>>;
  containerEdit?: Resolver<Maybe<ResolversTypes['ContainerEditMutations']>, ParentType, ContextType, RequireFields<MutationContainerEditArgs, 'id'>>;
  countryAdd?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<MutationCountryAddArgs>>;
  countryEdit?: Resolver<Maybe<ResolversTypes['CountryEditMutations']>, ParentType, ContextType, RequireFields<MutationCountryEditArgs, 'id'>>;
  courseOfActionAdd?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<MutationCourseOfActionAddArgs>>;
  courseOfActionEdit?: Resolver<Maybe<ResolversTypes['CourseOfActionEditMutations']>, ParentType, ContextType, RequireFields<MutationCourseOfActionEditArgs, 'id'>>;
  deleteConnector?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationDeleteConnectorArgs, 'id'>>;
  deleteImport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, Partial<MutationDeleteImportArgs>>;
  deleteTask?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationDeleteTaskArgs, 'id'>>;
  externalReferenceAdd?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, Partial<MutationExternalReferenceAddArgs>>;
  externalReferenceEdit?: Resolver<Maybe<ResolversTypes['ExternalReferenceEditMutations']>, ParentType, ContextType, RequireFields<MutationExternalReferenceEditArgs, 'id'>>;
  groupAdd?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, Partial<MutationGroupAddArgs>>;
  groupEdit?: Resolver<Maybe<ResolversTypes['GroupEditMutations']>, ParentType, ContextType, RequireFields<MutationGroupEditArgs, 'id'>>;
  identityAdd?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, Partial<MutationIdentityAddArgs>>;
  identityEdit?: Resolver<Maybe<ResolversTypes['IdentityEditMutations']>, ParentType, ContextType, RequireFields<MutationIdentityEditArgs, 'id'>>;
  incidentAdd?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<MutationIncidentAddArgs>>;
  incidentEdit?: Resolver<Maybe<ResolversTypes['IncidentEditMutations']>, ParentType, ContextType, RequireFields<MutationIncidentEditArgs, 'id'>>;
  indicatorAdd?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, Partial<MutationIndicatorAddArgs>>;
  indicatorEdit?: Resolver<Maybe<ResolversTypes['IndicatorEditMutations']>, ParentType, ContextType, RequireFields<MutationIndicatorEditArgs, 'id'>>;
  individualAdd?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, Partial<MutationIndividualAddArgs>>;
  individualEdit?: Resolver<Maybe<ResolversTypes['IndividualEditMutations']>, ParentType, ContextType, RequireFields<MutationIndividualEditArgs, 'id'>>;
  infrastructureAdd?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, Partial<MutationInfrastructureAddArgs>>;
  infrastructureEdit?: Resolver<Maybe<ResolversTypes['InfrastructureEditMutations']>, ParentType, ContextType, RequireFields<MutationInfrastructureEditArgs, 'id'>>;
  intrusionSetAdd?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<MutationIntrusionSetAddArgs>>;
  intrusionSetEdit?: Resolver<Maybe<ResolversTypes['IntrusionSetEditMutations']>, ParentType, ContextType, RequireFields<MutationIntrusionSetEditArgs, 'id'>>;
  killChainPhaseAdd?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, Partial<MutationKillChainPhaseAddArgs>>;
  killChainPhaseEdit?: Resolver<Maybe<ResolversTypes['KillChainPhaseEditMutations']>, ParentType, ContextType, RequireFields<MutationKillChainPhaseEditArgs, 'id'>>;
  labelAdd?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, Partial<MutationLabelAddArgs>>;
  labelEdit?: Resolver<Maybe<ResolversTypes['LabelEditMutations']>, ParentType, ContextType, RequireFields<MutationLabelEditArgs, 'id'>>;
  listTaskAdd?: Resolver<ResolversTypes['Task'], ParentType, ContextType, Partial<MutationListTaskAddArgs>>;
  locationAdd?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, Partial<MutationLocationAddArgs>>;
  locationEdit?: Resolver<Maybe<ResolversTypes['LocationEditMutations']>, ParentType, ContextType, RequireFields<MutationLocationEditArgs, 'id'>>;
  logout?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  malwareAdd?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<MutationMalwareAddArgs>>;
  malwareEdit?: Resolver<Maybe<ResolversTypes['MalwareEditMutations']>, ParentType, ContextType, RequireFields<MutationMalwareEditArgs, 'id'>>;
  markingDefinitionAdd?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, Partial<MutationMarkingDefinitionAddArgs>>;
  markingDefinitionEdit?: Resolver<Maybe<ResolversTypes['MarkingDefinitionEditMutations']>, ParentType, ContextType, RequireFields<MutationMarkingDefinitionEditArgs, 'id'>>;
  meEdit?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<MutationMeEditArgs, 'input'>>;
  meTokenRenew?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  noteAdd?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<MutationNoteAddArgs>>;
  noteEdit?: Resolver<Maybe<ResolversTypes['NoteEditMutations']>, ParentType, ContextType, RequireFields<MutationNoteEditArgs, 'id'>>;
  observedDataAdd?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<MutationObservedDataAddArgs>>;
  observedDataEdit?: Resolver<Maybe<ResolversTypes['ObservedDataEditMutations']>, ParentType, ContextType, RequireFields<MutationObservedDataEditArgs, 'id'>>;
  opinionAdd?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<MutationOpinionAddArgs>>;
  opinionEdit?: Resolver<Maybe<ResolversTypes['OpinionEditMutations']>, ParentType, ContextType, RequireFields<MutationOpinionEditArgs, 'id'>>;
  organizationAdd?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<MutationOrganizationAddArgs>>;
  organizationEdit?: Resolver<Maybe<ResolversTypes['OrganizationEditMutations']>, ParentType, ContextType, RequireFields<MutationOrganizationEditArgs, 'id'>>;
  pingConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<MutationPingConnectorArgs, 'id'>>;
  positionAdd?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, Partial<MutationPositionAddArgs>>;
  positionEdit?: Resolver<Maybe<ResolversTypes['PositionEditMutations']>, ParentType, ContextType, RequireFields<MutationPositionEditArgs, 'id'>>;
  queryTaskAdd?: Resolver<ResolversTypes['Task'], ParentType, ContextType, Partial<MutationQueryTaskAddArgs>>;
  regionAdd?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, Partial<MutationRegionAddArgs>>;
  regionEdit?: Resolver<Maybe<ResolversTypes['RegionEditMutations']>, ParentType, ContextType, RequireFields<MutationRegionEditArgs, 'id'>>;
  registerConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, Partial<MutationRegisterConnectorArgs>>;
  reportAdd?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<MutationReportAddArgs>>;
  reportEdit?: Resolver<Maybe<ResolversTypes['ReportEditMutations']>, ParentType, ContextType, RequireFields<MutationReportEditArgs, 'id'>>;
  resetStateConnector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<MutationResetStateConnectorArgs, 'id'>>;
  retentionRuleAdd?: Resolver<ResolversTypes['RetentionRule'], ParentType, ContextType, Partial<MutationRetentionRuleAddArgs>>;
  retentionRuleCheck?: Resolver<ResolversTypes['Int'], ParentType, ContextType, Partial<MutationRetentionRuleCheckArgs>>;
  retentionRuleEdit?: Resolver<Maybe<ResolversTypes['RetentionRuleEditMutations']>, ParentType, ContextType, RequireFields<MutationRetentionRuleEditArgs, 'id'>>;
  roleAdd?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, Partial<MutationRoleAddArgs>>;
  roleEdit?: Resolver<Maybe<ResolversTypes['RoleEditMutations']>, ParentType, ContextType, RequireFields<MutationRoleEditArgs, 'id'>>;
  ruleManagerClean?: Resolver<ResolversTypes['RuleManager'], ParentType, ContextType, Partial<MutationRuleManagerCleanArgs>>;
  ruleSetActivation?: Resolver<ResolversTypes['Rule'], ParentType, ContextType, RequireFields<MutationRuleSetActivationArgs, 'enable' | 'id'>>;
  runtimeAttributeEdit?: Resolver<ResolversTypes['ID'], ParentType, ContextType, RequireFields<MutationRuntimeAttributeEditArgs, 'current' | 'id' | 'previous'>>;
  sectorAdd?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<MutationSectorAddArgs>>;
  sectorEdit?: Resolver<Maybe<ResolversTypes['SectorEditMutations']>, ParentType, ContextType, RequireFields<MutationSectorEditArgs, 'id'>>;
  sessionKill?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType, RequireFields<MutationSessionKillArgs, 'id'>>;
  settingsEdit?: Resolver<Maybe<ResolversTypes['SettingsEditMutations']>, ParentType, ContextType, RequireFields<MutationSettingsEditArgs, 'id'>>;
  stixCoreObjectEdit?: Resolver<Maybe<ResolversTypes['StixCoreObjectEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCoreObjectEditArgs, 'id'>>;
  stixCoreRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<MutationStixCoreRelationshipAddArgs>>;
  stixCoreRelationshipDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<MutationStixCoreRelationshipDeleteArgs, 'fromId' | 'relationship_type' | 'toId'>>;
  stixCoreRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCoreRelationshipEditArgs, 'id'>>;
  stixCyberObservableAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableAddArgs, 'type'>>;
  stixCyberObservableEdit?: Resolver<Maybe<ResolversTypes['StixCyberObservableEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableEditArgs, 'id'>>;
  stixCyberObservableRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<MutationStixCyberObservableRelationshipAddArgs>>;
  stixCyberObservableRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixCyberObservableRelationshipEditArgs, 'id'>>;
  stixCyberObservablesExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixCyberObservablesExportAskArgs, 'exportType' | 'format'>>;
  stixCyberObservablesExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixCyberObservablesExportPushArgs, 'file'>>;
  stixDomainObjectAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<MutationStixDomainObjectAddArgs>>;
  stixDomainObjectEdit?: Resolver<Maybe<ResolversTypes['StixDomainObjectEditMutations']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectEditArgs, 'id'>>;
  stixDomainObjectsDelete?: Resolver<Array<Maybe<ResolversTypes['ID']>>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsDeleteArgs, 'id'>>;
  stixDomainObjectsExportAsk?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsExportAskArgs, 'exportType' | 'format' | 'type'>>;
  stixDomainObjectsExportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationStixDomainObjectsExportPushArgs, 'file' | 'type'>>;
  stixEdit?: Resolver<Maybe<ResolversTypes['StixEditMutations']>, ParentType, ContextType, RequireFields<MutationStixEditArgs, 'id'>>;
  stixRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixRelationshipEditArgs, 'id'>>;
  stixSightingRelationshipAdd?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<MutationStixSightingRelationshipAddArgs>>;
  stixSightingRelationshipEdit?: Resolver<Maybe<ResolversTypes['StixSightingRelationshipEditMutations']>, ParentType, ContextType, RequireFields<MutationStixSightingRelationshipEditArgs, 'id'>>;
  streamCollectionAdd?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, Partial<MutationStreamCollectionAddArgs>>;
  streamCollectionEdit?: Resolver<Maybe<ResolversTypes['StreamCollectionEditMutations']>, ParentType, ContextType, RequireFields<MutationStreamCollectionEditArgs, 'id'>>;
  subTypeEdit?: Resolver<Maybe<ResolversTypes['SubTypeEditMutations']>, ParentType, ContextType, RequireFields<MutationSubTypeEditArgs, 'id'>>;
  synchronizerAdd?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, Partial<MutationSynchronizerAddArgs>>;
  synchronizerEdit?: Resolver<Maybe<ResolversTypes['SynchronizerEditMutations']>, ParentType, ContextType, RequireFields<MutationSynchronizerEditArgs, 'id'>>;
  synchronizerStart?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<MutationSynchronizerStartArgs, 'id'>>;
  synchronizerStop?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<MutationSynchronizerStopArgs, 'id'>>;
  synchronizerTest?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MutationSynchronizerTestArgs>>;
  systemAdd?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<MutationSystemAddArgs>>;
  systemEdit?: Resolver<Maybe<ResolversTypes['SystemEditMutations']>, ParentType, ContextType, RequireFields<MutationSystemEditArgs, 'id'>>;
  taxiiCollectionAdd?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, Partial<MutationTaxiiCollectionAddArgs>>;
  taxiiCollectionEdit?: Resolver<Maybe<ResolversTypes['TaxiiCollectionEditMutations']>, ParentType, ContextType, RequireFields<MutationTaxiiCollectionEditArgs, 'id'>>;
  threatActorAdd?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<MutationThreatActorAddArgs>>;
  threatActorEdit?: Resolver<Maybe<ResolversTypes['ThreatActorEditMutations']>, ParentType, ContextType, RequireFields<MutationThreatActorEditArgs, 'id'>>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MutationTokenArgs>>;
  toolAdd?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<MutationToolAddArgs>>;
  toolEdit?: Resolver<Maybe<ResolversTypes['ToolEditMutations']>, ParentType, ContextType, RequireFields<MutationToolEditArgs, 'id'>>;
  uploadImport?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationUploadImportArgs, 'file'>>;
  uploadPending?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<MutationUploadPendingArgs, 'file'>>;
  userAdd?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<MutationUserAddArgs>>;
  userEdit?: Resolver<Maybe<ResolversTypes['UserEditMutations']>, ParentType, ContextType, RequireFields<MutationUserEditArgs, 'id'>>;
  userSessionsKill?: Resolver<Maybe<Array<Maybe<ResolversTypes['ID']>>>, ParentType, ContextType, RequireFields<MutationUserSessionsKillArgs, 'id'>>;
  userSubscriptionAdd?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, Partial<MutationUserSubscriptionAddArgs>>;
  userSubscriptionEdit?: Resolver<Maybe<ResolversTypes['UserSubscriptionEditMutations']>, ParentType, ContextType, RequireFields<MutationUserSubscriptionEditArgs, 'id'>>;
  vulnerabilityAdd?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<MutationVulnerabilityAddArgs>>;
  vulnerabilityEdit?: Resolver<Maybe<ResolversTypes['VulnerabilityEditMutations']>, ParentType, ContextType, RequireFields<MutationVulnerabilityEditArgs, 'id'>>;
  workAdd?: Resolver<ResolversTypes['Work'], ParentType, ContextType, RequireFields<MutationWorkAddArgs, 'connectorId'>>;
  workDelete?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<MutationWorkDeleteArgs, 'connectorId'>>;
  workEdit?: Resolver<Maybe<ResolversTypes['WorkEditMutations']>, ParentType, ContextType, RequireFields<MutationWorkEditArgs, 'id'>>;
  workspaceAdd?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<MutationWorkspaceAddArgs>>;
  workspaceEdit?: Resolver<Maybe<ResolversTypes['WorkspaceEditMutations']>, ParentType, ContextType, RequireFields<MutationWorkspaceEditArgs, 'id'>>;
};

export type MutexResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutex'] = ResolversParentTypes['Mutex']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<MutexConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<MutexExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<MutexIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<MutexJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<MutexNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<MutexOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<MutexPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<MutexReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<MutexStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<MutexStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NetworkTrafficResolvers<ContextType = any, ParentType extends ResolversParentTypes['NetworkTraffic'] = ResolversParentTypes['NetworkTraffic']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<NetworkTrafficConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  dst_byte_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dst_packets?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dst_port?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  end?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<NetworkTrafficExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<NetworkTrafficIndicatorsArgs>>;
  is_active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<NetworkTrafficJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<NetworkTrafficNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<NetworkTrafficOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NetworkTrafficPendingFilesArgs>>;
  protocols?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<NetworkTrafficReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  src_byte_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  src_packets?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  src_port?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<NetworkTrafficStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<NetworkTrafficStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Note'] = ResolversParentTypes['Note']> = {
  attribute_abstract?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authors?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<NoteConnectorsArgs>>;
  content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NoteExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<NoteExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NoteImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<NoteJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<NoteNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<NoteObjectsArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<NoteOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<NotePendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<NoteRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<NoteReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<NoteStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NoteConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteConnection'] = ResolversParentTypes['NoteConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['NoteEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NoteEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteEdge'] = ResolversParentTypes['NoteEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Note'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NoteEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['NoteEditMutations'] = ResolversParentTypes['NoteEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<NoteEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, RequireFields<NoteEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<NoteEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, RequireFields<NoteEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NumberResolvers<ContextType = any, ParentType extends ResolversParentTypes['Number'] = ResolversParentTypes['Number']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ObjectTotalsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObjectTotals'] = ResolversParentTypes['ObjectTotals']> = {
  channels?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  queues?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ObservedDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedData'] = ResolversParentTypes['ObservedData']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ObservedDataConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ObservedDataExternalReferencesArgs>>;
  first_observed?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ObservedDataJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_observed?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ObservedDataNotesArgs>>;
  number_observed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<ObservedDataObjectsArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ObservedDataOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ObservedDataPendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ObservedDataRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ObservedDataReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ObservedDataStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ObservedDataConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataConnection'] = ResolversParentTypes['ObservedDataConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ObservedDataEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ObservedDataEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataEdge'] = ResolversParentTypes['ObservedDataEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ObservedData'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ObservedDataEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObservedDataEditMutations'] = ResolversParentTypes['ObservedDataEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<ObservedDataEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, RequireFields<ObservedDataEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ObservedDataEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, RequireFields<ObservedDataEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OpinionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Opinion'] = ResolversParentTypes['Opinion']> = {
  authors?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<OpinionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  explanation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<OpinionExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<OpinionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<OpinionNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<OpinionObjectsArgs>>;
  opinion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<OpinionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OpinionPendingFilesArgs>>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<OpinionRelatedContainersArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<OpinionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<OpinionStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OpinionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionConnection'] = ResolversParentTypes['OpinionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OpinionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OpinionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionEdge'] = ResolversParentTypes['OpinionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Opinion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OpinionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpinionEditMutations'] = ResolversParentTypes['OpinionEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<OpinionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<OpinionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<OpinionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<OpinionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Organization'] = ResolversParentTypes['Organization']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<OrganizationConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<OrganizationExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<OrganizationJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<OrganizationNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<OrganizationOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<OrganizationPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<OrganizationReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  sectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<OrganizationStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_organization_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_reliability?: Resolver<Maybe<ResolversTypes['OrganizationReliability']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationConnection'] = ResolversParentTypes['OrganizationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationEdge'] = ResolversParentTypes['OrganizationEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationEditMutations'] = ResolversParentTypes['OrganizationEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<OrganizationEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<OrganizationEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<OrganizationEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, RequireFields<OrganizationEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationOrIndividualResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationOrIndividual'] = ResolversParentTypes['OrganizationOrIndividual']> = {
  __resolveType: TypeResolveFn<'Individual' | 'Organization', ParentType, ContextType>;
};

export type OverviewMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OverviewMetrics'] = ResolversParentTypes['OverviewMetrics']> = {
  message_stats?: Resolver<Maybe<ResolversTypes['MessagesStats']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  object_totals?: Resolver<Maybe<ResolversTypes['ObjectTotals']>, ParentType, ContextType>;
  queue_totals?: Resolver<Maybe<ResolversTypes['QueueTotals']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  globalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PositionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Position'] = ResolversParentTypes['Position']> = {
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<PositionConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<PositionExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<PositionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<PositionNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<PositionOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<PositionPendingFilesArgs>>;
  postal_code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<PositionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<PositionStixCoreRelationshipsArgs>>;
  street_address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PositionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionConnection'] = ResolversParentTypes['PositionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PositionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PositionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionEdge'] = ResolversParentTypes['PositionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Position'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PositionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['PositionEditMutations'] = ResolversParentTypes['PositionEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, Partial<PositionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<PositionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<PositionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<PositionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProcessResolvers<ContextType = any, ParentType extends ResolversParentTypes['Process'] = ResolversParentTypes['Process']> = {
  command_line?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ProcessConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  created_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  cwd?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  environment_variables?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ProcessExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<ProcessIndicatorsArgs>>;
  is_hidden?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ProcessJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ProcessNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ProcessOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ProcessPendingFilesArgs>>;
  pid?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ProcessReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ProcessStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<ProcessStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProviderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Provider'] = ResolversParentTypes['Provider']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  strategy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  about?: Resolver<Maybe<ResolversTypes['AppInfo']>, ParentType, ContextType>;
  attackPattern?: Resolver<Maybe<ResolversTypes['AttackPattern']>, ParentType, ContextType, Partial<QueryAttackPatternArgs>>;
  attackPatterns?: Resolver<Maybe<ResolversTypes['AttackPatternConnection']>, ParentType, ContextType, Partial<QueryAttackPatternsArgs>>;
  bookmarks?: Resolver<Maybe<ResolversTypes['StixDomainObjectConnection']>, ParentType, ContextType, Partial<QueryBookmarksArgs>>;
  campaign?: Resolver<Maybe<ResolversTypes['Campaign']>, ParentType, ContextType, Partial<QueryCampaignArgs>>;
  campaigns?: Resolver<Maybe<ResolversTypes['CampaignConnection']>, ParentType, ContextType, Partial<QueryCampaignsArgs>>;
  campaignsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryCampaignsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  capabilities?: Resolver<Maybe<ResolversTypes['CapabilityConnection']>, ParentType, ContextType, Partial<QueryCapabilitiesArgs>>;
  cities?: Resolver<Maybe<ResolversTypes['CityConnection']>, ParentType, ContextType, Partial<QueryCitiesArgs>>;
  city?: Resolver<Maybe<ResolversTypes['City']>, ParentType, ContextType, Partial<QueryCityArgs>>;
  connector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType, RequireFields<QueryConnectorArgs, 'id'>>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  connectorsForExport?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  connectorsForImport?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType>;
  container?: Resolver<Maybe<ResolversTypes['Container']>, ParentType, ContextType, Partial<QueryContainerArgs>>;
  containers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<QueryContainersArgs>>;
  containersObjectsOfObject?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, RequireFields<QueryContainersObjectsOfObjectArgs, 'id'>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType, Partial<QueryCountriesArgs>>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType, Partial<QueryCountryArgs>>;
  courseOfAction?: Resolver<Maybe<ResolversTypes['CourseOfAction']>, ParentType, ContextType, Partial<QueryCourseOfActionArgs>>;
  coursesOfAction?: Resolver<Maybe<ResolversTypes['CourseOfActionConnection']>, ParentType, ContextType, Partial<QueryCoursesOfActionArgs>>;
  elasticSearchMetrics?: Resolver<Maybe<ResolversTypes['ElasticSearchMetrics']>, ParentType, ContextType>;
  externalReference?: Resolver<Maybe<ResolversTypes['ExternalReference']>, ParentType, ContextType, RequireFields<QueryExternalReferenceArgs, 'id'>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<QueryExternalReferencesArgs>>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileArgs, 'id'>>;
  group?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<QueryGroupArgs, 'id'>>;
  groups?: Resolver<Maybe<ResolversTypes['GroupConnection']>, ParentType, ContextType, Partial<QueryGroupsArgs>>;
  identities?: Resolver<Maybe<ResolversTypes['IdentityConnection']>, ParentType, ContextType, Partial<QueryIdentitiesArgs>>;
  identity?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType, RequireFields<QueryIdentityArgs, 'id'>>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryImportFilesArgs>>;
  incident?: Resolver<Maybe<ResolversTypes['Incident']>, ParentType, ContextType, Partial<QueryIncidentArgs>>;
  incidents?: Resolver<Maybe<ResolversTypes['IncidentConnection']>, ParentType, ContextType, Partial<QueryIncidentsArgs>>;
  incidentsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryIncidentsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  indicator?: Resolver<Maybe<ResolversTypes['Indicator']>, ParentType, ContextType, RequireFields<QueryIndicatorArgs, 'id'>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<QueryIndicatorsArgs>>;
  indicatorsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryIndicatorsDistributionArgs, 'field' | 'operation'>>;
  indicatorsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryIndicatorsNumberArgs>>;
  indicatorsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryIndicatorsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  individual?: Resolver<Maybe<ResolversTypes['Individual']>, ParentType, ContextType, RequireFields<QueryIndividualArgs, 'id'>>;
  individuals?: Resolver<Maybe<ResolversTypes['IndividualConnection']>, ParentType, ContextType, Partial<QueryIndividualsArgs>>;
  infrastructure?: Resolver<Maybe<ResolversTypes['Infrastructure']>, ParentType, ContextType, RequireFields<QueryInfrastructureArgs, 'id'>>;
  infrastructures?: Resolver<Maybe<ResolversTypes['InfrastructureConnection']>, ParentType, ContextType, Partial<QueryInfrastructuresArgs>>;
  intrusionSet?: Resolver<Maybe<ResolversTypes['IntrusionSet']>, ParentType, ContextType, Partial<QueryIntrusionSetArgs>>;
  intrusionSets?: Resolver<Maybe<ResolversTypes['IntrusionSetConnection']>, ParentType, ContextType, Partial<QueryIntrusionSetsArgs>>;
  killChainPhase?: Resolver<Maybe<ResolversTypes['KillChainPhase']>, ParentType, ContextType, RequireFields<QueryKillChainPhaseArgs, 'id'>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType, Partial<QueryKillChainPhasesArgs>>;
  label?: Resolver<Maybe<ResolversTypes['Label']>, ParentType, ContextType, RequireFields<QueryLabelArgs, 'id'>>;
  labels?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType, Partial<QueryLabelsArgs>>;
  location?: Resolver<Maybe<ResolversTypes['Location']>, ParentType, ContextType, RequireFields<QueryLocationArgs, 'id'>>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType, Partial<QueryLocationsArgs>>;
  logs?: Resolver<Maybe<ResolversTypes['LogConnection']>, ParentType, ContextType, Partial<QueryLogsArgs>>;
  logsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryLogsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  logsWorkerConfig?: Resolver<Maybe<ResolversTypes['LogsWorkerConfig']>, ParentType, ContextType>;
  malware?: Resolver<Maybe<ResolversTypes['Malware']>, ParentType, ContextType, Partial<QueryMalwareArgs>>;
  malwares?: Resolver<Maybe<ResolversTypes['MalwareConnection']>, ParentType, ContextType, Partial<QueryMalwaresArgs>>;
  markingDefinition?: Resolver<Maybe<ResolversTypes['MarkingDefinition']>, ParentType, ContextType, RequireFields<QueryMarkingDefinitionArgs, 'id'>>;
  markingDefinitions?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType, Partial<QueryMarkingDefinitionsArgs>>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  myOpinion?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, RequireFields<QueryMyOpinionArgs, 'id'>>;
  note?: Resolver<Maybe<ResolversTypes['Note']>, ParentType, ContextType, Partial<QueryNoteArgs>>;
  noteContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryNoteContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<QueryNotesArgs>>;
  notesDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryNotesDistributionArgs, 'field' | 'operation'>>;
  notesNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryNotesNumberArgs>>;
  notesTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryNotesTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  observedData?: Resolver<Maybe<ResolversTypes['ObservedData']>, ParentType, ContextType, Partial<QueryObservedDataArgs>>;
  observedDataContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryObservedDataContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  observedDatas?: Resolver<Maybe<ResolversTypes['ObservedDataConnection']>, ParentType, ContextType, Partial<QueryObservedDatasArgs>>;
  observedDatasDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryObservedDatasDistributionArgs, 'field' | 'operation'>>;
  observedDatasNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryObservedDatasNumberArgs>>;
  observedDatasTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryObservedDatasTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  opinion?: Resolver<Maybe<ResolversTypes['Opinion']>, ParentType, ContextType, Partial<QueryOpinionArgs>>;
  opinionContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryOpinionContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<QueryOpinionsArgs>>;
  opinionsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryOpinionsDistributionArgs, 'field' | 'operation'>>;
  opinionsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryOpinionsNumberArgs>>;
  opinionsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryOpinionsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  organization?: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType, Partial<QueryOrganizationArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType, Partial<QueryOrganizationsArgs>>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryPendingFilesArgs>>;
  platform_theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Position']>, ParentType, ContextType, RequireFields<QueryPositionArgs, 'id'>>;
  positions?: Resolver<Maybe<ResolversTypes['PositionConnection']>, ParentType, ContextType, Partial<QueryPositionsArgs>>;
  rabbitMQMetrics?: Resolver<Maybe<ResolversTypes['RabbitMQMetrics']>, ParentType, ContextType, Partial<QueryRabbitMqMetricsArgs>>;
  region?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<QueryRegionArgs, 'id'>>;
  regions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType, Partial<QueryRegionsArgs>>;
  report?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<QueryReportArgs>>;
  reportContainsStixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryReportContainsStixObjectOrStixRelationshipArgs, 'id' | 'stixObjectOrStixRelationshipId'>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<QueryReportsArgs>>;
  reportsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryReportsDistributionArgs, 'field' | 'operation'>>;
  reportsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryReportsNumberArgs>>;
  reportsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryReportsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  retentionRule?: Resolver<Maybe<ResolversTypes['RetentionRule']>, ParentType, ContextType, RequireFields<QueryRetentionRuleArgs, 'id'>>;
  retentionRules?: Resolver<Maybe<ResolversTypes['RetentionRuleConnection']>, ParentType, ContextType, Partial<QueryRetentionRulesArgs>>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<QueryRoleArgs, 'id'>>;
  roles?: Resolver<Maybe<ResolversTypes['RoleConnection']>, ParentType, ContextType, Partial<QueryRolesArgs>>;
  rule?: Resolver<Maybe<ResolversTypes['Rule']>, ParentType, ContextType, RequireFields<QueryRuleArgs, 'id'>>;
  ruleManagerInfo?: Resolver<Maybe<ResolversTypes['RuleManager']>, ParentType, ContextType>;
  rules?: Resolver<Maybe<Array<Maybe<ResolversTypes['Rule']>>>, ParentType, ContextType>;
  runtimeAttributes?: Resolver<Maybe<ResolversTypes['AttributeConnection']>, ParentType, ContextType, RequireFields<QueryRuntimeAttributesArgs, 'attributeName'>>;
  schemaAttributes?: Resolver<Maybe<ResolversTypes['AttributeConnection']>, ParentType, ContextType, RequireFields<QuerySchemaAttributesArgs, 'elementType'>>;
  sector?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<QuerySectorArgs>>;
  sectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType, Partial<QuerySectorsArgs>>;
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserSession']>>>, ParentType, ContextType>;
  settings?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType, RequireFields<QueryStatusArgs, 'id'>>;
  statusTemplate?: Resolver<Maybe<ResolversTypes['StatusTemplate']>, ParentType, ContextType, RequireFields<QueryStatusTemplateArgs, 'id'>>;
  statusTemplates?: Resolver<Maybe<ResolversTypes['StatusTemplateConnection']>, ParentType, ContextType, Partial<QueryStatusTemplatesArgs>>;
  statuses?: Resolver<Maybe<ResolversTypes['StatusConnection']>, ParentType, ContextType, Partial<QueryStatusesArgs>>;
  stix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QueryStixArgs, 'id'>>;
  stixCoreObject?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectArgs, 'id'>>;
  stixCoreObjectOrStixCoreRelationship?: Resolver<Maybe<ResolversTypes['StixCoreObjectOrStixCoreRelationship']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectOrStixCoreRelationshipArgs, 'id'>>;
  stixCoreObjectRaw?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QueryStixCoreObjectRawArgs, 'id'>>;
  stixCoreObjects?: Resolver<Maybe<ResolversTypes['StixCoreObjectConnection']>, ParentType, ContextType, Partial<QueryStixCoreObjectsArgs>>;
  stixCoreRelationship?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipArgs>>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipsArgs>>;
  stixCoreRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixCoreRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCoreRelationshipsNumberArgs>>;
  stixCoreRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCoreRelationshipsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixCyberObservable?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<QueryStixCyberObservableArgs, 'id'>>;
  stixCyberObservableRelationship?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipsArgs>>;
  stixCyberObservableRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservableRelationshipsDistributionArgs, 'field' | 'fromId' | 'operation'>>;
  stixCyberObservableRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCyberObservableRelationshipsNumberArgs>>;
  stixCyberObservableRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservableRelationshipsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixCyberObservables?: Resolver<Maybe<ResolversTypes['StixCyberObservableConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservablesArgs>>;
  stixCyberObservablesDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixCyberObservablesDistributionArgs, 'field' | 'operation'>>;
  stixCyberObservablesExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<QueryStixCyberObservablesExportFilesArgs>>;
  stixCyberObservablesNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixCyberObservablesNumberArgs>>;
  stixCyberObservablesTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, Partial<QueryStixCyberObservablesTimeSeriesArgs>>;
  stixDomainObject?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<QueryStixDomainObjectArgs, 'id'>>;
  stixDomainObjects?: Resolver<Maybe<ResolversTypes['StixDomainObjectConnection']>, ParentType, ContextType, Partial<QueryStixDomainObjectsArgs>>;
  stixDomainObjectsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsDistributionArgs, 'field' | 'operation' | 'relationship_type'>>;
  stixDomainObjectsExportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsExportFilesArgs, 'type'>>;
  stixDomainObjectsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixDomainObjectsNumberArgs>>;
  stixDomainObjectsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixDomainObjectsTimeSeriesArgs, 'field' | 'interval' | 'operation' | 'startDate'>>;
  stixMetaRelationship?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipArgs>>;
  stixMetaRelationships?: Resolver<Maybe<ResolversTypes['StixMetaRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipsArgs>>;
  stixMetaRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixMetaRelationshipsDistributionArgs, 'field' | 'operation'>>;
  stixMetaRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixMetaRelationshipsNumberArgs>>;
  stixObjectOrStixRelationship?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType, RequireFields<QueryStixObjectOrStixRelationshipArgs, 'id'>>;
  stixRelationship?: Resolver<Maybe<ResolversTypes['StixRelationship']>, ParentType, ContextType, Partial<QueryStixRelationshipArgs>>;
  stixRelationships?: Resolver<Maybe<ResolversTypes['StixRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixRelationshipsArgs>>;
  stixSightingRelationship?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipArgs>>;
  stixSightingRelationships?: Resolver<Maybe<ResolversTypes['StixSightingRelationshipConnection']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipsArgs>>;
  stixSightingRelationshipsDistribution?: Resolver<Maybe<Array<Maybe<ResolversTypes['Distribution']>>>, ParentType, ContextType, RequireFields<QueryStixSightingRelationshipsDistributionArgs, 'field' | 'fromId' | 'operation'>>;
  stixSightingRelationshipsNumber?: Resolver<Maybe<ResolversTypes['Number']>, ParentType, ContextType, Partial<QueryStixSightingRelationshipsNumberArgs>>;
  stixSightingRelationshipsTimeSeries?: Resolver<Maybe<Array<Maybe<ResolversTypes['TimeSeries']>>>, ParentType, ContextType, RequireFields<QueryStixSightingRelationshipsTimeSeriesArgs, 'endDate' | 'field' | 'interval' | 'operation' | 'startDate'>>;
  streamCollection?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<QueryStreamCollectionArgs, 'id'>>;
  streamCollections?: Resolver<Maybe<ResolversTypes['StreamCollectionConnection']>, ParentType, ContextType, Partial<QueryStreamCollectionsArgs>>;
  subType?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<QuerySubTypeArgs, 'id'>>;
  subTypes?: Resolver<Maybe<ResolversTypes['SubTypeConnection']>, ParentType, ContextType, Partial<QuerySubTypesArgs>>;
  synchronizer?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<QuerySynchronizerArgs, 'id'>>;
  synchronizers?: Resolver<Maybe<ResolversTypes['SynchronizerConnection']>, ParentType, ContextType, Partial<QuerySynchronizersArgs>>;
  system?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<QuerySystemArgs>>;
  systems?: Resolver<Maybe<ResolversTypes['SystemConnection']>, ParentType, ContextType, Partial<QuerySystemsArgs>>;
  task?: Resolver<Maybe<ResolversTypes['Task']>, ParentType, ContextType, RequireFields<QueryTaskArgs, 'id'>>;
  tasks?: Resolver<Maybe<ResolversTypes['TaskConnection']>, ParentType, ContextType, Partial<QueryTasksArgs>>;
  taxiiCollection?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, RequireFields<QueryTaxiiCollectionArgs, 'id'>>;
  taxiiCollections?: Resolver<Maybe<ResolversTypes['TaxiiCollectionConnection']>, ParentType, ContextType, Partial<QueryTaxiiCollectionsArgs>>;
  threatActor?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<QueryThreatActorArgs>>;
  threatActors?: Resolver<Maybe<ResolversTypes['ThreatActorConnection']>, ParentType, ContextType, Partial<QueryThreatActorsArgs>>;
  tool?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<QueryToolArgs>>;
  tools?: Resolver<Maybe<ResolversTypes['ToolConnection']>, ParentType, ContextType, Partial<QueryToolsArgs>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'id'>>;
  userSubscription?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, RequireFields<QueryUserSubscriptionArgs, 'id'>>;
  userSubscriptions?: Resolver<Maybe<ResolversTypes['UserSubscriptionConnection']>, ParentType, ContextType, Partial<QueryUserSubscriptionsArgs>>;
  users?: Resolver<Maybe<ResolversTypes['UserConnection']>, ParentType, ContextType, Partial<QueryUsersArgs>>;
  vulnerabilities?: Resolver<Maybe<ResolversTypes['VulnerabilityConnection']>, ParentType, ContextType, Partial<QueryVulnerabilitiesArgs>>;
  vulnerability?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<QueryVulnerabilityArgs>>;
  work?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<QueryWorkArgs, 'id'>>;
  works?: Resolver<Maybe<ResolversTypes['WorkConnection']>, ParentType, ContextType, Partial<QueryWorksArgs>>;
  workspace?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<QueryWorkspaceArgs>>;
  workspaces?: Resolver<Maybe<ResolversTypes['WorkspaceConnection']>, ParentType, ContextType, Partial<QueryWorkspacesArgs>>;
};

export type QueryTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueryTask'] = ResolversParentTypes['QueryTask']> = {
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_filters?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_search?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueueArgumentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueArguments'] = ResolversParentTypes['QueueArguments']> = {
  config?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueueMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueMetrics'] = ResolversParentTypes['QueueMetrics']> = {
  arguments?: Resolver<Maybe<ResolversTypes['QueueArguments']>, ParentType, ContextType>;
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  idle_since?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  message_stats?: Resolver<Maybe<ResolversTypes['MessagesStats']>, ParentType, ContextType>;
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_ready?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_unacknowledged?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueueTotalsResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueueTotals'] = ResolversParentTypes['QueueTotals']> = {
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_ready?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  messages_unacknowledged?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RabbitMqConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RabbitMQConnection'] = ResolversParentTypes['RabbitMQConnection']> = {
  ca?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  host?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pass?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  port?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  use_ssl?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RabbitMqMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RabbitMQMetrics'] = ResolversParentTypes['RabbitMQMetrics']> = {
  consumers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  overview?: Resolver<Maybe<ResolversTypes['OverviewMetrics']>, ParentType, ContextType>;
  queues?: Resolver<Maybe<Array<Maybe<ResolversTypes['QueueMetrics']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Region'] = ResolversParentTypes['Region']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<RegionConnectorsArgs>>;
  countries?: Resolver<Maybe<ResolversTypes['CountryConnection']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<RegionExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionImportFilesArgs>>;
  isSubRegion?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<RegionJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<RegionNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<RegionOpinionsArgs>>;
  parentRegions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<RegionPendingFilesArgs>>;
  precision?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<RegionReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<RegionStixCoreRelationshipsArgs>>;
  subRegions?: Resolver<Maybe<ResolversTypes['RegionConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionConnection'] = ResolversParentTypes['RegionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RegionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionEdge'] = ResolversParentTypes['RegionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Region'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegionEditMutations'] = ResolversParentTypes['RegionEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, Partial<RegionEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<RegionEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<RegionEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType, RequireFields<RegionEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportResolvers<ContextType = any, ParentType extends ResolversParentTypes['Report'] = ResolversParentTypes['Report']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ReportConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ReportExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ReportJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ReportNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<ReportObjectsArgs>>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ReportOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ReportPendingFilesArgs>>;
  published?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  relatedContainers?: Resolver<Maybe<ResolversTypes['ContainerConnection']>, ParentType, ContextType, Partial<ReportRelatedContainersArgs>>;
  report_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ReportReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ReportStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportConnection'] = ResolversParentTypes['ReportConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ReportEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportEdge'] = ResolversParentTypes['ReportEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Report'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportEditMutations'] = ResolversParentTypes['ReportEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, Partial<ReportEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<ReportEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ReportEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Report']>, ParentType, ContextType, RequireFields<ReportEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RetentionRuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRule'] = ResolversParentTypes['RetentionRule']> = {
  filters?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  last_deleted_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  max_retention?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  remaining_count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RetentionRuleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleConnection'] = ResolversParentTypes['RetentionRuleConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RetentionRuleEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RetentionRuleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleEdge'] = ResolversParentTypes['RetentionRuleEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['RetentionRule'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RetentionRuleEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RetentionRuleEditMutations'] = ResolversParentTypes['RetentionRuleEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['RetentionRule']>, ParentType, ContextType, RequireFields<RetentionRuleEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = {
  capabilities?: Resolver<Maybe<Array<Maybe<ResolversTypes['Capability']>>>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  default_assignation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleConnection'] = ResolversParentTypes['RoleConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['RoleEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEdge'] = ResolversParentTypes['RoleEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEditMutations'] = ResolversParentTypes['RoleEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, Partial<RoleEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<RoleEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<RoleEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType, RequireFields<RoleEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Rule'] = ResolversParentTypes['Rule']> = {
  activated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleExecutionErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleExecutionError'] = ResolversParentTypes['RuleExecutionError']> = {
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleManagerResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleManager'] = ResolversParentTypes['RuleManager']> = {
  activated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['RuleExecutionError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastEventId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleTaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleTask'] = ResolversParentTypes['RuleTask']> = {
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  enable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  rule?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchMetricsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchMetrics'] = ResolversParentTypes['SearchMetrics']> = {
  fetch_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query_total?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SectorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sector'] = ResolversParentTypes['Sector']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SectorConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SectorExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorImportFilesArgs>>;
  isSubSector?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SectorJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SectorNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SectorOpinionsArgs>>;
  parentSectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SectorPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SectorReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SectorStixCoreRelationshipsArgs>>;
  subSectors?: Resolver<Maybe<ResolversTypes['SectorConnection']>, ParentType, ContextType>;
  targetedOrganizations?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SectorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorConnection'] = ResolversParentTypes['SectorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SectorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SectorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorEdge'] = ResolversParentTypes['SectorEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Sector'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SectorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectorEditMutations'] = ResolversParentTypes['SectorEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, Partial<SectorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, RequireFields<SectorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<SectorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Sector']>, ParentType, ContextType, RequireFields<SectorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionDetailResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionDetail'] = ResolversParentTypes['SessionDetail']> = {
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ttl?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Settings'] = ResolversParentTypes['Settings']> = {
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  platform_email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_enable_reference?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  platform_favicon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_feature_flags?: Resolver<Maybe<Array<Maybe<ResolversTypes['Module']>>>, ParentType, ContextType>;
  platform_language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_login_message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_map_tile_server_dark?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_map_tile_server_light?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_modules?: Resolver<Maybe<Array<Maybe<ResolversTypes['Module']>>>, ParentType, ContextType>;
  platform_providers?: Resolver<Maybe<Array<Maybe<ResolversTypes['Provider']>>>, ParentType, ContextType>;
  platform_reference_attachment?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  platform_theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_accent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_background?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_logo_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_nav?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_paper?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_primary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_dark_secondary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_accent?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_background?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_logo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_logo_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_nav?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_paper?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_primary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_theme_light_secondary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  platform_url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SettingsEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettingsEditMutations'] = ResolversParentTypes['SettingsEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType, Partial<SettingsEditMutationsContextPatchArgs>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Settings']>, ParentType, ContextType, RequireFields<SettingsEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SoftwareResolvers<ContextType = any, ParentType extends ResolversParentTypes['Software'] = ResolversParentTypes['Software']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SoftwareConnectorsArgs>>;
  cpe?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwareExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SoftwareExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwareImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<SoftwareIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SoftwareJobsArgs>>;
  languages?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SoftwareNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SoftwareOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SoftwarePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SoftwareReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SoftwareStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<SoftwareStixCyberObservableRelationshipsArgs>>;
  swid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vendor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusResolvers<ContextType = any, ParentType extends ResolversParentTypes['Status'] = ResolversParentTypes['Status']> = {
  disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['StatusTemplate']>, ParentType, ContextType>;
  template_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusConnection'] = ResolversParentTypes['StatusConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StatusEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusEdge'] = ResolversParentTypes['StatusEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Status'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusTemplateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplate'] = ResolversParentTypes['StatusTemplate']> = {
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusTemplateConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplateConnection'] = ResolversParentTypes['StatusTemplateConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StatusTemplateEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatusTemplateEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatusTemplateEdge'] = ResolversParentTypes['StatusTemplateEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StatusTemplate'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObject'] = ResolversParentTypes['StixCoreObject']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'Campaign' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'MacAddr' | 'Malware' | 'Mutex' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixCoreObjectConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCoreObjectExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixCoreObjectJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCoreObjectNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCoreObjectOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCoreObjectPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCoreObjectReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCoreObjectStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixCoreObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectConnection'] = ResolversParentTypes['StixCoreObjectConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCoreObjectEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectEdge'] = ResolversParentTypes['StixCoreObjectEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCoreObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreObjectEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectEditMutations'] = ResolversParentTypes['StixCoreObjectEditMutations']> = {
  askEnrichment?: Resolver<Maybe<ResolversTypes['Work']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsAskEnrichmentArgs, 'connectorId'>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsExportPushArgs, 'file'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsImportPushArgs, 'file'>>;
  merge?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsMergeArgs, 'stixCoreObjectsIds'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCoreObjectEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, RequireFields<StixCoreObjectEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixCoreObject']>, ParentType, ContextType, Partial<StixCoreObjectEditMutationsRelationsAddArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreObjectOrStixCoreRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreObjectOrStixCoreRelationship'] = ResolversParentTypes['StixCoreObjectOrStixCoreRelationship']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'Campaign' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'MacAddr' | 'Malware' | 'Mutex' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixCoreRelationship' | 'StixFile' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
};

export type StixCoreRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationship'] = ResolversParentTypes['StixCoreRelationship']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipExternalReferencesArgs>>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCoreRelationshipStixCoreRelationshipsArgs>>;
  stop_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipConnection'] = ResolversParentTypes['StixCoreRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCoreRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipEdge'] = ResolversParentTypes['StixCoreRelationshipEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCoreRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCoreRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCoreRelationshipEditMutations'] = ResolversParentTypes['StixCoreRelationshipEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, Partial<StixCoreRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCoreRelationshipEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCoreRelationship']>, ParentType, ContextType, RequireFields<StixCoreRelationshipEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservable'] = ResolversParentTypes['StixCyberObservable']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AutonomousSystem' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'MacAddr' | 'Mutex' | 'NetworkTraffic' | 'Process' | 'Software' | 'StixFile' | 'Text' | 'Url' | 'UserAccount' | 'UserAgent' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixCyberObservableConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservableExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixCyberObservableExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservableImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<StixCyberObservableIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixCyberObservableJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixCyberObservableNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixCyberObservableOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixCyberObservablePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixCyberObservableReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixCyberObservableStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<StixCyberObservableStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixCyberObservableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableConnection'] = ResolversParentTypes['StixCyberObservableConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCyberObservableEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableEdge'] = ResolversParentTypes['StixCyberObservableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCyberObservable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableEditMutations'] = ResolversParentTypes['StixCyberObservableEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsExportPushArgs, 'file'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsImportPushArgs, 'file'>>;
  promote?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, RequireFields<StixCyberObservableEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixCyberObservable']>, ParentType, ContextType, Partial<StixCyberObservableEditMutationsRelationsAddArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationship'] = ResolversParentTypes['StixCyberObservableRelationship']> = {
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  start_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  stop_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipConnection'] = ResolversParentTypes['StixCyberObservableRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixCyberObservableRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipEdge'] = ResolversParentTypes['StixCyberObservableRelationshipEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixCyberObservableRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixCyberObservableRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixCyberObservableRelationshipEditMutations'] = ResolversParentTypes['StixCyberObservableRelationshipEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, Partial<StixCyberObservableRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, ParentType, ContextType, RequireFields<StixCyberObservableRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixDomainObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObject'] = ResolversParentTypes['StixDomainObject']> = {
  __resolveType: TypeResolveFn<'AttackPattern' | 'Campaign' | 'City' | 'Country' | 'CourseOfAction' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'Malware' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Region' | 'Report' | 'Sector' | 'System' | 'ThreatActor' | 'Tool' | 'Vulnerability', ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixDomainObjectConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixDomainObjectExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixDomainObjectJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixDomainObjectNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixDomainObjectOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixDomainObjectPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixDomainObjectReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixDomainObjectStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixDomainObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectConnection'] = ResolversParentTypes['StixDomainObjectConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixDomainObjectEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixDomainObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectEdge'] = ResolversParentTypes['StixDomainObjectEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixDomainObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixDomainObjectEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixDomainObjectEditMutations'] = ResolversParentTypes['StixDomainObjectEditMutations']> = {
  changeType?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsChangeTypeArgs, 'newType'>>;
  contextClean?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  exportAsk?: Resolver<Maybe<Array<Maybe<ResolversTypes['File']>>>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsExportAskArgs, 'exportType' | 'format'>>;
  exportPush?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsExportPushArgs, 'file'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsFieldPatchArgs, 'input'>>;
  importPush?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsImportPushArgs, 'file'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, RequireFields<StixDomainObjectEditMutationsRelationDeleteArgs, 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['StixDomainObject']>, ParentType, ContextType, Partial<StixDomainObjectEditMutationsRelationsAddArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixEditMutations'] = ResolversParentTypes['StixEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixFileResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixFile'] = ResolversParentTypes['StixFile']> = {
  atime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<StixFileConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  ctime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFileExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixFileExternalReferencesArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFileImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<StixFileIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<StixFileJobsArgs>>;
  magic_number_hex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mime_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mtime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name_enc?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixFileNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixFileOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<StixFilePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixFileReportsArgs>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<StixFileStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<StixFileStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_additional_names?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixMetaObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaObject'] = ResolversParentTypes['StixMetaObject']> = {
  __resolveType: TypeResolveFn<'ExternalReference' | 'KillChainPhase' | 'Label' | 'MarkingDefinition', ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixMetaRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationship'] = ResolversParentTypes['StixMetaRelationship']> = {
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixMetaRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationshipConnection'] = ResolversParentTypes['StixMetaRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixMetaRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixMetaRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixMetaRelationshipEdge'] = ResolversParentTypes['StixMetaRelationshipEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixMetaRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObject'] = ResolversParentTypes['StixObject']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'Campaign' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'ExternalReference' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'Mutex' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixFile' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixObjectOrStixRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationship'] = ResolversParentTypes['StixObjectOrStixRelationship']> = {
  __resolveType: TypeResolveFn<'Artifact' | 'AttackPattern' | 'AutonomousSystem' | 'Campaign' | 'City' | 'Country' | 'CourseOfAction' | 'CryptocurrencyWallet' | 'CryptographicKey' | 'Directory' | 'DomainName' | 'EmailAddr' | 'EmailMessage' | 'EmailMimePartType' | 'ExternalReference' | 'Hostname' | 'IPv4Addr' | 'IPv6Addr' | 'Incident' | 'Indicator' | 'Individual' | 'Infrastructure' | 'IntrusionSet' | 'KillChainPhase' | 'Label' | 'MacAddr' | 'Malware' | 'MarkingDefinition' | 'Mutex' | 'NetworkTraffic' | 'Note' | 'ObservedData' | 'Opinion' | 'Organization' | 'Position' | 'Process' | 'Region' | 'Report' | 'Sector' | 'Software' | 'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixFile' | 'StixMetaRelationship' | 'StixSightingRelationship' | 'System' | 'Text' | 'ThreatActor' | 'Tool' | 'Url' | 'UserAccount' | 'UserAgent' | 'Vulnerability' | 'WindowsRegistryKey' | 'WindowsRegistryValueType' | 'X509Certificate' | 'X509V3ExtensionsType', ParentType, ContextType>;
};

export type StixObjectOrStixRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipConnection'] = ResolversParentTypes['StixObjectOrStixRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixObjectOrStixRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixObjectOrStixRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixObjectOrStixRelationshipEdge'] = ResolversParentTypes['StixObjectOrStixRelationshipEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixObjectOrStixRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationship'] = ResolversParentTypes['StixRelationship']> = {
  __resolveType: TypeResolveFn<'StixCoreRelationship' | 'StixCyberObservableRelationship' | 'StixMetaRelationship' | 'StixSightingRelationship', ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export type StixRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipConnection'] = ResolversParentTypes['StixRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixRelationshipEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixRelationshipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipEdge'] = ResolversParentTypes['StixRelationshipEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixRelationshipEditMutations'] = ResolversParentTypes['StixRelationshipEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixSightingRelationshipResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationship'] = ResolversParentTypes['StixSightingRelationship']> = {
  attribute_count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  from?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  fromRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  relationship_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<StixSightingRelationshipReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationship']>, ParentType, ContextType>;
  toRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_negative?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixSightingRelationshipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipConnection'] = ResolversParentTypes['StixSightingRelationshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixSightingRelationshipsEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixSightingRelationshipEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipEditMutations'] = ResolversParentTypes['StixSightingRelationshipEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, Partial<StixSightingRelationshipEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<StixSightingRelationshipEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['StixSightingRelationship']>, ParentType, ContextType, RequireFields<StixSightingRelationshipEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StixSightingRelationshipsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StixSightingRelationshipsEdge'] = ResolversParentTypes['StixSightingRelationshipsEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StixSightingRelationship'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StreamCollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollection'] = ResolversParentTypes['StreamCollection']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<Maybe<ResolversTypes['Group']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StreamCollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionConnection'] = ResolversParentTypes['StreamCollectionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['StreamCollectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StreamCollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionEdge'] = ResolversParentTypes['StreamCollectionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StreamCollection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StreamCollectionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StreamCollectionEditMutations'] = ResolversParentTypes['StreamCollectionEditMutations']> = {
  addGroup?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsAddGroupArgs, 'id'>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  deleteGroup?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsDeleteGroupArgs, 'id'>>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['StreamCollection']>, ParentType, ContextType, RequireFields<StreamCollectionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubType'] = ResolversParentTypes['SubType']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  statuses?: Resolver<Maybe<ResolversTypes['StatusConnection']>, ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubTypeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeConnection'] = ResolversParentTypes['SubTypeConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SubTypeEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubTypeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeEdge'] = ResolversParentTypes['SubTypeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SubType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubTypeEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubTypeEditMutations'] = ResolversParentTypes['SubTypeEditMutations']> = {
  statusAdd?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, Partial<SubTypeEditMutationsStatusAddArgs>>;
  statusDelete?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<SubTypeEditMutationsStatusDeleteArgs, 'statusId'>>;
  statusFieldPatch?: Resolver<Maybe<ResolversTypes['SubType']>, ParentType, ContextType, RequireFields<SubTypeEditMutationsStatusFieldPatchArgs, 'input' | 'statusId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  externalReference?: SubscriptionResolver<Maybe<ResolversTypes['ExternalReference']>, "externalReference", ParentType, ContextType, RequireFields<SubscriptionExternalReferenceArgs, 'id'>>;
  group?: SubscriptionResolver<Maybe<ResolversTypes['Group']>, "group", ParentType, ContextType, RequireFields<SubscriptionGroupArgs, 'id'>>;
  killChainPhase?: SubscriptionResolver<Maybe<ResolversTypes['KillChainPhase']>, "killChainPhase", ParentType, ContextType, RequireFields<SubscriptionKillChainPhaseArgs, 'id'>>;
  label?: SubscriptionResolver<Maybe<ResolversTypes['Label']>, "label", ParentType, ContextType, RequireFields<SubscriptionLabelArgs, 'id'>>;
  markingDefinition?: SubscriptionResolver<Maybe<ResolversTypes['MarkingDefinition']>, "markingDefinition", ParentType, ContextType, RequireFields<SubscriptionMarkingDefinitionArgs, 'id'>>;
  settings?: SubscriptionResolver<Maybe<ResolversTypes['Settings']>, "settings", ParentType, ContextType, RequireFields<SubscriptionSettingsArgs, 'id'>>;
  stixCoreObject?: SubscriptionResolver<Maybe<ResolversTypes['StixCoreObject']>, "stixCoreObject", ParentType, ContextType, RequireFields<SubscriptionStixCoreObjectArgs, 'id'>>;
  stixCoreRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixCoreRelationship']>, "stixCoreRelationship", ParentType, ContextType, RequireFields<SubscriptionStixCoreRelationshipArgs, 'id'>>;
  stixCyberObservable?: SubscriptionResolver<Maybe<ResolversTypes['StixCyberObservable']>, "stixCyberObservable", ParentType, ContextType, RequireFields<SubscriptionStixCyberObservableArgs, 'id'>>;
  stixCyberObservableRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixCyberObservableRelationship']>, "stixCyberObservableRelationship", ParentType, ContextType, RequireFields<SubscriptionStixCyberObservableRelationshipArgs, 'id'>>;
  stixDomainObject?: SubscriptionResolver<Maybe<ResolversTypes['StixDomainObject']>, "stixDomainObject", ParentType, ContextType, RequireFields<SubscriptionStixDomainObjectArgs, 'id'>>;
  stixSightingRelationship?: SubscriptionResolver<Maybe<ResolversTypes['StixSightingRelationship']>, "stixSightingRelationship", ParentType, ContextType, RequireFields<SubscriptionStixSightingRelationshipArgs, 'id'>>;
  user?: SubscriptionResolver<Maybe<ResolversTypes['User']>, "user", ParentType, ContextType, RequireFields<SubscriptionUserArgs, 'id'>>;
  workspace?: SubscriptionResolver<Maybe<ResolversTypes['Workspace']>, "workspace", ParentType, ContextType, RequireFields<SubscriptionWorkspaceArgs, 'id'>>;
};

export type SynchronizerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Synchronizer'] = ResolversParentTypes['Synchronizer']> = {
  current_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  listen_deletion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  running?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  ssl_verify?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  stream_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SynchronizerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerConnection'] = ResolversParentTypes['SynchronizerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SynchronizerEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SynchronizerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerEdge'] = ResolversParentTypes['SynchronizerEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Synchronizer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SynchronizerEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SynchronizerEditMutations'] = ResolversParentTypes['SynchronizerEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Synchronizer']>, ParentType, ContextType, RequireFields<SynchronizerEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemResolvers<ContextType = any, ParentType extends ResolversParentTypes['System'] = ResolversParentTypes['System']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<SystemConnectorsArgs>>;
  contact_information?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<SystemExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identity_class?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<SystemJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<SystemNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<SystemOpinionsArgs>>;
  organizations?: Resolver<Maybe<ResolversTypes['OrganizationConnection']>, ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<SystemPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<SystemReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<SystemStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  x_opencti_firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemConnection'] = ResolversParentTypes['SystemConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['SystemEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemEdge'] = ResolversParentTypes['SystemEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['System'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemEditMutations'] = ResolversParentTypes['SystemEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, Partial<SystemEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, RequireFields<SystemEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<SystemEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['System']>, ParentType, ContextType, RequireFields<SystemEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaskResolvers<ContextType = any, ParentType extends ResolversParentTypes['Task'] = ResolversParentTypes['Task']> = {
  __resolveType: TypeResolveFn<'ListTask' | 'QueryTask' | 'RuleTask', ParentType, ContextType>;
  actions?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskAction']>>>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskError']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  last_execution_date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  task_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  task_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskType']>, ParentType, ContextType>;
};

export type TaskActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskAction'] = ResolversParentTypes['TaskAction']> = {
  context?: Resolver<Maybe<ResolversTypes['TaskContext']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskActionType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaskConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskConnection'] = ResolversParentTypes['TaskConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaskConnectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaskConnectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskConnectionEdge'] = ResolversParentTypes['TaskConnectionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Task'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaskContextResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskContext'] = ResolversParentTypes['TaskContext']> = {
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TaskContextType']>, ParentType, ContextType>;
  values?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaskErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaskError'] = ResolversParentTypes['TaskError']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxiiCollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollection'] = ResolversParentTypes['TaxiiCollection']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxiiCollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionConnection'] = ResolversParentTypes['TaxiiCollectionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['TaxiiCollectionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxiiCollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionEdge'] = ResolversParentTypes['TaxiiCollectionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['TaxiiCollection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxiiCollectionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxiiCollectionEditMutations'] = ResolversParentTypes['TaxiiCollectionEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['TaxiiCollection']>, ParentType, ContextType, RequireFields<TaxiiCollectionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TextResolvers<ContextType = any, ParentType extends ResolversParentTypes['Text'] = ResolversParentTypes['Text']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<TextConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<TextExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<TextIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<TextJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<TextNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<TextOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<TextPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<TextReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<TextStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<TextStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ThreatActorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActor'] = ResolversParentTypes['ThreatActor']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ThreatActorConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ThreatActorExternalReferencesArgs>>;
  first_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  goals?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ThreatActorJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  last_seen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locations?: Resolver<Maybe<ResolversTypes['LocationConnection']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ThreatActorNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ThreatActorOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ThreatActorPendingFilesArgs>>;
  personal_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  primary_motivation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ThreatActorReportsArgs>>;
  resource_level?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  secondary_motivations?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  sophistication?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ThreatActorStixCoreRelationshipsArgs>>;
  threat_actor_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ThreatActorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorConnection'] = ResolversParentTypes['ThreatActorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ThreatActorEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ThreatActorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorEdge'] = ResolversParentTypes['ThreatActorEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ThreatActor'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ThreatActorEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ThreatActorEditMutations'] = ResolversParentTypes['ThreatActorEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, Partial<ThreatActorEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, RequireFields<ThreatActorEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ThreatActorEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['ThreatActor']>, ParentType, ContextType, RequireFields<ThreatActorEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeSeriesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeSeries'] = ResolversParentTypes['TimeSeries']> = {
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ToolResolvers<ContextType = any, ParentType extends ResolversParentTypes['Tool'] = ResolversParentTypes['Tool']> = {
  aliases?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<ToolConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<ToolExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<ToolJobsArgs>>;
  killChainPhases?: Resolver<Maybe<ResolversTypes['KillChainPhaseConnection']>, ParentType, ContextType>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<ToolNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<ToolOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<ToolPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<ToolReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<ToolStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tool_types?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  tool_version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ToolConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolConnection'] = ResolversParentTypes['ToolConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['ToolEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ToolEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolEdge'] = ResolversParentTypes['ToolEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Tool'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ToolEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ToolEditMutations'] = ResolversParentTypes['ToolEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, Partial<ToolEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, RequireFields<ToolEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<ToolEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Tool']>, ParentType, ContextType, RequireFields<ToolEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UploadScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type UrlResolvers<ContextType = any, ParentType extends ResolversParentTypes['Url'] = ResolversParentTypes['Url']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UrlConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UrlExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UrlIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UrlJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UrlNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UrlOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UrlPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UrlReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UrlStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UrlStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  allowed_marking?: Resolver<Maybe<Array<Maybe<ResolversTypes['MarkingDefinition']>>>, ParentType, ContextType>;
  api_token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  capabilities?: Resolver<Array<Maybe<ResolversTypes['Capability']>>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dashboard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  firstname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<ResolversTypes['GroupConnection']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  roles?: Resolver<Array<Maybe<ResolversTypes['Role']>>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['SessionDetail']>>>, ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  theme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userSubscriptions?: Resolver<Maybe<ResolversTypes['UserSubscriptionConnection']>, ParentType, ContextType, Partial<UserUserSubscriptionsArgs>>;
  user_email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAccount'] = ResolversParentTypes['UserAccount']> = {
  account_created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_expires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_first_login?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_last_login?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  account_login?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  account_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  can_escalate_privs?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UserAccountConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  credential?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  credential_last_changed?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  display_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountExportFilesArgs>>;
  extensions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UserAccountExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UserAccountIndicatorsArgs>>;
  is_disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_privileged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  is_service_account?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UserAccountJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UserAccountNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UserAccountOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAccountPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UserAccountReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UserAccountStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UserAccountStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAgentResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAgent'] = ResolversParentTypes['UserAgent']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<UserAgentConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<UserAgentExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<UserAgentIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<UserAgentJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<UserAgentNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<UserAgentOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<UserAgentPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<UserAgentReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<UserAgentStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<UserAgentStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEditMutations'] = ResolversParentTypes['UserEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<UserEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['InternalRelationship']>, ParentType, ContextType, Partial<UserEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<UserEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  tokenRenew?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSession'] = ResolversParentTypes['UserSession']> = {
  sessions?: Resolver<Maybe<Array<Maybe<ResolversTypes['SessionDetail']>>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscription'] = ResolversParentTypes['UserSubscription']> = {
  cron?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entities?: Resolver<Maybe<Array<Maybe<ResolversTypes['StixDomainObject']>>>, ParentType, ContextType>;
  entities_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  filters?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  last_run?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  options?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  user_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSubscriptionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionConnection'] = ResolversParentTypes['UserSubscriptionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['UserSubscriptionEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSubscriptionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionEdge'] = ResolversParentTypes['UserSubscriptionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserSubscription'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSubscriptionEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSubscriptionEditMutations'] = ResolversParentTypes['UserSubscriptionEditMutations']> = {
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['UserSubscription']>, ParentType, ContextType, RequireFields<UserSubscriptionEditMutationsFieldPatchArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VulnerabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Vulnerability'] = ResolversParentTypes['Vulnerability']> = {
  confidence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<VulnerabilityConnectorsArgs>>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<VulnerabilityExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityImportFilesArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<VulnerabilityJobsArgs>>;
  lang?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<VulnerabilityNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<VulnerabilityOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<VulnerabilityPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<VulnerabilityReportsArgs>>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Status']>, ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<VulnerabilityStixCoreRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  workflowEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  x_opencti_attack_vector?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_availability_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_base_score?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  x_opencti_base_severity?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_confidentiality_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_integrity_impact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VulnerabilityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityConnection'] = ResolversParentTypes['VulnerabilityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['VulnerabilityEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VulnerabilityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityEdge'] = ResolversParentTypes['VulnerabilityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Vulnerability'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VulnerabilityEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['VulnerabilityEditMutations'] = ResolversParentTypes['VulnerabilityEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, Partial<VulnerabilityEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, RequireFields<VulnerabilityEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<VulnerabilityEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Vulnerability']>, ParentType, ContextType, RequireFields<VulnerabilityEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WindowsRegistryKeyResolvers<ContextType = any, ParentType extends ResolversParentTypes['WindowsRegistryKey'] = ResolversParentTypes['WindowsRegistryKey']> = {
  attribute_key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<WindowsRegistryKeyConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<WindowsRegistryKeyJobsArgs>>;
  modified_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyNotesArgs>>;
  number_of_subkeys?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyPendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryKeyStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WindowsRegistryValueTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WindowsRegistryValueType'] = ResolversParentTypes['WindowsRegistryValueType']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<WindowsRegistryValueTypeConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  data_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<WindowsRegistryValueTypeJobsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<WindowsRegistryValueTypeStixCyberObservableRelationshipsArgs>>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkResolvers<ContextType = any, ParentType extends ResolversParentTypes['Work'] = ResolversParentTypes['Work']> = {
  completed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  completed_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  connector?: Resolver<Maybe<ResolversTypes['Connector']>, ParentType, ContextType>;
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  event_source_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  messages?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkMessage']>>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  processed_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  received_time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['State'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  tracking?: Resolver<Maybe<ResolversTypes['WorkTracking']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkConnection'] = ResolversParentTypes['WorkConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkEdge'] = ResolversParentTypes['WorkEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Work'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkEditMutations'] = ResolversParentTypes['WorkEditMutations']> = {
  addExpectations?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsAddExpectationsArgs>>;
  delete?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ping?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reportExpectation?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsReportExpectationArgs>>;
  toProcessed?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsToProcessedArgs>>;
  toReceived?: Resolver<ResolversTypes['ID'], ParentType, ContextType, Partial<WorkEditMutationsToReceivedArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkMessage'] = ResolversParentTypes['WorkMessage']> = {
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkTrackingResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkTracking'] = ResolversParentTypes['WorkTracking']> = {
  import_expected_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  import_last_processed?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  import_processed_number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkspaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Workspace'] = ResolversParentTypes['Workspace']> = {
  created_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  graph_data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  manifest?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  objects?: Resolver<Maybe<ResolversTypes['StixObjectOrStixRelationshipConnection']>, ParentType, ContextType, Partial<WorkspaceObjectsArgs>>;
  owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkspaceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceConnection'] = ResolversParentTypes['WorkspaceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['WorkspaceEdge']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkspaceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceEdge'] = ResolversParentTypes['WorkspaceEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Workspace'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WorkspaceEditMutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['WorkspaceEditMutations'] = ResolversParentTypes['WorkspaceEditMutations']> = {
  contextClean?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType>;
  contextPatch?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<WorkspaceEditMutationsContextPatchArgs>>;
  delete?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  fieldPatch?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsFieldPatchArgs, 'input'>>;
  relationAdd?: Resolver<Maybe<ResolversTypes['StixMetaRelationship']>, ParentType, ContextType, Partial<WorkspaceEditMutationsRelationAddArgs>>;
  relationDelete?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsRelationDeleteArgs, 'relationship_type' | 'toId'>>;
  relationsAdd?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, Partial<WorkspaceEditMutationsRelationsAddArgs>>;
  relationsDelete?: Resolver<Maybe<ResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<WorkspaceEditMutationsRelationsDeleteArgs, 'relationship_type' | 'toIds'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type X509CertificateResolvers<ContextType = any, ParentType extends ResolversParentTypes['X509Certificate'] = ResolversParentTypes['X509Certificate']> = {
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<X509CertificateConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificateExportFilesArgs>>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<X509CertificateExternalReferencesArgs>>;
  hashes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Hash']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificateImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<X509CertificateIndicatorsArgs>>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  is_self_signed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<X509CertificateJobsArgs>>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<X509CertificateNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<X509CertificateOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509CertificatePendingFilesArgs>>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<X509CertificateReportsArgs>>;
  serial_number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signature_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<X509CertificateStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<X509CertificateStixCyberObservableRelationshipsArgs>>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_public_key_algorithm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_public_key_exponent?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subject_public_key_modulus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validity_not_after?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validity_not_before?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type X509V3ExtensionsTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['X509V3ExtensionsType'] = ResolversParentTypes['X509V3ExtensionsType']> = {
  authority_key_identifier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basic_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  certificate_policies?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  connectors?: Resolver<Maybe<Array<Maybe<ResolversTypes['Connector']>>>, ParentType, ContextType, Partial<X509V3ExtensionsTypeConnectorsArgs>>;
  createdBy?: Resolver<Maybe<ResolversTypes['Identity']>, ParentType, ContextType>;
  created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  crl_distribution_points?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editContext?: Resolver<Maybe<Array<Maybe<ResolversTypes['EditUserContext']>>>, ParentType, ContextType>;
  entity_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exportFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeExportFilesArgs>>;
  extended_key_usage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalReferences?: Resolver<Maybe<ResolversTypes['ExternalReferenceConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeExternalReferencesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeImportFilesArgs>>;
  indicators?: Resolver<Maybe<ResolversTypes['IndicatorConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeIndicatorsArgs>>;
  inhibit_any_policy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  is_inferred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issuer_alternative_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobs?: Resolver<Maybe<Array<Maybe<ResolversTypes['Work']>>>, ParentType, ContextType, Partial<X509V3ExtensionsTypeJobsArgs>>;
  key_usage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notes?: Resolver<Maybe<ResolversTypes['NoteConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeNotesArgs>>;
  objectLabel?: Resolver<Maybe<ResolversTypes['LabelConnection']>, ParentType, ContextType>;
  objectMarking?: Resolver<Maybe<ResolversTypes['MarkingDefinitionConnection']>, ParentType, ContextType>;
  observable_value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  opinions?: Resolver<Maybe<ResolversTypes['OpinionConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeOpinionsArgs>>;
  parent_types?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  pendingFiles?: Resolver<Maybe<ResolversTypes['FileConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypePendingFilesArgs>>;
  policy_constraints?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  policy_mappings?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  private_key_usage_period_not_after?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  private_key_usage_period_not_before?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reports?: Resolver<Maybe<ResolversTypes['ReportConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeReportsArgs>>;
  spec_version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  standard_id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stixCoreRelationships?: Resolver<Maybe<ResolversTypes['StixCoreRelationshipConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeStixCoreRelationshipsArgs>>;
  stixCyberObservableRelationships?: Resolver<Maybe<ResolversTypes['StixCyberObservableRelationshipConnection']>, ParentType, ContextType, Partial<X509V3ExtensionsTypeStixCyberObservableRelationshipsArgs>>;
  subject_alternative_name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_directory_attributes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject_key_identifier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  toStix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  x_opencti_description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  x_opencti_inferences?: Resolver<Maybe<Array<Maybe<ResolversTypes['Inference']>>>, ParentType, ContextType>;
  x_opencti_score?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  x_opencti_stix_ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AckDetails?: AckDetailsResolvers<ContextType>;
  AppDebugDistribution?: AppDebugDistributionResolvers<ContextType>;
  AppDebugStatistics?: AppDebugStatisticsResolvers<ContextType>;
  AppInfo?: AppInfoResolvers<ContextType>;
  AppMemory?: AppMemoryResolvers<ContextType>;
  Artifact?: ArtifactResolvers<ContextType>;
  AttackPattern?: AttackPatternResolvers<ContextType>;
  AttackPatternConnection?: AttackPatternConnectionResolvers<ContextType>;
  AttackPatternEdge?: AttackPatternEdgeResolvers<ContextType>;
  AttackPatternEditMutations?: AttackPatternEditMutationsResolvers<ContextType>;
  Attribute?: AttributeResolvers<ContextType>;
  AttributeConnection?: AttributeConnectionResolvers<ContextType>;
  AttributeEdge?: AttributeEdgeResolvers<ContextType>;
  AttributeEditMutations?: AttributeEditMutationsResolvers<ContextType>;
  AutonomousSystem?: AutonomousSystemResolvers<ContextType>;
  BasicObject?: BasicObjectResolvers<ContextType>;
  BasicRelationship?: BasicRelationshipResolvers<ContextType>;
  Campaign?: CampaignResolvers<ContextType>;
  CampaignConnection?: CampaignConnectionResolvers<ContextType>;
  CampaignEdge?: CampaignEdgeResolvers<ContextType>;
  CampaignEditMutations?: CampaignEditMutationsResolvers<ContextType>;
  Capability?: CapabilityResolvers<ContextType>;
  CapabilityConnection?: CapabilityConnectionResolvers<ContextType>;
  CapabilityEdge?: CapabilityEdgeResolvers<ContextType>;
  City?: CityResolvers<ContextType>;
  CityConnection?: CityConnectionResolvers<ContextType>;
  CityEdge?: CityEdgeResolvers<ContextType>;
  CityEditMutations?: CityEditMutationsResolvers<ContextType>;
  Connector?: ConnectorResolvers<ContextType>;
  ConnectorConfig?: ConnectorConfigResolvers<ContextType>;
  ConstraintNumber?: GraphQLScalarType;
  ConstraintString?: GraphQLScalarType;
  Container?: ContainerResolvers<ContextType>;
  ContainerConnection?: ContainerConnectionResolvers<ContextType>;
  ContainerEdge?: ContainerEdgeResolvers<ContextType>;
  ContainerEditMutations?: ContainerEditMutationsResolvers<ContextType>;
  ContextData?: ContextDataResolvers<ContextType>;
  Country?: CountryResolvers<ContextType>;
  CountryConnection?: CountryConnectionResolvers<ContextType>;
  CountryEdge?: CountryEdgeResolvers<ContextType>;
  CountryEditMutations?: CountryEditMutationsResolvers<ContextType>;
  CourseOfAction?: CourseOfActionResolvers<ContextType>;
  CourseOfActionConnection?: CourseOfActionConnectionResolvers<ContextType>;
  CourseOfActionEdge?: CourseOfActionEdgeResolvers<ContextType>;
  CourseOfActionEditMutations?: CourseOfActionEditMutationsResolvers<ContextType>;
  CryptocurrencyWallet?: CryptocurrencyWalletResolvers<ContextType>;
  CryptographicKey?: CryptographicKeyResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  DependencyVersion?: DependencyVersionResolvers<ContextType>;
  Directory?: DirectoryResolvers<ContextType>;
  Distribution?: DistributionResolvers<ContextType>;
  DocsMetrics?: DocsMetricsResolvers<ContextType>;
  DomainName?: DomainNameResolvers<ContextType>;
  EditUserContext?: EditUserContextResolvers<ContextType>;
  ElasticSearchMetrics?: ElasticSearchMetricsResolvers<ContextType>;
  EmailAddr?: EmailAddrResolvers<ContextType>;
  EmailMessage?: EmailMessageResolvers<ContextType>;
  EmailMimePartType?: EmailMimePartTypeResolvers<ContextType>;
  ExternalReference?: ExternalReferenceResolvers<ContextType>;
  ExternalReferenceConnection?: ExternalReferenceConnectionResolvers<ContextType>;
  ExternalReferenceEdge?: ExternalReferenceEdgeResolvers<ContextType>;
  ExternalReferenceEditMutations?: ExternalReferenceEditMutationsResolvers<ContextType>;
  File?: FileResolvers<ContextType>;
  FileConnection?: FileConnectionResolvers<ContextType>;
  FileEdge?: FileEdgeResolvers<ContextType>;
  FileMetadata?: FileMetadataResolvers<ContextType>;
  GetMetrics?: GetMetricsResolvers<ContextType>;
  Group?: GroupResolvers<ContextType>;
  GroupConnection?: GroupConnectionResolvers<ContextType>;
  GroupEdge?: GroupEdgeResolvers<ContextType>;
  GroupEditMutations?: GroupEditMutationsResolvers<ContextType>;
  Hash?: HashResolvers<ContextType>;
  HashedObservable?: HashedObservableResolvers<ContextType>;
  Hostname?: HostnameResolvers<ContextType>;
  IPv4Addr?: IPv4AddrResolvers<ContextType>;
  IPv6Addr?: IPv6AddrResolvers<ContextType>;
  Identity?: IdentityResolvers<ContextType>;
  IdentityConnection?: IdentityConnectionResolvers<ContextType>;
  IdentityEdge?: IdentityEdgeResolvers<ContextType>;
  IdentityEditMutations?: IdentityEditMutationsResolvers<ContextType>;
  Incident?: IncidentResolvers<ContextType>;
  IncidentConnection?: IncidentConnectionResolvers<ContextType>;
  IncidentEdge?: IncidentEdgeResolvers<ContextType>;
  IncidentEditMutations?: IncidentEditMutationsResolvers<ContextType>;
  IndexingMetrics?: IndexingMetricsResolvers<ContextType>;
  Indicator?: IndicatorResolvers<ContextType>;
  IndicatorConnection?: IndicatorConnectionResolvers<ContextType>;
  IndicatorEdge?: IndicatorEdgeResolvers<ContextType>;
  IndicatorEditMutations?: IndicatorEditMutationsResolvers<ContextType>;
  Individual?: IndividualResolvers<ContextType>;
  IndividualConnection?: IndividualConnectionResolvers<ContextType>;
  IndividualEdge?: IndividualEdgeResolvers<ContextType>;
  IndividualEditMutations?: IndividualEditMutationsResolvers<ContextType>;
  Inference?: InferenceResolvers<ContextType>;
  InferenceAttribute?: InferenceAttributeResolvers<ContextType>;
  Infrastructure?: InfrastructureResolvers<ContextType>;
  InfrastructureConnection?: InfrastructureConnectionResolvers<ContextType>;
  InfrastructureEdge?: InfrastructureEdgeResolvers<ContextType>;
  InfrastructureEditMutations?: InfrastructureEditMutationsResolvers<ContextType>;
  InternalObject?: InternalObjectResolvers<ContextType>;
  InternalRelationship?: InternalRelationshipResolvers<ContextType>;
  IntrusionSet?: IntrusionSetResolvers<ContextType>;
  IntrusionSetConnection?: IntrusionSetConnectionResolvers<ContextType>;
  IntrusionSetEdge?: IntrusionSetEdgeResolvers<ContextType>;
  IntrusionSetEditMutations?: IntrusionSetEditMutationsResolvers<ContextType>;
  KillChainPhase?: KillChainPhaseResolvers<ContextType>;
  KillChainPhaseConnection?: KillChainPhaseConnectionResolvers<ContextType>;
  KillChainPhaseEdge?: KillChainPhaseEdgeResolvers<ContextType>;
  KillChainPhaseEditMutations?: KillChainPhaseEditMutationsResolvers<ContextType>;
  Label?: LabelResolvers<ContextType>;
  LabelConnection?: LabelConnectionResolvers<ContextType>;
  LabelEdge?: LabelEdgeResolvers<ContextType>;
  LabelEditMutations?: LabelEditMutationsResolvers<ContextType>;
  ListTask?: ListTaskResolvers<ContextType>;
  Location?: LocationResolvers<ContextType>;
  LocationConnection?: LocationConnectionResolvers<ContextType>;
  LocationEdge?: LocationEdgeResolvers<ContextType>;
  LocationEditMutations?: LocationEditMutationsResolvers<ContextType>;
  Log?: LogResolvers<ContextType>;
  LogConnection?: LogConnectionResolvers<ContextType>;
  LogEdge?: LogEdgeResolvers<ContextType>;
  LogsWorkerConfig?: LogsWorkerConfigResolvers<ContextType>;
  MacAddr?: MacAddrResolvers<ContextType>;
  Malware?: MalwareResolvers<ContextType>;
  MalwareConnection?: MalwareConnectionResolvers<ContextType>;
  MalwareEdge?: MalwareEdgeResolvers<ContextType>;
  MalwareEditMutations?: MalwareEditMutationsResolvers<ContextType>;
  MarkingDefinition?: MarkingDefinitionResolvers<ContextType>;
  MarkingDefinitionConnection?: MarkingDefinitionConnectionResolvers<ContextType>;
  MarkingDefinitionEdge?: MarkingDefinitionEdgeResolvers<ContextType>;
  MarkingDefinitionEditMutations?: MarkingDefinitionEditMutationsResolvers<ContextType>;
  MessagesStats?: MessagesStatsResolvers<ContextType>;
  Module?: ModuleResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Mutex?: MutexResolvers<ContextType>;
  NetworkTraffic?: NetworkTrafficResolvers<ContextType>;
  Note?: NoteResolvers<ContextType>;
  NoteConnection?: NoteConnectionResolvers<ContextType>;
  NoteEdge?: NoteEdgeResolvers<ContextType>;
  NoteEditMutations?: NoteEditMutationsResolvers<ContextType>;
  Number?: NumberResolvers<ContextType>;
  ObjectTotals?: ObjectTotalsResolvers<ContextType>;
  ObservedData?: ObservedDataResolvers<ContextType>;
  ObservedDataConnection?: ObservedDataConnectionResolvers<ContextType>;
  ObservedDataEdge?: ObservedDataEdgeResolvers<ContextType>;
  ObservedDataEditMutations?: ObservedDataEditMutationsResolvers<ContextType>;
  Opinion?: OpinionResolvers<ContextType>;
  OpinionConnection?: OpinionConnectionResolvers<ContextType>;
  OpinionEdge?: OpinionEdgeResolvers<ContextType>;
  OpinionEditMutations?: OpinionEditMutationsResolvers<ContextType>;
  Organization?: OrganizationResolvers<ContextType>;
  OrganizationConnection?: OrganizationConnectionResolvers<ContextType>;
  OrganizationEdge?: OrganizationEdgeResolvers<ContextType>;
  OrganizationEditMutations?: OrganizationEditMutationsResolvers<ContextType>;
  OrganizationOrIndividual?: OrganizationOrIndividualResolvers<ContextType>;
  OverviewMetrics?: OverviewMetricsResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Position?: PositionResolvers<ContextType>;
  PositionConnection?: PositionConnectionResolvers<ContextType>;
  PositionEdge?: PositionEdgeResolvers<ContextType>;
  PositionEditMutations?: PositionEditMutationsResolvers<ContextType>;
  Process?: ProcessResolvers<ContextType>;
  Provider?: ProviderResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  QueryTask?: QueryTaskResolvers<ContextType>;
  QueueArguments?: QueueArgumentsResolvers<ContextType>;
  QueueMetrics?: QueueMetricsResolvers<ContextType>;
  QueueTotals?: QueueTotalsResolvers<ContextType>;
  RabbitMQConnection?: RabbitMqConnectionResolvers<ContextType>;
  RabbitMQMetrics?: RabbitMqMetricsResolvers<ContextType>;
  Region?: RegionResolvers<ContextType>;
  RegionConnection?: RegionConnectionResolvers<ContextType>;
  RegionEdge?: RegionEdgeResolvers<ContextType>;
  RegionEditMutations?: RegionEditMutationsResolvers<ContextType>;
  Report?: ReportResolvers<ContextType>;
  ReportConnection?: ReportConnectionResolvers<ContextType>;
  ReportEdge?: ReportEdgeResolvers<ContextType>;
  ReportEditMutations?: ReportEditMutationsResolvers<ContextType>;
  RetentionRule?: RetentionRuleResolvers<ContextType>;
  RetentionRuleConnection?: RetentionRuleConnectionResolvers<ContextType>;
  RetentionRuleEdge?: RetentionRuleEdgeResolvers<ContextType>;
  RetentionRuleEditMutations?: RetentionRuleEditMutationsResolvers<ContextType>;
  Role?: RoleResolvers<ContextType>;
  RoleConnection?: RoleConnectionResolvers<ContextType>;
  RoleEdge?: RoleEdgeResolvers<ContextType>;
  RoleEditMutations?: RoleEditMutationsResolvers<ContextType>;
  Rule?: RuleResolvers<ContextType>;
  RuleExecutionError?: RuleExecutionErrorResolvers<ContextType>;
  RuleManager?: RuleManagerResolvers<ContextType>;
  RuleTask?: RuleTaskResolvers<ContextType>;
  SearchMetrics?: SearchMetricsResolvers<ContextType>;
  Sector?: SectorResolvers<ContextType>;
  SectorConnection?: SectorConnectionResolvers<ContextType>;
  SectorEdge?: SectorEdgeResolvers<ContextType>;
  SectorEditMutations?: SectorEditMutationsResolvers<ContextType>;
  SessionDetail?: SessionDetailResolvers<ContextType>;
  Settings?: SettingsResolvers<ContextType>;
  SettingsEditMutations?: SettingsEditMutationsResolvers<ContextType>;
  Software?: SoftwareResolvers<ContextType>;
  Status?: StatusResolvers<ContextType>;
  StatusConnection?: StatusConnectionResolvers<ContextType>;
  StatusEdge?: StatusEdgeResolvers<ContextType>;
  StatusTemplate?: StatusTemplateResolvers<ContextType>;
  StatusTemplateConnection?: StatusTemplateConnectionResolvers<ContextType>;
  StatusTemplateEdge?: StatusTemplateEdgeResolvers<ContextType>;
  StixCoreObject?: StixCoreObjectResolvers<ContextType>;
  StixCoreObjectConnection?: StixCoreObjectConnectionResolvers<ContextType>;
  StixCoreObjectEdge?: StixCoreObjectEdgeResolvers<ContextType>;
  StixCoreObjectEditMutations?: StixCoreObjectEditMutationsResolvers<ContextType>;
  StixCoreObjectOrStixCoreRelationship?: StixCoreObjectOrStixCoreRelationshipResolvers<ContextType>;
  StixCoreRelationship?: StixCoreRelationshipResolvers<ContextType>;
  StixCoreRelationshipConnection?: StixCoreRelationshipConnectionResolvers<ContextType>;
  StixCoreRelationshipEdge?: StixCoreRelationshipEdgeResolvers<ContextType>;
  StixCoreRelationshipEditMutations?: StixCoreRelationshipEditMutationsResolvers<ContextType>;
  StixCyberObservable?: StixCyberObservableResolvers<ContextType>;
  StixCyberObservableConnection?: StixCyberObservableConnectionResolvers<ContextType>;
  StixCyberObservableEdge?: StixCyberObservableEdgeResolvers<ContextType>;
  StixCyberObservableEditMutations?: StixCyberObservableEditMutationsResolvers<ContextType>;
  StixCyberObservableRelationship?: StixCyberObservableRelationshipResolvers<ContextType>;
  StixCyberObservableRelationshipConnection?: StixCyberObservableRelationshipConnectionResolvers<ContextType>;
  StixCyberObservableRelationshipEdge?: StixCyberObservableRelationshipEdgeResolvers<ContextType>;
  StixCyberObservableRelationshipEditMutations?: StixCyberObservableRelationshipEditMutationsResolvers<ContextType>;
  StixDomainObject?: StixDomainObjectResolvers<ContextType>;
  StixDomainObjectConnection?: StixDomainObjectConnectionResolvers<ContextType>;
  StixDomainObjectEdge?: StixDomainObjectEdgeResolvers<ContextType>;
  StixDomainObjectEditMutations?: StixDomainObjectEditMutationsResolvers<ContextType>;
  StixEditMutations?: StixEditMutationsResolvers<ContextType>;
  StixFile?: StixFileResolvers<ContextType>;
  StixMetaObject?: StixMetaObjectResolvers<ContextType>;
  StixMetaRelationship?: StixMetaRelationshipResolvers<ContextType>;
  StixMetaRelationshipConnection?: StixMetaRelationshipConnectionResolvers<ContextType>;
  StixMetaRelationshipEdge?: StixMetaRelationshipEdgeResolvers<ContextType>;
  StixObject?: StixObjectResolvers<ContextType>;
  StixObjectOrStixRelationship?: StixObjectOrStixRelationshipResolvers<ContextType>;
  StixObjectOrStixRelationshipConnection?: StixObjectOrStixRelationshipConnectionResolvers<ContextType>;
  StixObjectOrStixRelationshipEdge?: StixObjectOrStixRelationshipEdgeResolvers<ContextType>;
  StixRelationship?: StixRelationshipResolvers<ContextType>;
  StixRelationshipConnection?: StixRelationshipConnectionResolvers<ContextType>;
  StixRelationshipEdge?: StixRelationshipEdgeResolvers<ContextType>;
  StixRelationshipEditMutations?: StixRelationshipEditMutationsResolvers<ContextType>;
  StixSightingRelationship?: StixSightingRelationshipResolvers<ContextType>;
  StixSightingRelationshipConnection?: StixSightingRelationshipConnectionResolvers<ContextType>;
  StixSightingRelationshipEditMutations?: StixSightingRelationshipEditMutationsResolvers<ContextType>;
  StixSightingRelationshipsEdge?: StixSightingRelationshipsEdgeResolvers<ContextType>;
  StreamCollection?: StreamCollectionResolvers<ContextType>;
  StreamCollectionConnection?: StreamCollectionConnectionResolvers<ContextType>;
  StreamCollectionEdge?: StreamCollectionEdgeResolvers<ContextType>;
  StreamCollectionEditMutations?: StreamCollectionEditMutationsResolvers<ContextType>;
  SubType?: SubTypeResolvers<ContextType>;
  SubTypeConnection?: SubTypeConnectionResolvers<ContextType>;
  SubTypeEdge?: SubTypeEdgeResolvers<ContextType>;
  SubTypeEditMutations?: SubTypeEditMutationsResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  Synchronizer?: SynchronizerResolvers<ContextType>;
  SynchronizerConnection?: SynchronizerConnectionResolvers<ContextType>;
  SynchronizerEdge?: SynchronizerEdgeResolvers<ContextType>;
  SynchronizerEditMutations?: SynchronizerEditMutationsResolvers<ContextType>;
  System?: SystemResolvers<ContextType>;
  SystemConnection?: SystemConnectionResolvers<ContextType>;
  SystemEdge?: SystemEdgeResolvers<ContextType>;
  SystemEditMutations?: SystemEditMutationsResolvers<ContextType>;
  Task?: TaskResolvers<ContextType>;
  TaskAction?: TaskActionResolvers<ContextType>;
  TaskConnection?: TaskConnectionResolvers<ContextType>;
  TaskConnectionEdge?: TaskConnectionEdgeResolvers<ContextType>;
  TaskContext?: TaskContextResolvers<ContextType>;
  TaskError?: TaskErrorResolvers<ContextType>;
  TaxiiCollection?: TaxiiCollectionResolvers<ContextType>;
  TaxiiCollectionConnection?: TaxiiCollectionConnectionResolvers<ContextType>;
  TaxiiCollectionEdge?: TaxiiCollectionEdgeResolvers<ContextType>;
  TaxiiCollectionEditMutations?: TaxiiCollectionEditMutationsResolvers<ContextType>;
  Text?: TextResolvers<ContextType>;
  ThreatActor?: ThreatActorResolvers<ContextType>;
  ThreatActorConnection?: ThreatActorConnectionResolvers<ContextType>;
  ThreatActorEdge?: ThreatActorEdgeResolvers<ContextType>;
  ThreatActorEditMutations?: ThreatActorEditMutationsResolvers<ContextType>;
  TimeSeries?: TimeSeriesResolvers<ContextType>;
  Tool?: ToolResolvers<ContextType>;
  ToolConnection?: ToolConnectionResolvers<ContextType>;
  ToolEdge?: ToolEdgeResolvers<ContextType>;
  ToolEditMutations?: ToolEditMutationsResolvers<ContextType>;
  Upload?: GraphQLScalarType;
  Url?: UrlResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserAccount?: UserAccountResolvers<ContextType>;
  UserAgent?: UserAgentResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserEditMutations?: UserEditMutationsResolvers<ContextType>;
  UserSession?: UserSessionResolvers<ContextType>;
  UserSubscription?: UserSubscriptionResolvers<ContextType>;
  UserSubscriptionConnection?: UserSubscriptionConnectionResolvers<ContextType>;
  UserSubscriptionEdge?: UserSubscriptionEdgeResolvers<ContextType>;
  UserSubscriptionEditMutations?: UserSubscriptionEditMutationsResolvers<ContextType>;
  Vulnerability?: VulnerabilityResolvers<ContextType>;
  VulnerabilityConnection?: VulnerabilityConnectionResolvers<ContextType>;
  VulnerabilityEdge?: VulnerabilityEdgeResolvers<ContextType>;
  VulnerabilityEditMutations?: VulnerabilityEditMutationsResolvers<ContextType>;
  WindowsRegistryKey?: WindowsRegistryKeyResolvers<ContextType>;
  WindowsRegistryValueType?: WindowsRegistryValueTypeResolvers<ContextType>;
  Work?: WorkResolvers<ContextType>;
  WorkConnection?: WorkConnectionResolvers<ContextType>;
  WorkEdge?: WorkEdgeResolvers<ContextType>;
  WorkEditMutations?: WorkEditMutationsResolvers<ContextType>;
  WorkMessage?: WorkMessageResolvers<ContextType>;
  WorkTracking?: WorkTrackingResolvers<ContextType>;
  Workspace?: WorkspaceResolvers<ContextType>;
  WorkspaceConnection?: WorkspaceConnectionResolvers<ContextType>;
  WorkspaceEdge?: WorkspaceEdgeResolvers<ContextType>;
  WorkspaceEditMutations?: WorkspaceEditMutationsResolvers<ContextType>;
  X509Certificate?: X509CertificateResolvers<ContextType>;
  X509V3ExtensionsType?: X509V3ExtensionsTypeResolvers<ContextType>;
};

export type DirectiveResolvers<ContextType = any> = {
  auth?: AuthDirectiveResolver<any, any, ContextType>;
  constraint?: ConstraintDirectiveResolver<any, any, ContextType>;
};
